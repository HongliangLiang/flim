{'guid': '1839d9b_d6f26064d6f489ae6e1a681139e58eb7223837a0', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public static Panel new_Panel ( final Composite parent ) { int handle = parent . handle ; final WEmbeddedFrame frame = new WEmbeddedFrame ( handle ) ; Panel panel = new Panel ( ) ; frame . add ( panel ) ; parent . addListener ( SWT . Activate , new Listener ( ) { public void handleEvent ( Event e ) { frame . dispatchEvent ( new WindowEvent ( frame , WindowEvent . WINDOW_ACTIVATED ) ) ; frame . dispatchEvent ( new FocusEvent ( frame , FocusEvent . FOCUS_GAINED ) ) ; } } ) ; parent . addListener ( SWT . Deactivate , new Listener ( ) { public void handleEvent ( Event e ) { frame . dispatchEvent ( new WindowEvent ( frame , WindowEvent . WINDOW_DEACTIVATED ) ) ; frame . dispatchEvent ( new FocusEvent ( frame , FocusEvent . FOCUS_LOST ) ) ; } } ) ; parent . addListener ( SWT . Resize , new Listener ( ) { public void handleEvent ( Event e ) { Rectangle rect = parent . getClientArea ( ) ; frame . setSize ( rect . width , rect . height ) ; frame . validate ( ) ; } } ) ; parent . addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event e ) { frame . dispose ( ) ; } } ) ; return panel ; }', 'public void handleEvent ( Event e ) { frame . dispatchEvent ( new WindowEvent ( frame , WindowEvent . WINDOW_ACTIVATED ) ) ; frame . dispatchEvent ( new FocusEvent ( frame , FocusEvent . FOCUS_GAINED ) ) ; }', 'public void handleEvent ( Event e ) { frame . dispatchEvent ( new WindowEvent ( frame , WindowEvent . WINDOW_DEACTIVATED ) ) ; frame . dispatchEvent ( new FocusEvent ( frame , FocusEvent . FOCUS_LOST ) ) ; }', 'public void handleEvent ( Event e ) { Rectangle rect = parent . getClientArea ( ) ; frame . setSize ( rect . width , rect . height ) ; frame . validate ( ) ; }', 'public void handleEvent ( Event e ) { frame . dispose ( ) ; }', 'public static Shell new_Shell ( Display display , final Canvas parent ) { DrawingSurface ds = ( DrawingSurface ) parent . getPeer ( ) ; WDrawingSurfaceInfo wds = ( WDrawingSurfaceInfo ) ds . getDrawingSurfaceInfo ( ) ; wds . lock ( ) ; int handle = wds . getHWnd ( ) ; wds . unlock ( ) ; final Shell shell = Shell . win32_new ( display , handle ) ; final Display newDisplay = shell . getDisplay ( ) ; parent . addComponentListener ( new ComponentAdapter ( ) { public void componentResized ( ComponentEvent e ) { newDisplay . syncExec ( new Runnable ( ) { public void run ( ) { Dimension dim = parent . getSize ( ) ; shell . setSize ( dim . width , dim . height ) ; } } ) ; } } ) ; shell . setVisible ( true ) ; return shell ; }', 'public void componentResized ( ComponentEvent e ) { newDisplay . syncExec ( new Runnable ( ) { public void run ( ) { Dimension dim = parent . getSize ( ) ; shell . setSize ( dim . width , dim . height ) ; } } ) ; }', 'public void run ( ) { Dimension dim = parent . getSize ( ) ; shell . setSize ( dim . width , dim . height ) ; }'], 'label': 0}
{'guid': '1839d9b_4ff9c6a4e73ae1584914d0d3b62a941606412fef', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public AnimatedProgress ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; if ( ( style SWT . VERTICAL ) ! = 0 ) { orientation = SWT . VERTICAL ; } showBorder = ( style SWT . BORDER ) ! = 0 ; addControlListener ( new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { redraw ( ) ; } } ) ; addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent e ) { paint ( e ) ; } } ) ; addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { stop ( ) ; } } ) ; }', 'public void controlResized ( ControlEvent e ) { redraw ( ) ; }', 'public void paintControl ( PaintEvent e ) { paint ( e ) ; }', 'public void widgetDisposed ( DisposeEvent e ) { stop ( ) ; }', 'private static int checkStyle ( int style ) { int mask = SWT . NONE ; return style mask ; }', '/ * * * Stop the animation if it is not already stopped and * reset the presentation to a blank appearance . * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public synchronized void clear ( ) { checkWidget ( ) ; if ( active ) stop ( ) ; showStripes = false ; redraw ( ) ; }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; Point size = null ; if ( orientation = = SWT . HORIZONTAL ) { size = new Point ( DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; } else { size = new Point ( DEFAULT_HEIGHT , DEFAULT_WIDTH ) ; } if ( wHint ! = SWT . DEFAULT ) size . x = wHint ; if ( hHint ! = SWT . DEFAULT ) size . y = hHint ; return size ; }', 'private void drawBevelRect ( GC gc , int x , int y , int w , int h , Color topleft , Color bottomright ) { gc . setForeground ( topleft ) ; gc . drawLine ( x , y , x + w - 1 , y ) ; gc . drawLine ( x , y , x , y + h - 1 ) ; gc . setForeground ( bottomright ) ; gc . drawLine ( x + w , y , x + w , y + h ) ; gc . drawLine ( x , y + h , x + w , y + h ) ; }', 'private void paint ( PaintEvent event ) { GC gc = event . gc ; Display disp = getDisplay ( ) ; Rectangle rect = getClientArea ( ) ; gc . fillRectangle ( rect ) ; if ( showBorder ) { drawBevelRect ( gc , rect . x , rect . y , rect . width - 1 , rect . height - 1 , disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) , disp . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ) ; } paintStripes ( gc ) ; }', 'private void paintStripes ( GC gc ) { if ( ! showStripes ) return ; Rectangle rect = getClientArea ( ) ; / / Subtracted border painted by paint . rect = new Rectangle ( rect . x + 2 , rect . y + 2 , rect . width - 4 , rect . height - 4 ) ; gc . setLineWidth ( 2 ) ; gc . setClipping ( rect ) ; Color color = getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_SELECTION ) ; gc . setBackground ( color ) ; gc . fillRectangle ( rect ) ; gc . setForeground ( this . getBackground ( ) ) ; int step = 12 ; int foregroundValue = value = = 0 ? step - 2 : value - 2 ; if ( orientation = = SWT . HORIZONTAL ) { int y = rect . y - 1 ; int w = rect . width ; int h = rect . height + 2 ; for ( int i = 0 ; i < w ; i + = step ) { int x = i + foregroundValue ; gc . drawLine ( x , y , x , h ) ; } } else { int x = rect . x - 1 ; int w = rect . width + 2 ; int h = rect . height ; for ( int i = 0 ; i < h ; i + = step ) { int y = i + foregroundValue ; gc . drawLine ( x , y , w , y ) ; } } if ( active ) { value = ( value + 2 ) step ; } }', '/ * * * Start the animation . * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public synchronized void start ( ) { checkWidget ( ) ; if ( active ) return ; active = true ; showStripes = true ; final Display display = getDisplay ( ) ; final Runnable timer = new Runnable 1 ; timer 0 = new Runnable ( ) { public void run ( ) { if ( ! active ) return ; GC gc = new GC ( AnimatedProgress . this ) ; paintStripes ( gc ) ; gc . dispose ( ) ; display . timerExec ( SLEEP , timer 0 ) ; } } ; display . timerExec ( SLEEP , timer 0 ) ; }', 'public void run ( ) { if ( ! active ) return ; GC gc = new GC ( AnimatedProgress . this ) ; paintStripes ( gc ) ; gc . dispose ( ) ; display . timerExec ( SLEEP , timer 0 ) ; }', '/ * * * Stop the animation . Freeze the presentation at its current appearance . * / public synchronized void stop ( ) { / / checkWidget ( ) ; active = false ; }'], 'label': 0}
{'guid': '1839d9b_9c9394c8bb511bde7ecdabe6aea93245b0456310', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['BidiSegmentEvent ( StyledTextEvent e ) { super ( e ) ; lineOffset = e . detail ; lineText = e . text ; }'], 'label': 0}
{'guid': '1839d9b_806a7ecbba86472076932f3e5354f619a6bf82cb', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * This method is called when a line needs to be reordered for * measuring or rendering in a bidi locale . * < p > * * param event . lineOffset line start offset ( input ) * param event . lineText line text ( input ) * param event . segments text segments that should be reordered * separately . ( output ) * see BidiSegmentEvent * / public void lineGetSegments ( BidiSegmentEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_fc640a5a31e4b2b0133671b80d3828a02d9f2a43', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Runs the given < code > Runnable < / code > while providing * busy feedback using this busy indicator . * * param the display on which the busy feedback should be * displayed . If the display is null , the Display for the current * thread will be used . If there is no Display for the current thread , * the runnable code will be executed and no busy feedback will be displayed . * param the runnable for which busy feedback is to be shown * see showWhile * / public static void showWhile ( Display display , Runnable runnable ) { if ( display = = null ) { display = Display . getCurrent ( ) ; if ( display = = null ) { runnable . run ( ) ; return ; } } Integer busyId = new Integer ( nextBusyId ) ; nextBusyId + + ; Cursor cursor = new Cursor ( display , SWT . CURSOR_WAIT ) ; Shell shells = display . getShells ( ) ; for ( int i = 0 ; i < shells . length ; i + + ) { Integer id = ( Integer ) shells i . getData ( BUSYID_NAME ) ; if ( id = = null ) { shells i . setCursor ( cursor ) ; shells i . setData ( BUSYID_NAME , busyId ) ; } } try { runnable . run ( ) ; } finally { shells = display . getShells ( ) ; for ( int i = 0 ; i < shells . length ; i + + ) { Integer id = ( Integer ) shells i . getData ( BUSYID_NAME ) ; if ( id = = busyId ) { shells i . setCursor ( null ) ; shells i . setData ( BUSYID_NAME , null ) ; } } if ( cursor ! = null ! cursor . isDisposed ( ) ) { cursor . dispose ( ) ; } } }'], 'label': 0}
{'guid': '1839d9b_32707344f7475aa44197258957e19ef8ddd4a682', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public CCombo ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; style = getStyle ( ) ; int textStyle = SWT . SINGLE ; if ( ( style SWT . READ_ONLY ) ! = 0 ) textStyle = SWT . READ_ONLY ; if ( ( style SWT . FLAT ) ! = 0 ) textStyle = SWT . FLAT ; text = new Text ( this , textStyle ) ; popup = new Shell ( getShell ( ) , SWT . NO_TRIM ) ; int listStyle = SWT . SINGLE SWT . V_SCROLL ; if ( ( style SWT . FLAT ) ! = 0 ) listStyle = SWT . FLAT ; list = new List ( popup , listStyle ) ; int arrowStyle = SWT . ARROW SWT . DOWN ; if ( ( style SWT . FLAT ) ! = 0 ) arrowStyle = SWT . FLAT ; arrow = new Button ( this , arrowStyle ) ; Listener listener = new Listener ( ) { public void handleEvent ( Event event ) { if ( popup = = event . widget ) { popupEvent ( event ) ; return ; } if ( text = = event . widget ) { textEvent ( event ) ; return ; } if ( list = = event . widget ) { listEvent ( event ) ; return ; } if ( arrow = = event . widget ) { arrowEvent ( event ) ; return ; } if ( CCombo . this = = event . widget ) { comboEvent ( event ) ; return ; } } } ; int comboEvents = { SWT . Dispose , SWT . Move , SWT . Resize } ; for ( int i = 0 ; i < comboEvents . length ; i + + ) this . addListener ( comboEvents i , listener ) ; int popupEvents = { SWT . Close , SWT . Paint , SWT . Deactivate } ; for ( int i = 0 ; i < popupEvents . length ; i + + ) popup . addListener ( popupEvents i , listener ) ; int textEvents = { SWT . KeyDown , SWT . KeyUp , SWT . Modify , SWT . MouseDown , SWT . MouseUp , SWT . Traverse , SWT . FocusIn , SWT . FocusOut } ; for ( int i = 0 ; i < textEvents . length ; i + + ) text . addListener ( textEvents i , listener ) ; int listEvents = { SWT . MouseUp , SWT . Selection , SWT . Traverse , SWT . KeyDown , SWT . KeyUp , SWT . FocusIn , SWT . FocusOut } ; for ( int i = 0 ; i < listEvents . length ; i + + ) list . addListener ( listEvents i , listener ) ; int arrowEvents = { SWT . MouseDown , SWT . FocusIn , SWT . FocusOut } ; for ( int i = 0 ; i < arrowEvents . length ; i + + ) arrow . addListener ( arrowEvents i , listener ) ; }', 'public void handleEvent ( Event event ) { if ( popup = = event . widget ) { popupEvent ( event ) ; return ; } if ( text = = event . widget ) { textEvent ( event ) ; return ; } if ( list = = event . widget ) { listEvent ( event ) ; return ; } if ( arrow = = event . widget ) { arrowEvent ( event ) ; return ; } if ( CCombo . this = = event . widget ) { comboEvent ( event ) ; return ; } }', 'static int checkStyle ( int style ) { int mask = SWT . BORDER SWT . READ_ONLY SWT . FLAT ; return style mask ; }', '/ * * * Adds an item . * < p > * The item is placed at the end of the list . * Indexing is zero based . * * param string the new item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when the string is null * exception SWTError ( ERROR_ITEM_NOT_ADDED ) * when the item cannot be added * / public void add ( String string ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; list . add ( string ) ; }', '/ * * * Adds an item at an index . * < p > * The item is placed at an index in the list . * Indexing is zero based . * * This operation will fail when the index is * out of range . * * param string the new item * param index the index for the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when the string is null * exception SWTError ( ERROR_ITEM_NOT_ADDED ) * when the item cannot be added * / public void add ( String string , int index ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; list . add ( string , index ) ; }', '/ * * * Adds the listener to receive events . * < p > * * param listener the listener * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when listener is null * / public void addModifyListener ( ModifyListener listener ) { ; checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Modify , typedListener ) ; }', '/ * * * Adds the listener to receive events . * < p > * * param listener the listener * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when listener is null * / public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Selection , typedListener ) ; addListener ( SWT . DefaultSelection , typedListener ) ; }', 'void arrowEvent ( Event event ) { switch ( event . type ) { case SWT . FocusIn : { if ( hasFocus ) return ; hasFocus = true ; if ( getEditable ( ) ) text . selectAll ( ) ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusIn , e ) ; break ; } case SWT . FocusOut : { Control focusControl = getDisplay ( ) . getFocusControl ( ) ; if ( focusControl = = list focusControl = = text ) return ; hasFocus = false ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusOut , e ) ; break ; } case SWT . MouseDown : { if ( event . button ! = 1 ) return ; dropDown ( ! isDropped ( ) ) ; break ; } } }', '/ * * * Clears the current selection . * < p > * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public void clearSelection ( ) { checkWidget ( ) ; text . clearSelection ( ) ; list . deselectAll ( ) ; }', 'void comboEvent ( Event event ) { switch ( event . type ) { case SWT . Dispose : if ( popup ! = null ! popup . isDisposed ( ) ) popup . dispose ( ) ; popup = null ; text = null ; list = null ; arrow = null ; break ; case SWT . Move : dropDown ( false ) ; break ; case SWT . Resize : internalLayout ( ) ; break ; } }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int width = 0 , height = 0 ; Point textSize = text . computeSize ( wHint , SWT . DEFAULT , changed ) ; Point arrowSize = arrow . computeSize ( SWT . DEFAULT , SWT . DEFAULT , changed ) ; Point listSize = list . computeSize ( wHint , SWT . DEFAULT , changed ) ; Point barSize = list . getVerticalBar ( ) . getSize ( ) ; int borderWidth = getBorderWidth ( ) ; height = Math . max ( hHint , Math . max ( textSize . y , arrowSize . y ) + 2 * borderWidth ) ; width = Math . max ( wHint , Math . max ( textSize . x + arrowSize . x + 2 * borderWidth , listSize . x + 2 ) ) ; return new Point ( width , height ) ; }', '/ * * * Deselects an item . * < p > * If the item at an index is selected , it is * deselected . If the item at an index is not * selected , it remains deselected . Indices * that are out of range are ignored . Indexing * is zero based . * * param index the index of the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public void deselect ( int index ) { checkWidget ( ) ; list . deselect ( index ) ; }', '/ * * * Deselects all items . * < p > * * If an item is selected , it is deselected . * If an item is not selected , it remains unselected . * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public void deselectAll ( ) { checkWidget ( ) ; list . deselectAll ( ) ; }', 'void dropDown ( boolean drop ) { if ( drop = = isDropped ( ) ) return ; if ( ! drop ) { popup . setVisible ( false ) ; text . setFocus ( ) ; return ; } int index = list . getSelectionIndex ( ) ; if ( index ! = - 1 ) list . setTopIndex ( index ) ; Rectangle listRect = list . getBounds ( ) ; int borderWidth = getBorderWidth ( ) ; Point point = toDisplay ( new Point ( 0 - borderWidth , 0 - borderWidth ) ) ; Point comboSize = getSize ( ) ; popup . setBounds ( point . x , point . y + comboSize . y , comboSize . x , listRect . height + 2 ) ; popup . setVisible ( true ) ; list . setFocus ( ) ; }', 'public Control getChildren ( ) { checkWidget ( ) ; return new Control 0 ; }', 'boolean getEditable ( ) { return text . getEditable ( ) ; }', '/ * * * Gets an item at an index . * < p > * Indexing is zero based . * * This operation will fail when the index is out * of range or an item could not be queried from * the OS . * * param index the index of the item * return the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_CANNOT_GET_ITEM ) * when the operation fails * / public String getItem ( int index ) { checkWidget ( ) ; return list . getItem ( index ) ; }', '/ * * * Gets the number of items . * < p > * This operation will fail if the number of * items could not be queried from the OS . * * return the number of items in the widget * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_CANNOT_GET_COUNT ) * when the operation fails * / public int getItemCount ( ) { checkWidget ( ) ; return list . getItemCount ( ) ; }', '/ * * * Gets the height of one item . * < p > * This operation will fail if the height of * one item could not be queried from the OS . * * return the height of one item in the widget * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_CANNOT_GET_ITEM_HEIGHT ) * when the operation fails * / public int getItemHeight ( ) { checkWidget ( ) ; return list . getItemHeight ( ) ; }', '/ * * * Gets the items . * < p > * This operation will fail if the items cannot * be queried from the OS . * * return the items in the widget * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_CANNOT_GET_ITEM ) * when the operation fails * / public String getItems ( ) { checkWidget ( ) ; return list . getItems ( ) ; }', '/ * * * Gets the selection . * < p > * return a point representing the selection start and end * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public Point getSelection ( ) { checkWidget ( ) ; return text . getSelection ( ) ; }', '/ * * * Gets the index of the selected item . * < p > * Indexing is zero based . * If no item is selected - 1 is returned . * * return the index of the selected item . * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public int getSelectionIndex ( ) { checkWidget ( ) ; return list . getSelectionIndex ( ) ; }', '/ * * * Gets the widget text . * < p > * If the widget has no text , an empty string is returned . * * return the widget text * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public String getText ( ) { checkWidget ( ) ; return text . getText ( ) ; }', '/ * * * Gets the height of the combo s text field . * < p > * The operation will fail if the height cannot * be queried from the OS . * return the height of the combo s text field . * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_ERROR_CANNOT_GET_ITEM_HEIGHT ) * when the operation fails * / public int getTextHeight ( ) { checkWidget ( ) ; return text . getLineHeight ( ) ; }', '/ * * * Gets the text limit . * < p > * return the text limit * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public int getTextLimit ( ) { checkWidget ( ) ; return text . getTextLimit ( ) ; }', '/ * * * Gets the index of an item . * < p > * The list is searched starting at 0 until an * item is found that is equal to the search item . * If no item is found , - 1 is returned . Indexing * is zero based . * * param string the search item * return the index of the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when string is null * / public int indexOf ( String string ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; return list . indexOf ( string ) ; }', '/ * * * Gets the index of an item . * < p > * The widget is searched starting at start including * the end position until an item is found that * is equal to the search itenm . If no item is * found , - 1 is returned . Indexing is zero based . * * param string the search item * param index the starting position * return the index of the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when string is null * / public int indexOf ( String string , int start ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; return list . indexOf ( string , start ) ; }', 'boolean isDropped ( ) { return popup . getVisible ( ) ; }', 'public boolean isFocusControl ( ) { checkWidget ( ) ; if ( text . isFocusControl ( ) arrow . isFocusControl ( ) list . isFocusControl ( ) popup . isFocusControl ( ) ) { return true ; } else { return super . isFocusControl ( ) ; } }', 'void internalLayout ( ) { if ( isDropped ( ) ) dropDown ( false ) ; Rectangle rect = getClientArea ( ) ; int width = rect . width ; int height = rect . height ; Point arrowSize = arrow . computeSize ( SWT . DEFAULT , height ) ; text . setBounds ( 0 , 0 , width - arrowSize . x , height ) ; arrow . setBounds ( width - arrowSize . x , 0 , arrowSize . x , arrowSize . y ) ; Point size = getSize ( ) ; int listHeight = list . getItemHeight ( ) * ITEMS_SHOWING ; Rectangle trim = list . computeTrim ( 0 , 0 , size . x - 2 , listHeight ) ; list . setBounds ( 1 , 1 , size . x - 2 , trim . height ) ; }', 'void listEvent ( Event event ) { switch ( event . type ) { case SWT . FocusIn : { if ( hasFocus ) return ; hasFocus = true ; if ( getEditable ( ) ) text . selectAll ( ) ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusIn , e ) ; break ; } case SWT . FocusOut : { Control focusControl = getDisplay ( ) . getFocusControl ( ) ; if ( focusControl = = text focusControl = = arrow ) return ; hasFocus = false ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusOut , e ) ; break ; } case SWT . MouseUp : { if ( event . button ! = 1 ) return ; dropDown ( false ) ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . DefaultSelection , e ) ; break ; } case SWT . Selection : { int index = list . getSelectionIndex ( ) ; if ( index = = - 1 ) return ; text . setText ( list . getItem ( index ) ) ; text . selectAll ( ) ; list . setSelection ( index ) ; Event e = new Event ( ) ; e . time = event . time ; e . stateMask = event . stateMask ; e . doit = event . doit ; notifyListeners ( SWT . Selection , e ) ; event . doit = e . doit ; break ; } case SWT . Traverse : { switch ( event . detail ) { case SWT . TRAVERSE_TAB_NEXT : case SWT . TRAVERSE_RETURN : case SWT . TRAVERSE_ESCAPE : case SWT . TRAVERSE_ARROW_PREVIOUS : case SWT . TRAVERSE_ARROW_NEXT : event . doit = false ; break ; } Event e = new Event ( ) ; e . time = event . time ; e . detail = event . detail ; e . doit = event . doit ; e . keyCode = event . keyCode ; notifyListeners ( SWT . Traverse , e ) ; event . doit = e . doit ; break ; } case SWT . KeyUp : { Event e = new Event ( ) ; e . time = event . time ; e . character = event . character ; e . keyCode = event . keyCode ; e . stateMask = event . stateMask ; notifyListeners ( SWT . KeyUp , e ) ; break ; } case SWT . KeyDown : { if ( event . character = = SWT . ESC ) { / / escape key cancels popup list dropDown ( false ) ; } if ( event . character = = SWT . CR event . character = = t ) { / / Enter and Tab cause default selection dropDown ( false ) ; Event e = new Event ( ) ; e . time = event . time ; e . stateMask = event . stateMask ; notifyListeners ( SWT . DefaultSelection , e ) ; } / / At this point the widget may have been disposed . / / If so , do not continue . if ( isDisposed ( ) ) break ; Event e = new Event ( ) ; e . time = event . time ; e . character = event . character ; e . keyCode = event . keyCode ; e . stateMask = event . stateMask ; notifyListeners ( SWT . KeyDown , e ) ; break ; } } }', 'void popupEvent ( Event event ) { switch ( event . type ) { case SWT . Paint : / / draw black rectangle around list Rectangle listRect = list . getBounds ( ) ; Color black = getDisplay ( ) . getSystemColor ( SWT . COLOR_BLACK ) ; event . gc . setForeground ( black ) ; event . gc . drawRectangle ( 0 , 0 , listRect . width + 1 , listRect . height + 1 ) ; break ; case SWT . Close : event . doit = false ; dropDown ( false ) ; break ; case SWT . Deactivate : dropDown ( false ) ; break ; } }', 'public void redraw ( int x , int y , int width , int height , boolean all ) { checkWidget ( ) ; if ( ! all ) return ; Point location = text . getLocation ( ) ; text . redraw ( x - location . x , y - location . y , width , height , all ) ; location = list . getLocation ( ) ; list . redraw ( x - location . x , y - location . y , width , height , all ) ; if ( arrow ! = null ) { location = arrow . getLocation ( ) ; arrow . redraw ( x - location . x , y - location . y , width , height , all ) ; } }', '/ * * * Removes an item at an index . * < p > * Indexing is zero based . * * This operation will fail when the index is out * of range or an item could not be removed from * the OS . * * param index the index of the item * return the selection state * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_ITEM_NOT_REMOVED ) * when the operation fails * / public void remove ( int index ) { checkWidget ( ) ; list . remove ( index ) ; }', '/ * * * Removes a range of items . * < p > * Indexing is zero based . The range of items * is from the start index up to and including * the end index . * * This operation will fail when the index is out * of range or an item could not be removed from * the OS . * * param start the start of the range * param end the end of the range * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_ITEM_NOT_REMOVED ) * when the operation fails * / public void remove ( int start , int end ) { checkWidget ( ) ; list . remove ( start , end ) ; }', '/ * * * Removes an item . * < p > * This operation will fail when the item * could not be removed from the OS . * * param string the search item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when string is null * exception SWTError ( ERROR_ITEM_NOT_REMOVED ) * when the operation fails * / public void remove ( String string ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; list . remove ( string ) ; }', '/ * * * Removes all items . * < p > * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public void removeAll ( ) { checkWidget ( ) ; text . setText ( "" ) ; list . removeAll ( ) ; }', '/ * * * Removes the listener . * < p > * * param listener the listener * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when listener is null * / public void removeModifyListener ( ModifyListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( SWT . Modify , listener ) ; }', '/ * * * Removes the listener . * < p > * * param listener the listener * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when listener is null * / public void removeSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( SWT . Selection , listener ) ; removeListener ( SWT . DefaultSelection , listener ) ; }', '/ * * * Selects an item . * < p > * If the item at an index is not selected , it is * selected . Indices that are out of * range are ignored . Indexing is zero based . * * param index the index of the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public void select ( int index ) { checkWidget ( ) ; if ( index = = - 1 ) { list . deselectAll ( ) ; text . setText ( "" ) ; return ; } if ( 0 < = index index < list . getItemCount ( ) ) { if ( index ! = getSelectionIndex ( ) ) { text . setText ( list . getItem ( index ) ) ; text . selectAll ( ) ; list . select ( index ) ; list . showSelection ( ) ; } } }', 'public void setBackground ( Color color ) { super . setBackground ( color ) ; if ( text ! = null ) text . setBackground ( color ) ; if ( list ! = null ) list . setBackground ( color ) ; if ( arrow ! = null ) arrow . setBackground ( color ) ; }', 'public boolean setFocus ( ) { checkWidget ( ) ; return text . setFocus ( ) ; }', 'public void setFont ( Font font ) { super . setFont ( font ) ; text . setFont ( font ) ; list . setFont ( font ) ; internalLayout ( ) ; }', 'public void setForeground ( Color color ) { super . setForeground ( color ) ; if ( text ! = null ) text . setForeground ( color ) ; if ( list ! = null ) list . setForeground ( color ) ; if ( arrow ! = null ) arrow . setForeground ( color ) ; }', '/ * * * Sets the text of an item . * < p > * Indexing is zero based . * * This operation will fail when the index is out * of range or an item could not be changed in * the OS . * * param index the index for the item * param string the item * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when items is null * exception SWTError ( ERROR_ITEM_NOT_MODIFIED ) * when the operation fails * / public void setItem ( int index , String string ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; list . setItem ( index , string ) ; }', '/ * * * Sets all items . * < p > * param items the array of items * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when items is null * exception SWTError ( ERROR_ITEM_NOT_ADDED ) * when the operation fails * / public void setItems ( String items ) { checkWidget ( ) ; if ( items = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int style = getStyle ( ) ; if ( ( style SWT . READ_ONLY ) ! = 0 ) text . setText ( "" ) ; list . setItems ( items ) ; }', '/ * * * Sets the new selection . * < p > * param selection point representing the start and the end of the new selection * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when selection is null * / public void setSelection ( Point selection ) { checkWidget ( ) ; if ( selection = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; text . setSelection ( selection . x , selection . y ) ; }', '/ * * * Sets the widget text * < p > * param string the widget text * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_NULL_ARGUMENT ) * when string is null * / public void setText ( String string ) { checkWidget ( ) ; if ( string = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int index = list . indexOf ( string ) ; if ( index = = - 1 ) { list . deselectAll ( ) ; text . setText ( string ) ; return ; } text . setText ( string ) ; text . selectAll ( ) ; list . setSelection ( index ) ; list . showSelection ( ) ; }', '/ * * * Sets the text limit * < p > * param limit new text limit * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * exception SWTError ( ERROR_CANNOT_BE_ZERO ) * when limit is 0 * / public void setTextLimit ( int limit ) { checkWidget ( ) ; text . setTextLimit ( limit ) ; }', 'void textEvent ( Event event ) { switch ( event . type ) { case SWT . FocusIn : { if ( hasFocus ) return ; hasFocus = true ; if ( getEditable ( ) ) text . selectAll ( ) ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusIn , e ) ; break ; } case SWT . FocusOut : { Control focusControl = getDisplay ( ) . getFocusControl ( ) ; if ( focusControl = = list focusControl = = arrow ) return ; hasFocus = false ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . FocusOut , e ) ; break ; } case SWT . KeyDown : { if ( event . character = = SWT . ESC ) { / / escape key cancels popup list dropDown ( false ) ; } if ( event . character = = SWT . CR event . character = = t ) { dropDown ( false ) ; Event e = new Event ( ) ; e . time = event . time ; e . stateMask = event . stateMask ; notifyListeners ( SWT . DefaultSelection , e ) ; } / / At this point the widget may have been disposed . / / If so , do not continue . if ( isDisposed ( ) ) break ; if ( event . keyCode = = SWT . ARROW_UP event . keyCode = = SWT . ARROW_DOWN ) { int oldIndex = getSelectionIndex ( ) ; if ( event . keyCode = = SWT . ARROW_UP ) { select ( Math . max ( oldIndex - 1 , 0 ) ) ; } else { select ( Math . min ( oldIndex + 1 , getItemCount ( ) - 1 ) ) ; } if ( oldIndex ! = getSelectionIndex ( ) ) { Event e = new Event ( ) ; e . time = event . time ; e . stateMask = event . stateMask ; notifyListeners ( SWT . Selection , e ) ; } / / At this point the widget may have been disposed . / / If so , do not continue . if ( isDisposed ( ) ) break ; } / / Further work : Need to add support for incremental search in / / pop up list as characters typed in text widget Event e = new Event ( ) ; e . time = event . time ; e . character = event . character ; e . keyCode = event . keyCode ; e . stateMask = event . stateMask ; notifyListeners ( SWT . KeyDown , e ) ; break ; } case SWT . KeyUp : { Event e = new Event ( ) ; e . time = event . time ; e . character = event . character ; e . keyCode = event . keyCode ; e . stateMask = event . stateMask ; notifyListeners ( SWT . KeyUp , e ) ; break ; } case SWT . Modify : { list . deselectAll ( ) ; Event e = new Event ( ) ; e . time = event . time ; notifyListeners ( SWT . Modify , e ) ; break ; } case SWT . MouseDown : { if ( event . button ! = 1 ) return ; if ( text . getEditable ( ) ) return ; boolean dropped = isDropped ( ) ; text . selectAll ( ) ; if ( ! dropped ) setFocus ( ) ; dropDown ( ! dropped ) ; break ; } case SWT . MouseUp : { if ( event . button ! = 1 ) return ; if ( text . getEditable ( ) ) return ; text . selectAll ( ) ; break ; } case SWT . Traverse : { switch ( event . detail ) { case SWT . TRAVERSE_TAB_NEXT : case SWT . TRAVERSE_ARROW_PREVIOUS : case SWT . TRAVERSE_ARROW_NEXT : / / The tab key causes default selection and / / the arrow keys are used to manipulate the list contents so / / do not use them for traversal . event . doit = false ; break ; } Event e = new Event ( ) ; e . time = event . time ; e . detail = event . detail ; e . doit = event . doit ; e . keyCode = event . keyCode ; notifyListeners ( SWT . Traverse , e ) ; event . doit = e . doit ; break ; } } }'], 'label': 0}
{'guid': '1839d9b_6889189fba66f4bf6075c50f4c630a27aea2f712', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public CLabel ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; if ( ( style SWT . CENTER ) ! = 0 ) align = SWT . CENTER ; if ( ( style SWT . RIGHT ) ! = 0 ) align = SWT . RIGHT ; if ( ( style SWT . LEFT ) ! = 0 ) align = SWT . LEFT ; addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent event ) { onPaint ( event ) ; } } ) ; addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { onDispose ( event ) ; } } ) ; }', 'public void paintControl ( PaintEvent event ) { onPaint ( event ) ; }', 'public void widgetDisposed ( DisposeEvent event ) { onDispose ( event ) ; }', '/ * * * Check the style bits to ensure that no invalid styles are applied . * / private static int checkStyle ( int style ) { int mask = SWT . SHADOW_IN SWT . SHADOW_OUT SWT . SHADOW_NONE ; style = style mask ; style = SWT . NO_FOCUS SWT . NO_BACKGROUND ; return style ; }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; Point e = getTotalSize ( image , text ) ; if ( wHint = = SWT . DEFAULT ) { e . x + = 2 * hIndent ; } else { e . x = wHint ; } if ( hHint = = SWT . DEFAULT ) { e . y + = 2 * vIndent ; } else { e . y = hHint ; } return e ; }', '/ * * * Draw a rectangle in the given colors . * / private void drawBevelRect ( GC gc , int x , int y , int w , int h , Color topleft , Color bottomright ) { gc . setForeground ( bottomright ) ; gc . drawLine ( x + w , y , x + w , y + h ) ; gc . drawLine ( x , y + h , x + w , y + h ) ; gc . setForeground ( topleft ) ; gc . drawLine ( x , y , x + w - 1 , y ) ; gc . drawLine ( x , y , x , y + h - 1 ) ; }', '/ * * * Returns the alignment . * The alignment style ( LEFT , CENTER or RIGHT ) is returned . * * return SWT . LEFT , SWT . RIGHT or SWT . CENTER * / public int getAlignment ( ) { / / checkWidget ( ) ; return align ; }', '/ * * * Return the CLabel s image or < code > null < / code > . * * return the image of the label or null * / public Image getImage ( ) { / / checkWidget ( ) ; return image ; }', '/ * * * Compute the minimum size . * / private Point getTotalSize ( Image image , String text ) { Point size = new Point ( 0 , 0 ) ; if ( image ! = null ) { Rectangle r = image . getBounds ( ) ; size . x + = r . width ; size . y + = r . height ; } GC gc = new GC ( this ) ; if ( text ! = null text . length ( ) > 0 ) { Point e = gc . textExtent ( text ) ; size . x + = e . x ; size . y = Math . max ( size . y , e . y ) ; if ( image ! = null ) size . x + = GAP ; } else { size . y = Math . max ( size . y , gc . getFontMetrics ( ) . getHeight ( ) ) ; } gc . dispose ( ) ; return size ; }', 'public void setToolTipText ( String string ) { super . setToolTipText ( string ) ; appToolTipText = super . getToolTipText ( ) ; }', '/ * * * Return the Label s text . * * return the text of the label or null * / public String getText ( ) { / / checkWidget ( ) ; return text ; }', 'public String getToolTipText ( ) { checkWidget ( ) ; return appToolTipText ; }', '/ * * * Paint the Label s border . * / private void paintBorder ( GC gc , Rectangle r ) { Display disp = getDisplay ( ) ; Color c1 = null ; Color c2 = null ; int style = getStyle ( ) ; if ( ( style SWT . SHADOW_IN ) ! = 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ; } if ( ( style SWT . SHADOW_OUT ) ! = 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_LIGHT_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; } if ( c1 ! = null c2 ! = null ) { gc . setLineWidth ( 1 ) ; drawBevelRect ( gc , r . x , r . y , r . width - 1 , r . height - 1 , c1 , c2 ) ; } }', 'private void onDispose ( DisposeEvent event ) { gradientColors = null ; gradientPercents = null ; backgroundImage = null ; }', 'private void onPaint ( PaintEvent event ) { Rectangle rect = getClientArea ( ) ; if ( rect . width = = 0 rect . height = = 0 ) return ; boolean shortenText = false ; String t = text ; Image img = image ; int availableWidth = rect . width - 2 * hIndent ; Point extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { img = null ; extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { shortenText = true ; } } GC gc = event . gc ; / / shorten the text if ( shortenText ) { t = shortenText ( gc , text , availableWidth ) ; extent = getTotalSize ( img , t ) ; if ( appToolTipText = = null ) { super . setToolTipText ( text ) ; } } else { super . setToolTipText ( appToolTipText ) ; } / / determine horizontal position int x = rect . x + hIndent ; if ( align = = SWT . CENTER ) { x = ( rect . width - extent . x ) / 2 ; } if ( align = = SWT . RIGHT ) { x = rect . width - extent . x - hIndent ; } / / draw a background image behind the text try { if ( backgroundImage ! = null ) { / / draw a background image behind the text Rectangle imageRect = backgroundImage . getBounds ( ) ; gc . drawImage ( backgroundImage , 0 , 0 , imageRect . width , imageRect . height , 0 , 0 , rect . width , rect . height ) ; } else if ( gradientColors ! = null ) { / / draw a gradient behind the text final Color oldBackground = gc . getBackground ( ) ; if ( gradientColors . length = = 1 ) { if ( gradientColors 0 ! = null ) gc . setBackground ( gradientColors 0 ) ; gc . fillRectangle ( 0 , 0 , rect . width , rect . height ) ; } else { final Color oldForeground = gc . getForeground ( ) ; Color lastColor = gradientColors 0 ; if ( lastColor = = null ) lastColor = oldBackground ; for ( int i = 0 , pos = 0 ; i < gradientPercents . length ; + + i ) { gc . setForeground ( lastColor ) ; lastColor = gradientColors i + 1 ; if ( lastColor = = null ) lastColor = oldBackground ; gc . setBackground ( lastColor ) ; final int gradientWidth = ( gradientPercents i * rect . width / 100 ) - pos ; gc . fillGradientRectangle ( pos , 0 , gradientWidth , rect . height , false ) ; pos + = gradientWidth ; } gc . setForeground ( oldForeground ) ; } gc . setBackground ( oldBackground ) ; } else { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } } catch ( SWTException e ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } / / draw border int style = getStyle ( ) ; if ( ( style SWT . SHADOW_IN ) ! = 0 ( style SWT . SHADOW_OUT ) ! = 0 ) { paintBorder ( gc , rect ) ; } / / draw the image if ( img ! = null ) { Rectangle imageRect = img . getBounds ( ) ; gc . drawImage ( img , 0 , 0 , imageRect . width , imageRect . height , x , ( rect . height - imageRect . height ) / 2 , imageRect . width , imageRect . height ) ; x + = imageRect . width + GAP ; } / / draw the text if ( t ! = null ) { int textHeight = gc . getFontMetrics ( ) . getHeight ( ) ; gc . setForeground ( getForeground ( ) ) ; gc . drawText ( t , x , rect . y + ( rect . height - textHeight ) / 2 , true ) ; } }', '/ * * * Set the alignment of the CLabel . * Use the values LEFT , CENTER and RIGHT to align image and text within the available space . * * param align the alignment style of LEFT , RIGHT or CENTER * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if the value of align is not one of SWT . LEFT , SWT . RIGHT or SWT . CENTER < / li > * < / ul > * / public void setAlignment ( int align ) { checkWidget ( ) ; if ( align ! = SWT . LEFT align ! = SWT . RIGHT align ! = SWT . CENTER ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . align ! = align ) { this . align = align ; redraw ( ) ; } }', '/ * * * Specify a gradiant of colours to be draw in the background of the CLabel . * For example to draw a gradiant that varies from dark blue to blue and then to * white , use the following call to setBackground : * < pre > * clabel . setBackground ( new Color { display . getSystemColor ( SWT . COLOR_DARK_BLUE ) , * display . getSystemColor ( SWT . COLOR_BLUE ) , * display . getSystemColor ( SWT . COLOR_WHITE ) , * display . getSystemColor ( SWT . COLOR_WHITE ) } , * new int { 25 , 50 , 100 } ) ; * < / pre > * * param colors an array of Color that specifies the colors to appear in the gradiant * in order of appearance left to right . The value < code > null < / code > clears the * background gradiant . The value < code > null < / code > can be used inside the array of * Color to specify the background color . * param percents an array of integers between 0 and 100 specifying the percent of the width * of the widget at which the color should change . The size of the percents array must be one * less than the size of the colors array . * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if the values of colors and percents are not consistant < / li > * < / ul > * / public void setBackground ( Color colors , int percents ) { checkWidget ( ) ; if ( colors ! = null ) { if ( percents = = null percents . length ! = colors . length - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( getDisplay ( ) . getDepth ( ) < 15 ) { / / Don t use gradients on low color displays colors = new Color { colors 0 } ; percents = new int { } ; } for ( int i = 0 ; i < percents . length ; i + + ) { if ( percents i < 0 percents i > 100 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( i > 0 percents i < percents i - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } } } / / Are these settings the same as before ? final Color background = getBackground ( ) ; if ( backgroundImage = = null ) { if ( ( gradientColors ! = null ) ( colors ! = null ) ( gradientColors . length = = colors . length ) ) { boolean same = false ; for ( int i = 0 ; i < gradientColors . length ; i + + ) { same = ( gradientColors i = = colors i ) ( ( gradientColors i = = null ) ( colors i = = background ) ) ( ( gradientColors i = = background ) ( colors i = = null ) ) ; if ( ! same ) break ; } if ( same ) { for ( int i = 0 ; i < gradientPercents . length ; i + + ) { same = gradientPercents i = = percents i ; if ( ! same ) break ; } } if ( same ) return ; } } else { backgroundImage = null ; } / / Store the new settings if ( colors = = null ) { gradientColors = null ; gradientPercents = null ; } else { gradientColors = new Color colors . length ; for ( int i = 0 ; i < colors . length ; + + i ) gradientColors i = ( colors i ! = null ) ? colors i : background ; gradientPercents = new int percents . length ; for ( int i = 0 ; i < percents . length ; + + i ) gradientPercents i = percents i ; } / / Refresh with the new settings redraw ( ) ; }', '/ * * * Set the image to be drawn in the background of the label . * * param image the image to be drawn in the background * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setBackground ( Image image ) { checkWidget ( ) ; if ( image = = backgroundImage ) return ; if ( image ! = null ) { gradientColors = null ; gradientPercents = null ; } backgroundImage = image ; redraw ( ) ; }', 'public void setFont ( Font font ) { super . setFont ( font ) ; redraw ( ) ; }', '/ * * * Set the label s Image . * The value < code > null < / code > clears it . * * param image the image to be displayed in the label or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setImage ( Image image ) { checkWidget ( ) ; if ( image ! = this . image ) { this . image = image ; redraw ( ) ; } }', '/ * * * Set the label s text . * The value < code > null < / code > clears it . * * param text the text to be displayed in the label or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setText ( String text ) { checkWidget ( ) ; if ( text = = null ) text = "" ; if ( ! text . equals ( this . text ) ) { this . text = text ; redraw ( ) ; } }', '/ * * * Shorten the given text < code > t < / code > so that its length doesn t exceed * the given width . The default implementation replaces characters in the * center of the original string with an ellipsis ( " . . . " ) . * Override if you need a different strategy . * / protected String shortenText ( GC gc , String t , int width ) { if ( t = = null ) return null ; int w = gc . textExtent ( ellipsis ) . x ; int l = t . length ( ) ; int pivot = l / 2 ; int s = pivot ; int e = pivot + 1 ; while ( s > = 0 e < l ) { String s1 = t . substring ( 0 , s ) ; String s2 = t . substring ( e , l ) ; int l1 = gc . textExtent ( s1 ) . x ; int l2 = gc . textExtent ( s2 ) . x ; if ( l1 + w + l2 < width ) { t = s1 + ellipsis + s2 ; break ; } s - - ; e + + ; } return t ; }'], 'label': 0}
{'guid': '1839d9b_9767601dc8a1e001657238b29fdb8d1e80bb7712', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public CTabFolder ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; onBottom = ( getStyle ( ) SWT . BOTTOM ) ! = 0 ; borderColor1 = new Color ( getDisplay ( ) , borderInsideRGB ) ; borderColor2 = new Color ( getDisplay ( ) , borderMiddleRGB ) ; borderColor3 = new Color ( getDisplay ( ) , borderOutsideRGB ) ; Color background = getBackground ( ) ; / / tool tip support Display display = getDisplay ( ) ; tip = new Shell ( getShell ( ) , SWT . ON_TOP ) ; GridLayout layout = new GridLayout ( ) ; layout . marginWidth = layout . marginHeight = 1 ; tip . setLayout ( layout ) ; Label label = new Label ( tip , SWT . NONE ) ; label . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; label . setForeground ( display . getSystemColor ( SWT . COLOR_INFO_FOREGROUND ) ) ; label . setBackground ( display . getSystemColor ( SWT . COLOR_INFO_BACKGROUND ) ) ; tip . setBackground ( label . getBackground ( ) ) ; / / Add all listeners Listener listener = new Listener ( ) { public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . Dispose : onDispose ( ) ; break ; case SWT . Paint : onPaint ( event ) ; break ; case SWT . Resize : onResize ( ) ; break ; case SWT . MouseDoubleClick : onMouseDoubleClick ( event ) ; break ; case SWT . MouseDown : onMouseDown ( event ) ; break ; case SWT . MouseExit : onMouseExit ( event ) ; break ; case SWT . MouseHover : onMouseHover ( event ) ; break ; case SWT . MouseMove : onMouseMove ( event ) ; break ; case SWT . FocusIn : onFocus ( event ) ; break ; case SWT . FocusOut : onFocus ( event ) ; break ; case SWT . KeyDown : onKeyDown ( event ) ; break ; case SWT . Traverse : onTraverse ( event ) ; break ; } } } ; int folderEvents = new int { SWT . Dispose , SWT . MouseDown , SWT . MouseDoubleClick , SWT . MouseMove , SWT . MouseExit , SWT . MouseHover , SWT . Paint , SWT . Resize , SWT . FocusIn , SWT . FocusOut , SWT . KeyDown , SWT . Traverse , } ; for ( int i = 0 ; i < folderEvents . length ; i + + ) { addListener ( folderEvents i , listener ) ; } createArrowBar ( ) ; createCloseBar ( ) ; setBorderVisible ( ( style SWT . BORDER ) ! = 0 ) ; }', 'public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . Dispose : onDispose ( ) ; break ; case SWT . Paint : onPaint ( event ) ; break ; case SWT . Resize : onResize ( ) ; break ; case SWT . MouseDoubleClick : onMouseDoubleClick ( event ) ; break ; case SWT . MouseDown : onMouseDown ( event ) ; break ; case SWT . MouseExit : onMouseExit ( event ) ; break ; case SWT . MouseHover : onMouseHover ( event ) ; break ; case SWT . MouseMove : onMouseMove ( event ) ; break ; case SWT . FocusIn : onFocus ( event ) ; break ; case SWT . FocusOut : onFocus ( event ) ; break ; case SWT . KeyDown : onKeyDown ( event ) ; break ; case SWT . Traverse : onTraverse ( event ) ; break ; } }', 'private static int checkStyle ( int style ) { int mask = SWT . TOP SWT . BOTTOM SWT . FLAT ; style = style mask ; / / TOP and BOTTOM are mutually exlusive . / / TOP is the default if ( ( style SWT . TOP ) ! = 0 ) style = style ( SWT . TOP SWT . BOTTOM ) SWT . TOP ; / / reduce the flash by not redrawing the entire area on a Resize event style = SWT . NO_REDRAW_RESIZE ; return style ; }', '/ * * * Adds the listener to receive events . * < p > * * param listener the listener * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Selection , typedListener ) ; addListener ( SWT . DefaultSelection , typedListener ) ; }', '/ * * * Adds the listener to the collection of listeners who will * be notified when a tab item is closed . * * param listener the listener which should be notified * * exception IllegalArgumentException < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT - if the listener is null < / li > * < / ul > * * see CTabFolderListener * see removeCTabFolderListener * / public void addCTabFolderListener ( CTabFolderListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; / / add to array CTabFolderListener newTabListeners = new CTabFolderListener tabListeners . length + 1 ; System . arraycopy ( tabListeners , 0 , newTabListeners , 0 , tabListeners . length ) ; tabListeners = newTabListeners ; tabListeners tabListeners . length - 1 = listener ; showClose = true ; layoutItems ( ) ; }', 'void onClientAreaChange ( ) { oldArea = null ; notifyListeners ( SWT . Resize , new Event ( ) ) ; }', 'private void closeNotify ( CTabItem item , int time ) { if ( item = = null ) return ; CTabFolderEvent event = new CTabFolderEvent ( this ) ; event . widget = this ; event . time = time ; event . item = item ; event . doit = true ; if ( tabListeners ! = null ) { for ( int i = 0 ; i < tabListeners . length ; i + + ) { tabListeners i . itemClosed ( event ) ; } } if ( event . doit ) { item . dispose ( ) ; } }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int minWidth = 0 ; int minHeight = 0 ; / / tab width if ( items . length > 0 ) { CTabItem lastItem = items items . length - 1 ; minWidth = lastItem . x + lastItem . width ; } / / get max preferred size of items for ( int i = 0 ; i < items . length ; i + + ) { Control control = items i . getControl ( ) ; if ( control ! = null ! control . isDisposed ( ) ) { Point size = control . computeSize ( wHint , hHint ) ; minWidth = Math . max ( minWidth , size . x ) ; minHeight = Math . max ( minHeight , size . y ) ; } } if ( minWidth = = 0 ) minWidth = DEFAULT_WIDTH ; if ( minHeight = = 0 ) minHeight = DEFAULT_HEIGHT ; if ( wHint ! = SWT . DEFAULT ) minWidth = wHint ; if ( hHint ! = SWT . DEFAULT ) minHeight = hHint ; Rectangle trim = computeTrim ( 0 , 0 , minWidth , minHeight ) ; return new Point ( trim . width , trim . height ) ; }', 'public Rectangle computeTrim ( int x , int y , int width , int height ) { checkWidget ( ) ; int tabHeight = getTabHeight ( ) ; int trimX = x - marginWidth - borderLeft ; int trimY = y - marginHeight - tabHeight - borderTop ; if ( onBottom ) { trimY = y - marginHeight - borderTop ; } int trimWidth = width + borderLeft + borderRight + 2 * marginWidth ; int trimHeight = height + borderTop + borderBottom + 2 * marginHeight + tabHeight ; return new Rectangle ( trimX , trimY , trimWidth , trimHeight ) ; }', '/ * * * Create the specified item at index . * / void createItem ( CTabItem item , int index ) { if ( 0 > index index > getItemCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } / / grow by one and rearrange the array . CTabItem newItems = new CTabItem items . length + 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; newItems index = item ; System . arraycopy ( items , index , newItems , index + 1 , items . length - index ) ; items = newItems ; item . parent = this ; if ( selectedIndex > = index ) { selectedIndex + + ; } if ( items . length = = 1 ) { topTabIndex = 0 ; } layoutItems ( ) ; ensureVisible ( ) ; if ( items . length = = 1 ) { redraw ( ) ; } else { redrawTabArea ( - 1 ) ; } }', 'private void createArrowBar ( ) { / / create arrow buttons for scrolling arrowBar = new ToolBar ( this , SWT . FLAT ) ; arrowBar . setVisible ( false ) ; arrowBar . setBackground ( getBackground ( ) ) ; ToolItem scrollLeft = new ToolItem ( arrowBar , SWT . PUSH ) ; scrollLeft . setEnabled ( false ) ; ToolItem scrollRight = new ToolItem ( arrowBar , SWT . PUSH ) ; scrollRight . setEnabled ( false ) ; scrollLeft . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { scroll_scrollLeft ( ) ; } } ) ; scrollRight . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { scroll_scrollRight ( ) ; } } ) ; }', 'public void handleEvent ( Event event ) { scroll_scrollLeft ( ) ; }', 'public void handleEvent ( Event event ) { scroll_scrollRight ( ) ; }', 'private void createCloseBar ( ) { Color background = getBackground ( ) ; closeBar = new ToolBar ( this , SWT . FLAT ) ; closeBar . setVisible ( false ) ; if ( gradientColors ! = null gradientColors . length > 0 ) { closeBar . setBackground ( gradientColors gradientColors . length - 1 ) ; } else { closeBar . setBackground ( background ) ; } ToolItem closeItem = new ToolItem ( closeBar , SWT . PUSH ) ; inactiveCloseBar = new ToolBar ( this , SWT . FLAT ) ; inactiveCloseBar . setVisible ( false ) ; inactiveCloseBar . setBackground ( background ) ; ToolItem inactiveCloseItem = new ToolItem ( inactiveCloseBar , SWT . PUSH ) ; closeItem . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { closeNotify ( getSelection ( ) , event . time ) ; } } ) ; inactiveCloseItem . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { closeNotify ( inactiveItem , event . time ) ; inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; } } ) ; inactiveCloseBar . addListener ( SWT . MouseExit , new Listener ( ) { public void handleEvent ( Event event ) { if ( inactiveItem ! = null ) { Rectangle itemBounds = inactiveItem . getBounds ( ) ; if ( itemBounds . contains ( event . x , event . y ) ) return ; } inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; } } ) ; }', 'public void handleEvent ( Event event ) { closeNotify ( getSelection ( ) , event . time ) ; }', 'public void handleEvent ( Event event ) { closeNotify ( inactiveItem , event . time ) ; inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; }', 'public void handleEvent ( Event event ) { if ( inactiveItem ! = null ) { Rectangle itemBounds = inactiveItem . getBounds ( ) ; if ( itemBounds . contains ( event . x , event . y ) ) return ; } inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; }', '/ * * * Destroy the specified item . * / void destroyItem ( CTabItem item ) { if ( inDispose ) return ; int index = indexOf ( item ) ; if ( index = = - 1 ) return ; / / should this trigger an error ? insertionIndex = - 2 ; if ( items . length = = 1 ) { items = new CTabItem 0 ; selectedIndex = - 1 ; topTabIndex = 0 ; Control control = item . getControl ( ) ; if ( control ! = null ! control . isDisposed ( ) ) { control . setVisible ( false ) ; } closeBar . setVisible ( false ) ; redraw ( ) ; return ; } / / shrink by one and rearrange the array . CTabItem newItems = new CTabItem items . length - 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; System . arraycopy ( items , index + 1 , newItems , index , items . length - index - 1 ) ; items = newItems ; if ( topTabIndex = = items . length ) { - - topTabIndex ; } / / move the selection if this item is selected if ( selectedIndex = = index ) { Control control = item . getControl ( ) ; if ( control ! = null ! control . isDisposed ( ) ) { control . setVisible ( false ) ; } selectedIndex = - 1 ; setSelection ( Math . max ( 0 , index - 1 ) , true ) ; } else if ( selectedIndex > index ) { selectedIndex - - ; } layoutItems ( ) ; ensureVisible ( ) ; redrawTabArea ( - 1 ) ; }', 'private void onKeyDown ( Event e ) { if ( e . keyCode = = SWT . ARROW_LEFT ) { if ( selectedIndex > 0 ) { setSelection ( selectedIndex - 1 , true ) ; } } if ( e . keyCode = = SWT . ARROW_RIGHT ) { if ( selectedIndex < items . length - 1 ) { setSelection ( selectedIndex + 1 , true ) ; } } }', '/ * * * Dispose the items of the receiver * / private void onDispose ( ) { inDispose = true ; / / items array is resized during CTabItem . dispose / / it is set to null if the last item is removed int length = items . length ; for ( int i = 0 ; i < length ; i + + ) { if ( items i ! = null ) { items i . dispose ( ) ; } } / / clean up resources if ( tip ! = null ! tip . isDisposed ( ) ) { tip . dispose ( ) ; tip = null ; } if ( arrowLeftImage ! = null ) arrowLeftImage . dispose ( ) ; arrowLeftImage = null ; if ( arrowRightImage ! = null ) arrowRightImage . dispose ( ) ; arrowRightImage = null ; if ( closeImage ! = null ) closeImage . dispose ( ) ; closeImage = null ; gradientColors = null ; gradientPercents = null ; backgroundImage = null ; if ( borderColor1 ! = null ) borderColor1 . dispose ( ) ; borderColor1 = null ; if ( borderColor2 ! = null ) borderColor2 . dispose ( ) ; borderColor2 = null ; if ( borderColor3 ! = null ) borderColor3 . dispose ( ) ; borderColor3 = null ; }', 'void onFocus ( Event e ) { checkWidget ( ) ; if ( selectedIndex > = 0 ) { redrawTabArea ( selectedIndex ) ; } else { setSelection ( 0 , true ) ; } }', '/ * * * Draw a border around the receiver . * / private void drawBorder ( GC gc ) { Rectangle d = super . getClientArea ( ) ; if ( showBorders ) { if ( ( getStyle ( ) SWT . FLAT ) ! = 0 ) { gc . setForeground ( borderColor1 ) ; gc . drawRectangle ( d . x , d . y , d . x + d . width - 1 , d . y + d . height - 1 ) ; } else { gc . setForeground ( borderColor1 ) ; gc . drawRectangle ( d . x , d . y , d . x + d . width - 3 , d . y + d . height - 3 ) ; gc . setForeground ( borderColor2 ) ; gc . drawLine ( d . x + 1 , d . y + d . height - 2 , d . x + d . width - 1 , d . y + d . height - 2 ) ; gc . drawLine ( d . x + d . width - 2 , d . y + 1 , d . x + d . width - 2 , d . y + d . height - 1 ) ; gc . setForeground ( borderColor3 ) ; gc . drawLine ( d . x + 2 , d . y + d . height - 1 , d . x + d . width - 2 , d . y + d . height - 1 ) ; gc . drawLine ( d . x + d . width - 1 , d . y + 2 , d . x + d . width - 1 , d . y + d . height - 2 ) ; / / fill in corners with parent s background gc . setForeground ( getParent ( ) . getBackground ( ) ) ; gc . drawLine ( d . x + d . width - 2 , d . y , d . x + d . width - 1 , d . y ) ; gc . drawLine ( d . x + d . width - 1 , d . y + 1 , d . x + d . width - 1 , d . y + 1 ) ; gc . drawLine ( d . x , d . y + d . height - 2 , d . x , d . y + d . height - 2 ) ; gc . drawLine ( d . x , d . y + d . height - 1 , d . x + 1 , d . y + d . height - 1 ) ; gc . drawLine ( d . x + d . width - 1 , d . y + d . height - 1 , d . x + d . width - 1 , d . y + d . height - 1 ) ; } } / / draw a separator line if ( items . length > 0 ) { int tabHeight = getTabHeight ( ) ; int lineY = d . y + borderTop + tabHeight ; if ( onBottom ) { lineY = d . y + d . height - borderBottom - tabHeight - 1 ; } gc . setForeground ( borderColor1 ) ; gc . drawLine ( d . x + borderLeft , lineY , d . x + d . width - borderRight , lineY ) ; } gc . setForeground ( getForeground ( ) ) ; }', 'public Rectangle getClientArea ( ) { checkWidget ( ) ; Rectangle clientArea = super . getClientArea ( ) ; clientArea . x = xClient ; clientArea . y = yClient ; clientArea . width - = 2 * marginWidth + borderLeft + borderRight ; clientArea . height - = 2 * marginHeight + borderTop + borderBottom + getTabHeight ( ) + 1 ; return clientArea ; }', '/ * * * Returns the height of the tab * * return the height of the tab * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public int getTabHeight ( ) { checkWidget ( ) ; if ( fixedTabHeight > 0 ) return fixedTabHeight ; int tempHeight = 0 ; GC gc = new GC ( this ) ; for ( int i = 0 ; i < items . length ; i + + ) { tempHeight = Math . max ( tempHeight , items i . preferredHeight ( gc ) ) ; } gc . dispose ( ) ; return tempHeight ; }', '/ * * * Return the tab that is located at the specified index . * * return the item at the specified index * / public CTabItem getItem ( int index ) { / / checkWidget ( ) ; if ( index < 0 index > = items . length ) SWT . error ( SWT . ERROR_INVALID_RANGE ) ; return items index ; }', '/ * * * Gets the item at a point in the widget . * < p > * * return the item at a point * / public CTabItem getItem ( Point pt ) { / / checkWidget ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { Rectangle bounds = items i . getBounds ( ) ; if ( bounds . contains ( pt ) ) return items i ; } return null ; }', '/ * * * Return the number of tabs in the folder . * * return the number of tabs in the folder * / public int getItemCount ( ) { / / checkWidget ( ) ; return items . length ; }', '/ * * * Return the tab items . * * return the tab items * / public CTabItem getItems ( ) { / / checkWidget ( ) ; CTabItem tabItems = new CTabItem items . length ; System . arraycopy ( items , 0 , tabItems , 0 , items . length ) ; return tabItems ; }', '/ * * * Return the selected tab item , or an empty array if there * is no selection . * * return the selected tab item * / public CTabItem getSelection ( ) { / / checkWidget ( ) ; if ( selectedIndex = = - 1 ) return null ; return items selectedIndex ; }', '/ * * * Return the index of the selected tab item , or - 1 if there * is no selection . * * return the index of the selected tab item or - 1 * / public int getSelectionIndex ( ) { / / checkWidget ( ) ; return selectedIndex ; }', '/ * * * Return the index of the specified tab or - 1 if the tab is not * in the receiver . * * return the index of the specified tab item or - 1 * * exception SWTError < ul > * < li > ERROR_NULL_ARGUMENT when the item is null < / li > * < / ul > * / public int indexOf ( CTabItem item ) { / / checkWidget ( ) ; if ( item = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } for ( int i = 0 ; i < items . length ; i + + ) { if ( items i = = item ) return i ; } return - 1 ; }', 'private void layoutButtons ( ) { updateArrowBar ( ) ; updateCloseBar ( ) ; int tabHeight = getTabHeight ( ) ; Rectangle area = super . getClientArea ( ) ; boolean leftVisible = scroll_leftVisible ( ) ; boolean rightVisible = scroll_rightVisible ( ) ; if ( leftVisible rightVisible ) { Point size = arrowBar . computeSize ( SWT . DEFAULT , tabHeight ) ; int x = area . x + area . width - borderRight - size . x ; int y = ( onBottom ) ? area . y + area . height - borderBottom - size . y : area . y + borderTop ; arrowBar . setBounds ( x , y , size . x , size . y ) ; ToolItem items = arrowBar . getItems ( ) ; items 0 . setEnabled ( leftVisible ) ; items 1 . setEnabled ( rightVisible ) ; arrowBar . setVisible ( true ) ; } else { arrowBar . setVisible ( false ) ; } / / When the close button is right at the edge of the Tab folder , hide it because / / otherwise it may block off a part of the border on the right if ( showClose ) { CTabItem item = getSelection ( ) ; if ( item = = null ) { closeBar . setVisible ( false ) ; } else { int toolbarHeight = tabHeight - CTabItem . TOP_MARGIN - CTabItem . BOTTOM_MARGIN + 2 ; / / + 2 to ignore gab between focus rectangle int x = item . x + item . width - toolbarHeight - 1 ; int y = item . y + Math . max ( 0 , ( item . height - toolbarHeight ) / 2 ) ; closeBar . setBounds ( x , y , toolbarHeight , toolbarHeight ) ; if ( arrowBar . isVisible ( ) ) { Rectangle arrowRect = arrowBar . getBounds ( ) ; arrowRect . width + = borderRight ; closeBar . setVisible ( ! arrowRect . contains ( x , y ) ) ; } else { closeBar . setVisible ( true ) ; } } } }', '/ * * * Layout the items and store the client area size . * / void layoutItems ( ) { if ( isDisposed ( ) ) return ; Rectangle area = super . getClientArea ( ) ; int tabHeight = getTabHeight ( ) ; shortenedTabs = false ; if ( items . length > 0 ) { int widths = new int items . length ; int totalWidth = 0 ; GC gc = new GC ( this ) ; for ( int i = 0 ; i < items . length ; i + + ) { widths i = items i . preferredWidth ( gc ) ; totalWidth + = widths i ; } gc . dispose ( ) ; if ( totalWidth < ( area . width - borderLeft - borderRight ) ) { topTabIndex = 0 ; } else { int oldAverageWidth = 0 ; int averageWidth = ( area . width - borderLeft - borderRight ) / items . length ; while ( averageWidth > oldAverageWidth ) { int width = area . width - borderLeft - borderRight ; int count = items . length ; for ( int i = 0 ; i < items . length ; i + + ) { if ( widths i < averageWidth ) { width - = widths i ; count - - ; } } oldAverageWidth = averageWidth ; if ( count > 0 ) { averageWidth = width / count ; } } if ( averageWidth > MIN_TAB_WIDTH * tabHeight ) { for ( int i = 0 ; i < items . length ; i + + ) { if ( widths i > averageWidth ) { widths i = averageWidth ; } } topTabIndex = 0 ; shortenedTabs = true ; } } int x = area . x ; int y = area . y + borderTop ; if ( onBottom ) { y = Math . max ( 0 , area . y + area . height - borderBottom - tabHeight ) ; } for ( int i = topTabIndex - 1 ; i > = 0 ; i - - ) { / / if the first visible tab is not the first tab CTabItem tab = items i ; tab . width = widths i ; tab . height = getTabHeight ( ) ; x - = tab . width ; / / layout tab items from right to left thus making them invisible tab . x = x ; tab . y = y ; } x = area . x + borderLeft ; for ( int i = topTabIndex ; i < items . length ; i + + ) { / / continue laying out remaining , visible items left to right CTabItem tab = items i ; tab . x = x ; tab . y = y ; tab . height = tabHeight ; tab . width = widths i ; x = x + tab . width ; } } xClient = area . x + borderLeft + marginWidth ; if ( onBottom ) { yClient = area . y + borderTop + marginHeight ; } else { yClient = area . y + borderTop + tabHeight + 1 + marginHeight ; / / + 1 is for the line at the bottom of the tabs } / / resize the scrollbar and close butotns layoutButtons ( ) ; }', 'boolean onMnemonic ( Event event ) { char key = event . character ; for ( int i = 0 ; i < items . length ; i + + ) { if ( items i ! = null ) { char mnemonic = getMnemonic ( items i . getText ( ) ) ; if ( mnemonic ! = 0 ) { if ( Character . toUpperCase ( key ) = = Character . toUpperCase ( mnemonic ) ) { setSelection ( i , true ) ; return true ; } } } } return false ; }', '/ * * * Paint the receiver . * / private void onPaint ( Event event ) { GC gc = event . gc ; Rectangle rect = super . getClientArea ( ) ; if ( items . length = = 0 ) { if ( showBorders ) { gc . setForeground ( borderColor1 ) ; gc . drawRectangle ( rect . x + borderRight , rect . y + borderBottom , rect . x + rect . width - borderRight - 1 , rect . y + rect . height - borderBottom - 1 ) ; / / fill in top and left edge with parent s background color gc . setBackground ( getParent ( ) . getBackground ( ) ) ; gc . fillRectangle ( rect . x , rect . y , borderRight , rect . height ) ; gc . fillRectangle ( rect . x , rect . y , rect . width , borderBottom ) ; } int tabHeight = getTabHeight ( ) ; if ( tabHeight > 0 ) { int y = rect . y + borderBottom + tabHeight ; if ( onBottom ) { y = rect . y + rect . height - tabHeight - 1 ; } gc . setForeground ( borderColor1 ) ; gc . drawLine ( rect . x + borderRight , y , rect . x + rect . width , y ) ; } gc . setForeground ( getForeground ( ) ) ; gc . setBackground ( getBackground ( ) ) ; return ; } / / redraw the Border drawBorder ( gc ) ; rect . x + = borderLeft ; rect . y + = borderTop ; rect . width - = borderLeft + borderRight ; rect . height - = borderTop + borderBottom ; gc . setClipping ( rect ) ; / / Draw the unselected tabs first . for ( int i = 0 ; i < items . length ; i + + ) { if ( i ! = selectedIndex event . getBounds ( ) . intersects ( items i . getBounds ( ) ) ) { items i . onPaint ( gc , false ) ; } } / / Selected tab comes last if ( selectedIndex ! = - 1 ) { items selectedIndex . onPaint ( gc , true ) ; } / / draw insertion mark if ( insertionIndex > - 2 ) { gc . setForeground ( getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_SELECTION ) ) ; if ( insertionIndex = = - 1 ) { Rectangle bounds = items 0 . getBounds ( ) ; gc . drawLine ( bounds . x , bounds . y , bounds . x , bounds . y + bounds . height - 1 ) ; gc . drawLine ( bounds . x - 2 , bounds . y , bounds . x + 2 , bounds . y ) ; gc . drawLine ( bounds . x - 1 , bounds . y + 1 , bounds . x + 1 , bounds . y + 1 ) ; gc . drawLine ( bounds . x - 1 , bounds . y + bounds . height - 2 , bounds . x + 1 , bounds . y + bounds . height - 2 ) ; gc . drawLine ( bounds . x - 2 , bounds . y + bounds . height - 1 , bounds . x + 2 , bounds . y + bounds . height - 1 ) ; } else { Rectangle bounds = items insertionIndex . getBounds ( ) ; gc . drawLine ( bounds . x + bounds . width , bounds . y , bounds . x + bounds . width , bounds . y + bounds . height - 1 ) ; gc . drawLine ( bounds . x + bounds . width - 2 , bounds . y , bounds . x + bounds . width + 2 , bounds . y ) ; gc . drawLine ( bounds . x + bounds . width - 1 , bounds . y + 1 , bounds . x + bounds . width + 1 , bounds . y + 1 ) ; gc . drawLine ( bounds . x + bounds . width - 1 , bounds . y + bounds . height - 2 , bounds . x + bounds . width + 1 , bounds . y + bounds . height - 2 ) ; gc . drawLine ( bounds . x + bounds . width - 2 , bounds . y + bounds . height - 1 , bounds . x + bounds . width + 2 , bounds . y + bounds . height - 1 ) ; } } gc . setForeground ( getForeground ( ) ) ; gc . setBackground ( getBackground ( ) ) ; }', 'private void redrawTabArea ( int index ) { int x = 0 , y = 0 , width = 0 , height = 0 ; if ( index = = - 1 ) { Rectangle area = super . getClientArea ( ) ; if ( area . width = = 0 area . height = = 0 ) return ; width = area . x + area . width - borderLeft - borderRight ; height = getTabHeight ( ) + 1 ; / / + 1 causes top line between content and tabs to be redrawn x = area . x + borderLeft ; y = area . y + borderTop ; if ( onBottom ) { y = Math . max ( 0 , area . y + area . height - borderBottom - height ) ; } } else { CTabItem item = items index ; x = item . x ; y = item . y ; Rectangle area = super . getClientArea ( ) ; width = area . x + area . width - x ; height = item . height ; } redraw ( x , y , width , height , false ) ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( SWT . Selection , listener ) ; removeListener ( SWT . DefaultSelection , listener ) ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeCTabFolderListener ( CTabFolderListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( tabListeners . length = = 0 ) return ; int index = - 1 ; for ( int i = 0 ; i < tabListeners . length ; i + + ) { if ( listener = = tabListeners i ) { index = i ; break ; } } if ( index = = - 1 ) return ; if ( tabListeners . length = = 1 ) { tabListeners = new CTabFolderListener 0 ; showClose = false ; return ; } CTabFolderListener newTabListeners = new CTabFolderListener tabListeners . length - 1 ; System . arraycopy ( tabListeners , 0 , newTabListeners , 0 , index ) ; System . arraycopy ( tabListeners , index + 1 , newTabListeners , index , tabListeners . length - index - 1 ) ; tabListeners = newTabListeners ; }', '/ * * * The widget was resized . Adjust the size of the currently selected page . * / private void onResize ( ) { if ( items . length = = 0 ) { redraw ( ) ; return ; } Rectangle area = super . getClientArea ( ) ; if ( oldArea = = null oldArea . width = = 0 oldArea . height = = 0 ) { layoutItems ( ) ; redraw ( ) ; } else { if ( onBottom oldArea . height ! = area . height ) { / / move tabs up or down if tabs on bottom layoutItems ( ) ; redraw ( ) ; } else { int width = 0 ; if ( oldArea . width < area . width ) { width = area . width - oldArea . width + borderRight ; } else if ( oldArea . width > area . width ) { width = borderRight ; } redraw ( area . x + area . width - width , area . y , width , area . height , false ) ; int height = 0 ; if ( oldArea . height < area . height ) { height = area . height - oldArea . height + borderBottom ; } if ( oldArea . height > area . height ) { height = borderBottom ; } redraw ( area . x , area . y + area . height - height , area . width , height , false ) ; if ( oldArea . width ! = area . width ) { / / resize the widths so that all tabs are visible layoutItems ( ) ; redrawTabArea ( - 1 ) ; } } } oldArea = area ; / / resize content if ( selectedIndex ! = - 1 ) { Control control = items selectedIndex . getControl ( ) ; if ( control ! = null ! control . isDisposed ( ) ) { control . setBounds ( getClientArea ( ) ) ; } } }', 'public void setBackground ( Color color ) { super . setBackground ( color ) ; color = getBackground ( ) ; / / init inactive close button inactiveCloseBar . setBackground ( color ) ; / / init scroll buttons arrowBar . setBackground ( color ) ; / / init close button if ( gradientColors = = null ) { closeBar . setBackground ( color ) ; } }', '/ * * * Specify a gradient of colours to be draw in the background of the selected tab . * For example to draw a gradient that varies from dark blue to blue and then to * white , use the following call to setBackground : * < pre > * cfolder . setBackground ( new Color { display . getSystemColor ( SWT . COLOR_DARK_BLUE ) , * display . getSystemColor ( SWT . COLOR_BLUE ) , * display . getSystemColor ( SWT . COLOR_WHITE ) , * display . getSystemColor ( SWT . COLOR_WHITE ) } , * new int { 25 , 50 , 100 } ) ; * < / pre > * * param colors an array of Color that specifies the colors to appear in the gradient * in order of appearance left to right . The value < code > null < / code > clears the * background gradient . The value < code > null < / code > can be used inside the array of * Color to specify the background color . * param percents an array of integers between 0 and 100 specifying the percent of the width * of the widget at which the color should change . The size of the percents array must be one * less than the size of the colors array . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void setSelectionBackground ( Color colors , int percents ) { checkWidget ( ) ; if ( colors ! = null ) { if ( percents = = null percents . length ! = colors . length - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( getDisplay ( ) . getDepth ( ) < 15 ) { / / Don t use gradients on low color displays colors = new Color { colors 0 } ; percents = new int { } ; } for ( int i = 0 ; i < percents . length ; i + + ) { if ( percents i < 0 percents i > 100 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( i > 0 percents i < percents i - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } } } / / Are these settings the same as before ? final Color background = getBackground ( ) ; if ( backgroundImage = = null ) { if ( ( gradientColors ! = null ) ( colors ! = null ) ( gradientColors . length = = colors . length ) ) { boolean same = false ; for ( int i = 0 ; i < gradientColors . length ; i + + ) { same = ( gradientColors i = = colors i ) ( ( gradientColors i = = null ) ( colors i = = background ) ) ( ( gradientColors i = = background ) ( colors i = = null ) ) ; if ( ! same ) break ; } if ( same ) { for ( int i = 0 ; i < gradientPercents . length ; i + + ) { same = gradientPercents i = = percents i ; if ( ! same ) break ; } } if ( same ) return ; } } else { backgroundImage = null ; } / / Store the new settings if ( colors = = null ) { gradientColors = null ; gradientPercents = null ; closeBar . setBackground ( background ) ; } else { gradientColors = new Color colors . length ; for ( int i = 0 ; i < colors . length ; + + i ) gradientColors i = ( colors i ! = null ) ? colors i : background ; gradientPercents = new int percents . length ; for ( int i = 0 ; i < percents . length ; + + i ) gradientPercents i = percents i ; if ( getDisplay ( ) . getDepth ( ) < 15 ) closeBar . setBackground ( background ) ; else closeBar . setBackground ( gradientColors gradientColors . length - 1 ) ; } / / Refresh with the new settings if ( selectedIndex > - 1 ) redrawTabArea ( selectedIndex ) ; }', '/ * * * Set the image to be drawn in the background of the selected tab . * * param image the image to be drawn in the background * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setSelectionBackground ( Image image ) { checkWidget ( ) ; if ( image = = backgroundImage ) return ; if ( image ! = null ) { gradientColors = null ; gradientPercents = null ; } backgroundImage = image ; redrawTabArea ( selectedIndex ) ; }', '/ * * * Toggle the visibility of the border * * param show true if the border should be displayed * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setBorderVisible ( boolean show ) { checkWidget ( ) ; if ( showBorders = = show ) return ; showBorders = show ; if ( showBorders ) { if ( ( getStyle ( ) SWT . FLAT ) ! = 0 ) { borderBottom = borderTop = borderLeft = borderRight = 1 ; } else { borderLeft = borderTop = 1 ; borderRight = borderBottom = 3 ; } } else { borderBottom = borderTop = borderLeft = borderRight = 0 ; } onClientAreaChange ( ) ; }', 'public void setFont ( Font font ) { checkWidget ( ) ; if ( font ! = null font . equals ( getFont ( ) ) ) return ; int oldHeight = getTabHeight ( ) ; super . setFont ( font ) ; if ( oldHeight ! = getTabHeight ( ) ) { onClientAreaChange ( ) ; } else { layoutItems ( ) ; redraw ( ) ; } }', '/ * * * Set the foreground color of the selected tab . * * param color the color of the text displayed in the selected tab * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setSelectionForeground ( Color color ) { checkWidget ( ) ; if ( selectionForeground = = color ) return ; if ( color = = null ) color = getForeground ( ) ; selectionForeground = color ; if ( selectedIndex > - 1 ) { redrawTabArea ( selectedIndex ) ; } }', '/ * * * Display an insert marker before or after the specified tab item . * Null will clear the mark . * * param item the item with which the mark is associated or null * * param after true if the mark should be displayed after the specified item * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setInsertMark ( CTabItem item , boolean after ) { checkWidget ( ) ; int index = - 1 ; if ( item ! = null ) { index = indexOf ( item ) ; } setInsertMark ( index , after ) ; }', '/ * * * Display an insert marker before or after the specified tab item . * - 1 will clear the mark . * * param item the index of the item with which the mark is associated or null * * param after true if the mark should be displayed after the specified item * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setInsertMark ( int index , boolean after ) { checkWidget ( ) ; if ( index < - 1 index > = getItemCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( index = = - 1 ) { index = - 2 ; } else { index = after ? index : - - index ; } if ( insertionIndex = = index ) return ; int oldIndex = insertionIndex ; insertionIndex = index ; if ( index > - 1 ) redrawTabArea ( index ) ; if ( oldIndex > 1 ) redrawTabArea ( oldIndex ) ; }', '/ * * * Set the selection to the tab at the specified index . * * param index the index of the tab item to be selected * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setSelection ( int index ) { checkWidget ( ) ; if ( index < 0 index > = items . length ) return ; if ( selectedIndex = = index ) return ; if ( showClose ) { inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; if ( arrowBar . isVisible ( ) ) { Rectangle arrowRect = arrowBar . getBounds ( ) ; arrowRect . width + = borderRight ; closeBar . setVisible ( ! arrowRect . contains ( closeBar . getLocation ( ) ) ) ; } else { closeBar . setVisible ( true ) ; } } int oldIndex = selectedIndex ; selectedIndex = index ; Control control = items index . control ; if ( control ! = null ! control . isDisposed ( ) ) { control . setBounds ( getClientArea ( ) ) ; control . setVisible ( true ) ; } if ( oldIndex ! = - 1 ) { control = items oldIndex . control ; if ( control ! = null ! control . isDisposed ( ) ) { control . setVisible ( false ) ; } } ensureVisible ( ) ; redrawTabArea ( - 1 ) ; }', 'private void ensureVisible ( ) { if ( selectedIndex = = - 1 ) return ; / / make sure selected item is visible Rectangle area = super . getClientArea ( ) ; if ( area . width = = 0 ) return ; int areaWidth = area . x + area . width - borderRight ; CTabItem tabItem = items selectedIndex ; if ( selectedIndex < topTabIndex ) { topTabIndex = selectedIndex ; } layoutItems ( ) ; int scrollWidth = arrowBar . getSize ( ) . x ; int width = areaWidth ; if ( scroll_leftVisible ( ) scroll_rightVisible ( ) ) { width - = scrollWidth ; } while ( tabItem . x + tabItem . width > width selectedIndex ! = topTabIndex ) { topTabIndex + + ; layoutItems ( ) ; width = areaWidth ; if ( scroll_leftVisible ( ) scroll_rightVisible ( ) ) { width - = scrollWidth ; } } }', 'char getMnemonic ( String string ) { int index = 0 ; int length = string . length ( ) ; do { while ( ( index < length ) ( string . charAt ( index ) ! = ) ) index + + ; if ( + + index > = length ) return 0 ; if ( string . charAt ( index ) ! = ) return string . charAt ( index ) ; index + + ; } while ( index < length ) ; return 0 ; }', '/ * * * Set the selection to the tab at the specified item . * * param index the tab item to be selected * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_NULL_ARGUMENT - if argument is null < / li > * < / ul > * / public void setSelection ( CTabItem item ) { checkWidget ( ) ; if ( item = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; int index = indexOf ( item ) ; setSelection ( index ) ; }', '/ * * * Set the selection to the tab at the specified index . * / private void setSelection ( int index , boolean notify ) { int oldSelectedIndex = selectedIndex ; setSelection ( index ) ; if ( notify selectedIndex ! = oldSelectedIndex selectedIndex ! = - 1 ) { Event event = new Event ( ) ; event . item = getItem ( selectedIndex ) ; notifyListeners ( SWT . Selection , event ) ; } }', 'private void updateCloseBar ( ) { int imageHeight = getTabHeight ( ) - CTabItem . TOP_MARGIN - CTabItem . BOTTOM_MARGIN - 6 ; if ( imageHeight < 4 ) return ; if ( closeImage ! = null closeImage . getBounds ( ) . height = = imageHeight ) return ; if ( closeBar ! = null ) closeBar . dispose ( ) ; closeBar = null ; if ( inactiveCloseBar ! = null ) inactiveCloseBar . dispose ( ) ; inactiveCloseBar = null ; createCloseBar ( ) ; ToolItem closeItem = closeBar . getItems ( ) 0 ; ToolItem inactiveCloseItem = inactiveCloseBar . getItems ( ) 0 ; if ( closeImage ! = null ) closeImage . dispose ( ) ; Display display = getDisplay ( ) ; Color foreground = getForeground ( ) ; Color black = display . getSystemColor ( SWT . COLOR_BLACK ) ; Color background = getBackground ( ) ; PaletteData palette = new PaletteData ( new RGB { foreground . getRGB ( ) , background . getRGB ( ) , black . getRGB ( ) } ) ; ImageData imageData = new ImageData ( imageHeight , imageHeight , 4 , palette ) ; imageData . transparentPixel = 1 ; closeImage = new Image ( display , imageData ) ; GC gc = new GC ( closeImage ) ; gc . setBackground ( background ) ; gc . fillRectangle ( 0 , 0 , imageHeight , imageHeight ) ; gc . setForeground ( black ) ; int h = ( imageHeight / 2 ) * 2 ; gc . drawLine ( 0 , 0 , h - 2 , h - 2 ) ; gc . drawLine ( 1 , 0 , h - 1 , h - 2 ) ; gc . drawLine ( 0 , h - 2 , h - 2 , 0 ) ; gc . drawLine ( 1 , h - 2 , h - 1 , 0 ) ; gc . dispose ( ) ; closeItem . setImage ( closeImage ) ; inactiveCloseItem . setImage ( closeImage ) ; }', 'private void updateArrowBar ( ) { int imageHeight = getTabHeight ( ) - CTabItem . TOP_MARGIN - CTabItem . BOTTOM_MARGIN - 6 ; if ( imageHeight < 4 ) return ; if ( arrowLeftImage ! = null arrowLeftImage . getBounds ( ) . height = = imageHeight ) return ; if ( arrowBar ! = null ) arrowBar . dispose ( ) ; arrowBar = null ; if ( arrowLeftImage ! = null ) arrowLeftImage . dispose ( ) ; if ( arrowRightImage ! = null ) arrowRightImage . dispose ( ) ; createArrowBar ( ) ; ToolItem items = arrowBar . getItems ( ) ; ToolItem left = items 0 ; ToolItem right = items 1 ; Display display = getDisplay ( ) ; Color foreground = getForeground ( ) ; Color black = display . getSystemColor ( SWT . COLOR_BLACK ) ; Color background = getBackground ( ) ; PaletteData palette = new PaletteData ( new RGB { foreground . getRGB ( ) , background . getRGB ( ) , black . getRGB ( ) } ) ; ImageData imageData = new ImageData ( imageHeight , imageHeight , 4 , palette ) ; imageData . transparentPixel = 1 ; arrowLeftImage = new Image ( display , imageData ) ; GC gc = new GC ( arrowLeftImage ) ; gc . setBackground ( background ) ; gc . fillRectangle ( 0 , 0 , imageHeight , imageHeight ) ; gc . setBackground ( black ) ; int indent = 0 ; int midpoint = ( imageHeight - 2 * indent ) / 2 ; int height = 2 * midpoint ; int pointArr = new int { indent , indent + midpoint , indent + height , indent , indent + height , indent + height } ; gc . fillPolygon ( pointArr ) ; gc . dispose ( ) ; palette = new PaletteData ( new RGB { foreground . getRGB ( ) , background . getRGB ( ) , black . getRGB ( ) } ) ; imageData = new ImageData ( imageHeight , imageHeight , 4 , palette ) ; imageData . transparentPixel = 1 ; arrowRightImage = new Image ( display , imageData ) ; gc = new GC ( arrowRightImage ) ; gc . setBackground ( background ) ; gc . fillRectangle ( 0 , 0 , imageHeight , imageHeight ) ; gc . setBackground ( black ) ; pointArr = new int { indent , indent , indent , indent + height , indent + height , indent + midpoint } ; gc . fillPolygon ( pointArr ) ; gc . dispose ( ) ; left . setImage ( arrowLeftImage ) ; right . setImage ( arrowRightImage ) ; }', 'private void onMouseDoubleClick ( Event event ) { Event e = new Event ( ) ; e . item = getItem ( new Point ( event . x , event . y ) ) ; notifyListeners ( SWT . DefaultSelection , e ) ; }', '/ * * * A mouse button was pressed down . * If one of the tab scroll buttons was hit , scroll in the appropriate * direction . * If a tab was hit select the tab . * / private void onMouseDown ( Event event ) { for ( int i = 0 ; i < items . length ; i + + ) { if ( items i . getBounds ( ) . contains ( new Point ( event . x , event . y ) ) ) { setSelection ( i , true ) ; return ; } } }', 'private void onMouseExit ( Event event ) { Rectangle inactiveBounds = inactiveCloseBar . getBounds ( ) ; if ( inactiveBounds . contains ( event . x , event . y ) ) return ; inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; if ( ! tip . isDisposed ( ) tip . isVisible ( ) ) tip . setVisible ( false ) ; }', 'private void onMouseHover ( Event event ) { if ( tip . isDisposed ( ) ) return ; Point pt = new Point ( event . x , event . y ) ; CTabItem item = getItem ( pt ) ; if ( item ! = null ) { String tooltip = item . getToolTipText ( ) ; if ( tooltip ! = null ) { Label label = ( Label ) ( tip . getChildren ( ) 0 ) ; label . setText ( tooltip ) ; tip . pack ( ) ; pt . y + = 16 ; pt = toDisplay ( pt ) ; / * * Ensure that the tooltip is on the screen . * / Display display = tip . getDisplay ( ) ; Rectangle rect = display . getBounds ( ) ; Point size = tip . getSize ( ) ; pt . x = Math . max ( 0 , Math . min ( pt . x , rect . width - size . x ) ) ; pt . y = Math . max ( 0 , Math . min ( pt . y , rect . height - size . y ) ) ; tip . setLocation ( pt ) ; tip . setVisible ( true ) ; return ; } } tip . setVisible ( false ) ; }', 'private void onMouseMove ( Event event ) { if ( ! showClose ) return ; CTabItem item = null ; for ( int i = 0 ; i < items . length ; i + + ) { Rectangle rect = items i . getBounds ( ) ; if ( rect . contains ( new Point ( event . x , event . y ) ) ) { item = items i ; break ; } } if ( item = = inactiveItem ) return ; inactiveCloseBar . setVisible ( false ) ; inactiveItem = null ; if ( item = = null item = = getSelection ( ) ) return ; int toolbarHeight = getTabHeight ( ) - CTabItem . TOP_MARGIN - CTabItem . BOTTOM_MARGIN + 2 ; / / + 2 to ignore gab between focus rectangle int x = item . x + item . width - toolbarHeight ; int y = item . y + Math . max ( 0 , ( item . height - toolbarHeight ) / 2 ) ; if ( arrowBar . isVisible ( ) ) { Rectangle scrollArea = arrowBar . getBounds ( ) ; scrollArea . width + = borderRight ; if ( scrollArea . contains ( x , y ) ) return ; } inactiveCloseBar . setBounds ( x , y , toolbarHeight , toolbarHeight ) ; inactiveCloseBar . setVisible ( true ) ; inactiveItem = item ; }', 'private void onTraverse ( Event event ) { switch ( event . detail ) { case SWT . TRAVERSE_ESCAPE : case SWT . TRAVERSE_RETURN : case SWT . TRAVERSE_TAB_NEXT : case SWT . TRAVERSE_TAB_PREVIOUS : event . doit = true ; break ; case SWT . TRAVERSE_MNEMONIC : event . doit = onMnemonic ( event ) ; if ( event . doit ) event . detail = SWT . TRAVERSE_NONE ; break ; case SWT . TRAVERSE_PAGE_NEXT : case SWT . TRAVERSE_PAGE_PREVIOUS : event . doit = onPageTraversal ( event ) ; if ( event . doit ) event . detail = SWT . TRAVERSE_NONE ; break ; } }', 'private boolean onPageTraversal ( Event event ) { int count = getItemCount ( ) ; if ( count = = 0 ) return false ; int index = getSelectionIndex ( ) ; if ( index = = - 1 ) { index = 0 ; } else { int offset = ( event . detail = = SWT . TRAVERSE_PAGE_NEXT ) ? 1 : - 1 ; index = ( index + offset + count ) count ; } setSelection ( index , true ) ; return true ; }', '/ * * * Answer the area where the left scroll button is drawn . * / private Rectangle scroll_getBounds ( ) { if ( arrowBar ! = null ) return arrowBar . getBounds ( ) ; return new Rectangle ( 0 , 0 , 0 , 0 ) ; }', '/ * * * Answer true if not all tabs can be visible in the receive * thus requiring the scroll buttons to be visible . * / private boolean scroll_leftVisible ( ) { return topTabIndex > 0 ; }', '/ * * * Answer true if not all tabs can be visible in the receive * thus requiring the scroll buttons to be visible . * / private boolean scroll_rightVisible ( ) { if ( topTabIndex < items . length - 1 ) { / / only show Scroll buttons if there is more than one item / / and if we are not alread at the last item CTabItem tabItem = items items . length - 1 ; int tabStopX = tabItem . x + tabItem . width ; Rectangle area = super . getClientArea ( ) ; if ( tabStopX > area . x + area . width - borderRight ) { return true ; / / not all tabs fit in the client area } } return false ; }', '/ * * * Scroll the tab items to the left . * / private void scroll_scrollLeft ( ) { if ( scroll_leftVisible ( ) ) { - - topTabIndex ; layoutItems ( ) ; redrawTabArea ( - 1 ) ; } }', '/ * * * Scroll the tab items to the right . * / private void scroll_scrollRight ( ) { if ( scroll_rightVisible ( ) ) { topTabIndex + + ; layoutItems ( ) ; redrawTabArea ( - 1 ) ; } }', '/ * * * Specify a fixed height for the tab items . If no height is specified , * the default height is the height of the text or the image , whichever * is greater . Specifying a height of 0 will revert to the default height . * * param height the pixel value of the height or 0 * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if called with a height of less than 0 < / li > * < / ul > * / public void setTabHeight ( int height ) { checkWidget ( ) ; if ( height < 0 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( fixedTabHeight = = height ) return ; fixedTabHeight = height ; onClientAreaChange ( ) ; }'], 'label': 0}
{'guid': '1839d9b_1b72804de7ac26186c9f067ca50e8e7f8b0e8ff6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public void itemClosed ( CTabFolderEvent event ) { }'], 'label': 0}
{'guid': '1839d9b_c19ecfc43d7b40c565789b215bfed1ff2e786696', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['CTabFolderEvent ( Widget w ) { super ( w ) ; }'], 'label': 0}
{'guid': '1839d9b_cfc10a8796b75827d51a9c43bb574c4c206506cc', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public void itemClosed ( CTabFolderEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_033aad6f18a5e8b94a2481fd9695c14ab985274e', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > Table < / code > ) and a style value * describing its behavior and appearance . The item is added * to the end of the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a CTabFolder which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public CTabItem ( CTabFolder parent , int style ) { this ( parent , style , parent . getItemCount ( ) ) ; }', '/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > Table < / code > ) , a style value * describing its behavior and appearance , and the index * at which to place it in the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a CTabFolder which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * param index the index to store the receiver in its parent * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public CTabItem ( CTabFolder parent , int style , int index ) { super ( parent , checkStyle ( style ) ) ; parent . createItem ( this , index ) ; }', 'private static int checkStyle ( int style ) { return SWT . NONE ; }', 'public void dispose ( ) { if ( isDisposed ( ) ) return ; parent . destroyItem ( this ) ; super . dispose ( ) ; parent = null ; control = null ; toolTipText = null ; }', '/ * * * Returns a rectangle describing the receiver s size and location * relative to its parent . * * param index the index that specifies the column * return the receiver s bounding column rectangle * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Rectangle getBounds ( ) { / / checkWidget ( ) ; return new Rectangle ( x , y , width , height ) ; }', '/ * * * Gets the control that is displayed in the content are of the tab item . * * return the control * * exception SWTError ( ERROR_THREAD_INVALID_ACCESS ) * when called from the wrong thread * exception SWTError ( ERROR_WIDGET_DISPOSED ) * when the widget has been disposed * / public Control getControl ( ) { checkWidget ( ) ; return control ; }', 'public Display getDisplay ( ) { if ( parent = = null ) SWT . error ( SWT . ERROR_WIDGET_DISPOSED ) ; return parent . getDisplay ( ) ; }', '/ * * * Get the image displayed in the tab if the tab is disabled . * * return the disabled image or null * / public Image getDisabledImage ( ) { / / checkWidget ( ) ; return disabledImage ; }', '/ * * * Returns the receiver s parent , which must be a < code > CTabFolder < / code > . * * return the receiver s parent * / public CTabFolder getParent ( ) { / / checkWidget ( ) ; return parent ; }', '/ * * * Returns the receiver s tool tip text , or null if it has * not been set . * * return the receiver s tool tip text * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public String getToolTipText ( ) { checkWidget ( ) ; return toolTipText ; }', '/ * * * Paint the receiver . * / void onPaint ( GC gc , boolean isSelected ) { if ( width = = 0 height = = 0 ) return ; Display display = getDisplay ( ) ; Color highlightShadow = display . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ; Color normalShadow = display . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; int index = parent . indexOf ( this ) ; if ( isSelected ) { Rectangle bounds = null ; if ( ! parent . onBottom ) { if ( index = = parent . topTabIndex ) { bounds = new Rectangle ( x + 1 , y + 1 , width - 2 , height - 1 ) ; } else { bounds = new Rectangle ( x + 2 , y + 1 , width - 3 , height - 1 ) ; } } else { if ( index = = parent . topTabIndex ) { bounds = new Rectangle ( x + 1 , y + 1 , width - 2 , height - 2 ) ; } else { bounds = new Rectangle ( x + 2 , y + 1 , width - 3 , height - 2 ) ; } } if ( parent . backgroundImage ! = null ) { / / draw a background image behind the text Rectangle imageRect = parent . backgroundImage . getBounds ( ) ; gc . drawImage ( parent . backgroundImage , 0 , 0 , imageRect . width , imageRect . height , bounds . x , bounds . y , bounds . width , bounds . height ) ; } else if ( parent . gradientColors ! = null ) { / / draw a gradient behind the text Color oldBackground = gc . getBackground ( ) ; if ( parent . gradientColors . length = = 1 ) { if ( parent . gradientColors 0 ! = null ) gc . setBackground ( parent . gradientColors 0 ) ; gc . fillRectangle ( bounds . x , bounds . y , bounds . width , bounds . height ) ; } else { Color oldForeground = gc . getForeground ( ) ; Color lastColor = parent . gradientColors 0 ; if ( lastColor = = null ) lastColor = oldBackground ; for ( int i = 0 , pos = 0 ; i < parent . gradientPercents . length ; + + i ) { gc . setForeground ( lastColor ) ; lastColor = parent . gradientColors i + 1 ; if ( lastColor = = null ) lastColor = oldBackground ; gc . setBackground ( lastColor ) ; int gradientWidth = ( parent . gradientPercents i * bounds . width / 100 ) - pos ; gc . fillGradientRectangle ( bounds . x + pos , bounds . y , gradientWidth , bounds . height , false ) ; pos + = gradientWidth ; } gc . setForeground ( oldForeground ) ; } gc . setBackground ( oldBackground ) ; } / / draw tab lines if ( ! parent . onBottom ) { gc . setForeground ( normalShadow ) ; if ( index ! = parent . topTabIndex ) { gc . drawLine ( x + 1 , y , x + 1 , y ) ; gc . drawLine ( x , y + 1 , x , y + height - 2 ) ; gc . drawLine ( x , y + height - 1 , x , y + height - 1 ) ; } gc . drawLine ( x + width - 1 , y , x + width - 1 , y ) ; gc . drawLine ( x + width , y + 1 , x + width , y + height - 2 ) ; gc . drawLine ( x + width , y + height - 1 , x + width , y + height - 1 ) ; gc . setForeground ( highlightShadow ) ; if ( index ! = parent . topTabIndex ) { gc . drawLine ( x + 2 , y , x + 2 , y ) ; gc . drawLine ( x + 1 , y + 1 , x + 1 , y + height - 2 ) ; gc . drawLine ( x + 1 , y + height - 1 , x + 1 , y + height - 1 ) ; } else { gc . drawLine ( x , y , x , y + height - 1 ) ; } gc . drawLine ( x + width - 2 , y , x + width - 2 , y ) ; gc . drawLine ( x + width - 1 , y + 1 , x + width - 1 , y + height - 2 ) ; gc . drawLine ( x + width - 1 , y + height - 1 , x + width - 1 , y + height - 1 ) ; / / light line across top if ( index ! = parent . topTabIndex ) { gc . drawLine ( x + 3 , y , x + width - 3 , y ) ; } else { gc . drawLine ( x + 1 , y , x + width - 3 , y ) ; } } else { gc . setForeground ( normalShadow ) ; if ( index ! = parent . topTabIndex ) { gc . drawLine ( x , y , x , y ) ; gc . drawLine ( x , y + 1 , x , y + height - 2 ) ; gc . drawLine ( x + 1 , y + height - 1 , x + 1 , y + height - 1 ) ; } gc . drawLine ( x + width , y , x + width , y ) ; gc . drawLine ( x + width , y + 1 , x + width , y + height - 2 ) ; gc . drawLine ( x + width - 1 , y + height - 1 , x + width - 1 , y + height - 1 ) ; gc . setForeground ( highlightShadow ) ; if ( index ! = parent . topTabIndex ) { gc . drawLine ( x + 1 , y , x + 1 , y ) ; gc . drawLine ( x + 1 , y + 1 , x + 1 , y + height - 2 ) ; gc . drawLine ( x + 2 , y + height - 1 , x + 2 , y + height - 1 ) ; } else { gc . drawLine ( x , y , x , y + height - 1 ) ; } gc . drawLine ( x + width - 1 , y , x + width - 1 , y ) ; gc . drawLine ( x + width - 1 , y + 1 , x + width - 1 , y + height - 2 ) ; gc . drawLine ( x + width - 2 , y + height - 1 , x + width - 2 , y + height - 1 ) ; / / light line across top and bottom if ( index ! = parent . topTabIndex ) { gc . drawLine ( x + 1 , y , x + width - 2 , y ) ; gc . drawLine ( x + 2 , y + height - 1 , x + width - 3 , y + height - 1 ) ; } else { gc . drawLine ( x + 1 , y , x + width - 2 , y ) ; gc . drawLine ( x + 1 , y + height - 1 , x + width - 3 , y + height - 1 ) ; } } if ( parent . isFocusControl ( ) ) { / / draw a focus rectangle int x1 , y1 , width1 , height1 ; if ( ! parent . onBottom ) { if ( index = = parent . topTabIndex ) { x1 = x + 1 ; y1 = y + 1 ; width1 = width - 2 ; height1 = height - 1 ; } else { x1 = x + 2 ; y1 = y + 1 ; width1 = width - 3 ; height1 = height - 1 ; } } else { if ( index = = parent . topTabIndex ) { x1 = x + 1 ; y1 = y + 1 ; width1 = width - 2 ; height1 = height - 2 ; } else { x1 = x + 2 ; y1 = y + 1 ; width1 = width - 3 ; height1 = height - 2 ; } } gc . setBackground ( display . getSystemColor ( SWT . COLOR_BLACK ) ) ; gc . setForeground ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; gc . drawFocus ( x1 , y1 , width1 , height1 ) ; } } else { / / draw tab lines for unselected items gc . setForeground ( normalShadow ) ; if ( ! parent . onBottom ) { if ( index ! = parent . topTabIndex index ! = parent . getSelectionIndex ( ) + 1 ) { gc . drawLine ( x , y , x , y + ( height / 2 ) ) ; } } else { if ( index ! = parent . topTabIndex index ! = parent . getSelectionIndex ( ) + 1 ) { gc . drawLine ( x , y + ( height / 2 ) , x , y + height - 1 ) ; } } } / / draw Image int xDraw = x + LEFT_MARGIN ; Image image = getImage ( ) ; if ( ! isSelected image ! = null ) { Image temp = getDisabledImage ( ) ; if ( temp ! = null ) { image = temp ; } } if ( image ! = null ) { Rectangle imageBounds = image . getBounds ( ) ; int imageX = xDraw ; int imageHeight = Math . min ( height - BOTTOM_MARGIN - TOP_MARGIN , imageBounds . height ) ; int imageY = y + ( height - imageHeight ) / 2 ; int imageWidth = imageBounds . width * imageHeight / imageBounds . height ; gc . drawImage ( image , imageBounds . x , imageBounds . y , imageBounds . width , imageBounds . height , imageX , imageY , imageWidth , imageHeight ) ; xDraw + = imageWidth + INTERNAL_SPACING ; } / / draw Text int textWidth = x + width - xDraw - RIGHT_MARGIN ; if ( isSelected parent . showClose ) { textWidth = x + width - xDraw - parent . closeBar . getSize ( ) . x - RIGHT_MARGIN ; } String text = shortenText ( gc , getText ( ) , textWidth ) ; if ( isSelected parent . selectionForeground ! = null ) { gc . setForeground ( parent . selectionForeground ) ; } else { gc . setForeground ( parent . getForeground ( ) ) ; } int textY = y + ( height - gc . textExtent ( text , SWT . DRAW_MNEMONIC ) . y ) / 2 ; gc . drawText ( text , xDraw , textY , SWT . DRAW_TRANSPARENT SWT . DRAW_MNEMONIC ) ; gc . setForeground ( parent . getForeground ( ) ) ; }', 'private static String shortenText ( GC gc , String text , int width ) { if ( gc . textExtent ( text , SWT . DRAW_MNEMONIC ) . x < = width ) return text ; int ellipseWidth = gc . textExtent ( ellipsis , SWT . DRAW_MNEMONIC ) . x ; int length = text . length ( ) ; int end = length - 1 ; while ( end > 0 ) { text = text . substring ( 0 , end ) ; int l1 = gc . textExtent ( text , SWT . DRAW_MNEMONIC ) . x ; if ( l1 + ellipseWidth < = width ) { return text + ellipsis ; } end - - ; } return "" ; }', '/ * * * Answer the preferred height of the receiver for the GC . * / int preferredHeight ( GC gc ) { Image image = getImage ( ) ; int height = 0 ; if ( image ! = null ) height = image . getBounds ( ) . height ; String text = getText ( ) ; height = Math . max ( height , gc . textExtent ( text , SWT . DRAW_MNEMONIC ) . y ) ; return height + TOP_MARGIN + BOTTOM_MARGIN ; }', '/ * * * Answer the preferred width of the receiver for the GC . * / int preferredWidth ( GC gc ) { int width = 0 ; Image image = getImage ( ) ; if ( image ! = null ) width + = image . getBounds ( ) . width ; String text = getText ( ) ; if ( text ! = null ) { if ( image ! = null ) width + = INTERNAL_SPACING ; width + = gc . textExtent ( text , SWT . DRAW_MNEMONIC ) . x ; } if ( parent . showClose ) width + = INTERNAL_SPACING + preferredHeight ( gc ) ; / / closebar will be square and will fill preferred height return width + LEFT_MARGIN + RIGHT_MARGIN ; }', '/ * * * Sets the control that is used to fill the client area of * the tab folder when the user selects the tab item . * < p > * param control the new control ( or null ) * * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT - if the control has been disposed < / li > * < li > ERROR_INVALID_PARENT - if the control is not in the same widget tree < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setControl ( Control control ) { checkWidget ( ) ; if ( control ! = null ) { if ( control . isDisposed ( ) ) SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; if ( control . getParent ( ) ! = parent ) SWT . error ( SWT . ERROR_INVALID_PARENT ) ; } if ( this . control ! = null ! this . control . isDisposed ( ) ) { this . control . setVisible ( false ) ; } this . control = control ; if ( this . control ! = null ) { int index = parent . indexOf ( this ) ; if ( index = = parent . getSelectionIndex ( ) ) { this . control . setBounds ( parent . getClientArea ( ) ) ; this . control . setVisible ( true ) ; } else { this . control . setVisible ( false ) ; } } }', 'public void setImage ( Image image ) { checkWidget ( ) ; if ( image ! = null image . equals ( getImage ( ) ) ) return ; int oldHeight = parent . getTabHeight ( ) ; super . setImage ( image ) ; if ( oldHeight ! = parent . getTabHeight ( ) ) { parent . onClientAreaChange ( ) ; } else { parent . layoutItems ( ) ; parent . redraw ( ) ; } }', '/ * * * Sets the image that is displayed if the tab item is disabled . * Null will clear the image . * * param image the image to be displayed when the item is disabled or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setDisabledImage ( Image image ) { checkWidget ( ) ; if ( image ! = null image . equals ( getDisabledImage ( ) ) ) return ; disabledImage = image ; parent . redraw ( ) ; }', '/ * * * Set the widget text . * < p > * This method sets the widget label . The label may include * mnemonic characters but must not contain line delimiters . * * param string the new label for the widget * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the text is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setText ( String string ) { checkWidget ( ) ; if ( string . equals ( getText ( ) ) ) return ; super . setText ( string ) ; parent . layoutItems ( ) ; parent . redraw ( ) ; }', '/ * * * Sets the receiver s tool tip text to the argument , which * may be null indicating that no tool tip text should be shown . * * param string the new tool tip text ( or null ) * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setToolTipText ( String string ) { checkWidget ( ) ; toolTipText = string ; }'], 'label': 0}
{'guid': '1839d9b_9dfd02a16d8c31f9ed6abd14bf726641c1ef5938', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a ControlEditor for the specified Composite . * * param parent the Composite above which this editor will be displayed * * / public ControlEditor ( Composite parent ) { this . parent = parent ; internalListener = new Listener ( ) { public void handleEvent ( Event e ) { if ( e . widget instanceof ScrollBar e . type = = SWT . Selection ) scroll ( e ) ; else if ( e . type = = SWT . Resize ) resize ( ) ; } } ; parent . addListener ( SWT . Resize , internalListener ) ; ScrollBar hBar = parent . getHorizontalBar ( ) ; if ( hBar ! = null ) hBar . addListener ( SWT . Selection , internalListener ) ; ScrollBar vBar = parent . getVerticalBar ( ) ; if ( vBar ! = null ) vBar . addListener ( SWT . Selection , internalListener ) ; }', 'public void handleEvent ( Event e ) { if ( e . widget instanceof ScrollBar e . type = = SWT . Selection ) scroll ( e ) ; else if ( e . type = = SWT . Resize ) resize ( ) ; }', 'Rectangle computeBounds ( ) { Rectangle clientArea = parent . getClientArea ( ) ; Rectangle editorRect = new Rectangle ( clientArea . x , clientArea . y , minimumWidth , minimumHeight ) ; if ( grabHorizontal ) editorRect . width = Math . max ( clientArea . width , minimumWidth ) ; if ( grabVertical ) editorRect . height = Math . max ( clientArea . height , minimumHeight ) ; switch ( horizontalAlignment ) { case SWT . RIGHT : editorRect . x + = clientArea . width - editorRect . width ; break ; case SWT . LEFT : / / do nothing - clientArea . x is the right answer break ; default : / / default is CENTER editorRect . x + = ( clientArea . width - editorRect . width ) / 2 ; } switch ( verticalAlignment ) { case SWT . BOTTOM : editorRect . y + = clientArea . height - editorRect . height ; break ; case SWT . TOP : / / do nothing - clientArea . y is the right answer break ; default : / / default is CENTER editorRect . y + = ( clientArea . height - editorRect . height ) / 2 ; } return editorRect ; }', '/ * * * Removes all associations between the Editor and the underlying composite . The * composite and the editor Control are < b > not < / b > disposed . * / public void dispose ( ) { if ( ! parent . isDisposed ( ) ) { parent . removeListener ( SWT . Resize , internalListener ) ; ScrollBar hBar = parent . getHorizontalBar ( ) ; if ( hBar ! = null ) hBar . removeListener ( SWT . Selection , internalListener ) ; ScrollBar vBar = parent . getVerticalBar ( ) ; if ( vBar ! = null ) vBar . removeListener ( SWT . Selection , internalListener ) ; } parent = null ; editor = null ; hadFocus = false ; internalListener = null ; }', '/ * * * Returns the Control that is displayed above the composite being edited . * * return the Control that is displayed above the composite being edited * / public Control getEditor ( ) { return editor ; }', 'void resize ( ) { if ( editor = = null editor . isDisposed ( ) ) return ; if ( editor . getVisible ( ) ) { hadFocus = editor . isFocusControl ( ) ; } / / this doesn t work because / / resizing the column takes the focus away / / before we get here editor . setBounds ( computeBounds ( ) ) ; if ( hadFocus ) editor . setFocus ( ) ; }', 'void scroll ( Event e ) { if ( editor = = null editor . isDisposed ( ) ) return ; if ( editor . getVisible ( ) ) { hadFocus = editor . isFocusControl ( ) ; } boolean visible = e . detail ! = SWT . DRAG ; if ( visible ) { editor . setBounds ( computeBounds ( ) ) ; } editor . setVisible ( visible ) ; if ( visible hadFocus ) editor . setFocus ( ) ; }', '/ * * * Specify the Control that is to be displayed . * * < p > Note : The Control provided as the editor < b > must < / b > be created with its parent * being the Composite specified in the ControlEditor constructor . * * param editor the Control that is displayed above the composite being edited * / public void setEditor ( Control editor ) { if ( editor = = null ) { / / this is the case where the caller is setting the editor to be blank / / set all the values accordingly this . editor = null ; return ; } this . editor = editor ; editor . setVisible ( false ) ; editor . setBounds ( computeBounds ( ) ) ; editor . setVisible ( true ) ; }'], 'label': 0}
{'guid': '1839d9b_530b5a1adbd9303b66e6f4d95925270c857e3a0a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new DefaultContent and initializes it . A < code > StyledTextContent < / > will always have * at least one empty line . * / DefaultContent ( ) { super ( ) ; setText ( "" ) ; }', '/ * * * Adds a line to the end of the line indexes array . Increases the size of the array if necessary . * < code > lineCount < / code > is updated to reflect the new entry . * < p > * * param start the start of the line * param length the length of the line * / void addLineIndex ( int start , int length ) { int size = lines . length ; if ( lineCount = = size ) { / / expand the lines by powers of 2 int newLines = new int size + Compatibility . pow2 ( expandExp ) 2 ; System . arraycopy ( lines , 0 , newLines , 0 , size ) ; lines = newLines ; expandExp + + ; } int range = new int { start , length } ; lines lineCount = range ; lineCount + + ; }', '/ * * * Adds a line index to the end of < code > linesArray < / code > . Increases the * size of the array if necessary and returns a new array . * < p > * * param start the start of the line * param length the length of the line * param linesArray the array to which to add the line index * param count the position at which to add the line * return a new array of line indexes * / int addLineIndex ( int start , int length , int linesArray , int count ) { int size = linesArray . length ; int newLines = linesArray ; if ( count = = size ) { newLines = new int size + Compatibility . pow2 ( replaceExpandExp ) 2 ; replaceExpandExp + + ; System . arraycopy ( linesArray , 0 , newLines , 0 , size ) ; } int range = new int { start , length } ; newLines count = range ; return newLines ; }', '/ * * * Adds a < code > TextChangeListener < / code > listening for * < code > TextChangingEvent < / code > and < code > TextChangedEvent < / code > . A * < code > TextChangingEvent < / code > is sent before changes to the text occur . * A < code > TextChangedEvent < / code > is sent after changes to the text * occured . * < p > * * param listener the listener * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addTextChangeListener ( TextChangeListener listener ) { if ( listener = = null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; StyledTextListener typedListener = new StyledTextListener ( listener ) ; textListeners . addElement ( typedListener ) ; }', '/ * * * Adjusts the gap to accomodate a text change that is occurring . * < p > * * param position the position at which a change is occurring * param sizeHint the size of the change * param line the line where the gap will go * / void adjustGap ( int position , int sizeHint , int line ) { if ( position = = gapStart ) { / / text is being inserted at the gap position int size = ( gapEnd - gapStart ) - sizeHint ; if ( lowWatermark < = size size < = highWatermark ) return ; } else if ( ( position + sizeHint = = gapStart ) ( sizeHint < 0 ) ) { / / text is being deleted at the gap position int size = ( gapEnd - gapStart ) - sizeHint ; if ( lowWatermark < = size size < = highWatermark ) return ; } moveAndResizeGap ( position , sizeHint , line ) ; }', '/ * * * Calculates the indexes of each line in the text store . Assumes no gap exists . * Optimized to do less checking . * / void indexLines ( ) { int start = 0 ; lineCount = 0 ; int textLength = textStore . length ; int i ; for ( i = start ; i < textLength ; i + + ) { char ch = textStore i ; if ( ch = = SWT . CR ) { / / see if the next character is a LF if ( i + 1 < textLength ) { ch = textStore i + 1 ; if ( ch = = SWT . LF ) { i + + ; } } addLineIndex ( start , i - start + 1 ) ; start = i + 1 ; } else if ( ch = = SWT . LF ) { addLineIndex ( start , i - start + 1 ) ; start = i + 1 ; } } addLineIndex ( start , i - start ) ; }', '/ * * * Returns whether or not the given character is a line delimiter . Both CR and LF * are valid line delimiters . * < p > * * param ch the character to test * return true if ch is a delimiter , false otherwise * / boolean isDelimiter ( char ch ) { if ( ch = = SWT . CR ) return true ; if ( ch = = SWT . LF ) return true ; return false ; }', '/ * * * Determine whether or not the replace operation is valid . DefaultContent will not allow * the / r / n line delimiter to be split or partially deleted . * < p > * * param start start offset of text to replace * param replaceLength start offset of text to replace * param newText start offset of text to replace * / protected boolean isValidReplace ( int start , int replaceLength , String newText ) { if ( replaceLength = = 0 ) { / / inserting text , see if the r n line delimiter is being split if ( start = = 0 ) return true ; if ( start = = getCharCount ( ) ) return true ; char before = getTextRange ( start - 1 , 1 ) . charAt ( 0 ) ; if ( before = = r ) { char after = getTextRange ( start , 1 ) . charAt ( 0 ) ; if ( after = = n ) return false ; } } else { / / deleting text , see if part of a r n line delimiter is being deleted char startChar = getTextRange ( start , 1 ) . charAt ( 0 ) ; if ( startChar = = n ) { / / see if char before delete position is r if ( start ! = 0 ) { char before = getTextRange ( start - 1 , 1 ) . charAt ( 0 ) ; if ( before = = r ) return false ; } } char endChar = getTextRange ( start + replaceLength - 1 , 1 ) . charAt ( 0 ) ; if ( endChar = = r ) { / / see if char after delete position is n if ( start + replaceLength ! = getCharCount ( ) ) { char after = getTextRange ( start + replaceLength , 1 ) . charAt ( 0 ) ; if ( after = = n ) return false ; } } } return true ; }', '/ * * * Calculates the indexes of each line of text in the given range . * < p > * * param offset the logical start offset of the text lineate * param length the length of the text to lineate , includes gap * param numLines the number of lines to initially allocate for the line index array , * passed in for efficiency ( the exact number of lines may be known ) * return a line indexes array where each line is identified by a start offset and * a length * / int indexLines ( int offset , int length , int numLines ) { int indexedLines = new int numLines 2 ; int start = 0 ; int lineCnt = 0 ; int i ; replaceExpandExp = 1 ; for ( i = start ; i < length ; i + + ) { int location = i + offset ; if ( ( location > = gapStart ) ( location < gapEnd ) ) { / / ignore the gap } else { char ch = textStore location ; if ( ch = = SWT . CR ) { / / see if the next character is a LF if ( location + 1 < textStore . length ) { ch = textStore location + 1 ; if ( ch = = SWT . LF ) { i + + ; } } indexedLines = addLineIndex ( start , i - start + 1 , indexedLines , lineCnt ) ; lineCnt + + ; start = i + 1 ; } else if ( ch = = SWT . LF ) { indexedLines = addLineIndex ( start , i - start + 1 , indexedLines , lineCnt ) ; lineCnt + + ; start = i + 1 ; } } } int newLines = new int lineCnt + 1 2 ; System . arraycopy ( indexedLines , 0 , newLines , 0 , lineCnt ) ; int range = new int { start , i - start } ; newLines lineCnt = range ; return newLines ; }', '/ * * * Inserts text . * < p > * * param position the position at which to insert the text * param length the text to insert * / void insert ( int position , String text ) { if ( text . length ( ) = = 0 ) return ; int startLine = getLineAtOffset ( position ) ; int change = text . length ( ) ; boolean endInsert = position = = getCharCount ( ) ; adjustGap ( position , change , startLine ) ; / / during an insert the gap will be adjusted to start at / / position and it will be associated with startline , the / / inserted text will be placed in the gap int startLineOffset = getOffsetAtLine ( startLine ) ; / / at this point , startLineLength will include the start line / / and all of the newly inserted text int startLineLength = getPhysicalLine ( startLine ) . length ( ) ; if ( change > 0 ) { / / shrink gap gapStart + = ( change ) ; for ( int i = 0 ; i < text . length ( ) ; i + + ) textStore position + i = text . charAt ( i ) ; } / / figure out the number of new lines that have been inserted int newLines = indexLines ( startLineOffset , startLineLength , 10 ) ; / / only insert an empty line if it is the last line in the text int numNewLines = newLines . length - 1 ; if ( newLines numNewLines 1 = = 0 ) { / / last inserted line is a new line if ( endInsert ) { / / insert happening at end of the text , leave numNewLines as / / is since the last new line will not be concatenated with another / / line numNewLines + = 1 ; } else { numNewLines - = 1 ; } } / / make room for the new lines expandLinesBy ( numNewLines ) ; / / shift down the lines after the replace line for ( int i = lineCount - 1 ; i > startLine ; i - - ) { lines i + numNewLines = lines i ; } / / insert the new lines for ( int i = 0 ; i < numNewLines ; i + + ) { newLines i 0 + = startLineOffset ; lines startLine + i = newLines i ; } / / update the last inserted line if ( numNewLines < newLines . length ) { newLines numNewLines 0 + = startLineOffset ; lines startLine + numNewLines = newLines numNewLines ; } lineCount + = numNewLines ; gapLine = getLineAtPhysicalOffset ( gapStart ) ; }', '/ * * * Moves the gap and adjusts its size in anticipation of a text change . * The gap is resized to actual size + the specified size and moved to the given * position . * < p > * * param position the position at which a change is occurring * param sizeHint the size of the change * param line the line where the gap should be put * / void moveAndResizeGap ( int position , int size , int newGapLine ) { char content = null ; int oldSize = gapEnd - gapStart ; int newSize ; if ( size > 0 ) { newSize = highWatermark + size ; } else { newSize = lowWatermark - size ; } / / remove the old gap from the lines information if ( gapExists ( ) ) { / / adjust the line length lines gapLine 1 = lines gapLine 1 - oldSize ; / / adjust the offsets of the lines after the gapLine for ( int i = gapLine + 1 ; i < lineCount ; i + + ) { lines i 0 = lines i 0 - oldSize ; } } if ( newSize < 0 ) { if ( oldSize > 0 ) { / / removing the gap content = new char textStore . length - oldSize ; System . arraycopy ( textStore , 0 , content , 0 , gapStart ) ; System . arraycopy ( textStore , gapEnd , content , gapStart , content . length - gapStart ) ; textStore = content ; } gapStart = gapEnd = position ; return ; } content = new char textStore . length + ( newSize - oldSize ) ; int newGapStart = position ; int newGapEnd = newGapStart + newSize ; if ( oldSize = = 0 ) { System . arraycopy ( textStore , 0 , content , 0 , newGapStart ) ; System . arraycopy ( textStore , newGapStart , content , newGapEnd , content . length - newGapEnd ) ; } else if ( newGapStart < gapStart ) { int delta = gapStart - newGapStart ; System . arraycopy ( textStore , 0 , content , 0 , newGapStart ) ; System . arraycopy ( textStore , newGapStart , content , newGapEnd , delta ) ; System . arraycopy ( textStore , gapEnd , content , newGapEnd + delta , textStore . length - gapEnd ) ; } else { int delta = newGapStart - gapStart ; System . arraycopy ( textStore , 0 , content , 0 , gapStart ) ; System . arraycopy ( textStore , gapEnd , content , gapStart , delta ) ; System . arraycopy ( textStore , gapEnd + delta , content , newGapEnd , content . length - newGapEnd ) ; } textStore = content ; gapStart = newGapStart ; gapEnd = newGapEnd ; / / add the new gap to the lines information if ( gapExists ( ) ) { gapLine = newGapLine ; / / adjust the line length int gapLength = gapEnd - gapStart ; lines gapLine 1 = lines gapLine 1 + ( gapLength ) ; / / adjust the offsets of the lines after the gapLine for ( int i = gapLine + 1 ; i < lineCount ; i + + ) { lines i 0 = lines i 0 + gapLength ; } } }', '/ * * * Returns the number of lines that are in the specified text . * < p > * * param startOffset the start of the text to lineate * param length the length of the text to lineate * return number of lines * / int lineCount ( int startOffset , int length ) { if ( length = = 0 ) { return 0 ; } int lineCnt = 0 ; int count = 0 ; int i = startOffset ; if ( i > = gapStart ) { i + = gapEnd - gapStart ; } while ( count < length ) { if ( ( i > = gapStart ) ( i < gapEnd ) ) { / / ignore the gap } else { char ch = textStore i ; if ( ch = = SWT . CR ) { / / see if the next character is a LF if ( i + 1 < textStore . length ) { ch = textStore i + 1 ; if ( ch = = SWT . LF ) { i + + ; count + + ; } } lineCnt + + ; } else if ( ch = = SWT . LF ) { lineCnt + + ; } count + + ; } i + + ; } return lineCnt ; }', '/ * * * Returns the number of lines that are in the specified text . * < p > * * param text the text to lineate * return number of lines in the text * / int lineCount ( String text ) { int lineCount = 0 ; int length = text . length ( ) ; for ( int i = 0 ; i < length ; i + + ) { char ch = text . charAt ( i ) ; if ( ch = = SWT . CR ) { if ( i + 1 < length text . charAt ( i + 1 ) = = SWT . LF ) { i + + ; } lineCount + + ; } else if ( ch = = SWT . LF ) { lineCount + + ; } } return lineCount ; }', '/ * * * return the logical length of the text store * / public int getCharCount ( ) { int length = gapEnd - gapStart ; return ( textStore . length - length ) ; }', '/ * * * Returns the line at < code > index < / code > without delimiters . * < p > * * param index the index of the line to return * return the logical line text ( i . e . , without the gap ) * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when index is out of range < / li > * < / ul > * / public String getLine ( int index ) { if ( ( index > = lineCount ) ( index < 0 ) ) error ( SWT . ERROR_INVALID_ARGUMENT ) ; int start = lines index 0 ; int length = lines index 1 ; int end = start + length - 1 ; if ( ! gapExists ( ) ( end < gapStart ) ( start > = gapEnd ) ) { / / line is before or after the gap while ( ( length - 1 > = 0 ) isDelimiter ( textStore start + length - 1 ) ) { length - - ; } return new String ( textStore , start , length ) ; } else { / / gap is in the specified range , strip out the gap StringBuffer buf = new StringBuffer ( ) ; int gapLength = gapEnd - gapStart ; buf . append ( textStore , start , gapStart - start ) ; buf . append ( textStore , gapEnd , length - gapLength - ( gapStart - start ) ) ; length = buf . length ( ) ; while ( ( length - 1 > = 0 ) isDelimiter ( buf . charAt ( length - 1 ) ) ) { length - - ; } return Compatibility . substring ( buf , 0 , length ) ; } }', '/ * * * Returns the line delimiter that should be used by the StyledText * widget when inserting new lines . This delimiter may be different than the * delimiter that is used by the < code > StyledTextContent < / code > interface . * < p > * * return the platform line delimiter as specified in the line . separator * system property . * / public String getLineDelimiter ( ) { return LineDelimiter ; }', '/ * * * Returns the line at the given index with delimiters . * < p > * param index the index of the line to return * return the logical line text ( i . e . , without the gap ) with delimiters * / String getFullLine ( int index ) { int start = lines index 0 ; int length = lines index 1 ; int end = start + length - 1 ; if ( ! gapExists ( ) ( end < gapStart ) ( start > = gapEnd ) ) { / / line is before or after the gap return new String ( textStore , start , length ) ; } else { / / gap is in the specified range , strip out the gap StringBuffer buf = new StringBuffer ( ) ; int gapLength = gapEnd - gapStart ; buf . append ( textStore , start , gapStart - start ) ; buf . append ( textStore , gapEnd , length - gapLength - ( gapStart - start ) ) ; return buf . toString ( ) ; } }', '/ * * * Returns the physical line at the given index ( i . e . , with delimiters and the gap ) . * < p > * * param index the line index * return the physical line * / String getPhysicalLine ( int index ) { int start = lines index 0 ; int length = lines index 1 ; return getPhysicalText ( start , length ) ; }', '/ * * * return the number of lines in the text store * / public int getLineCount ( ) { return lineCount ; }', '/ * * * Returns the line at the given offset . * < p > * * param charPosition logical character offset ( i . e . , does not include gap ) * return the line index * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when charPosition is out of range < / li > * < / ul > * / public int getLineAtOffset ( int charPosition ) { int position ; if ( ( charPosition > getCharCount ( ) ) ( charPosition < 0 ) ) error ( SWT . ERROR_INVALID_ARGUMENT ) ; if ( charPosition < gapStart ) { / / position is before the gap position = charPosition ; } else { / / position includes the gap position = charPosition + ( gapEnd - gapStart ) ; } / / if last line and the line is not empty you can ask for / / a position that doesn t exist ( the one to the right of the / / last character ) - for inserting if ( lineCount > 0 ) { int lastLine = lineCount - 1 ; if ( position = = lines lastLine 0 + lines lastLine 1 ) return lastLine ; } int high = lineCount ; int low = - 1 ; int index = lineCount ; while ( high - low > 1 ) { index = ( high + low ) / 2 ; int lineStart = lines index 0 ; int lineEnd = lineStart + lines index 1 - 1 ; if ( position < = lineStart ) { high = index ; } else if ( position < = lineEnd ) { high = index ; break ; } else { low = index ; } } return high ; }', '/ * * * Returns the line index at the given physical offset . * < p > * * param position physical character offset ( i . e . , includes gap ) * return the line index * / int getLineAtPhysicalOffset ( int position ) { int high = lineCount ; int low = - 1 ; int index = lineCount ; while ( high - low > 1 ) { index = ( high + low ) / 2 ; int lineStart = lines index 0 ; int lineEnd = lineStart + lines index 1 - 1 ; if ( position < = lineStart ) { high = index ; } else if ( position < = lineEnd ) { high = index ; break ; } else { low = index ; } } return high ; }', '/ * * * Returns the logical offset of the given line . * < p > * * param lineIndex index of line * return the logical starting offset of the line . When there are not any lines , * getOffsetAtLine ( 0 ) is a valid call that should answer 0 . * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when lineIndex is out of range < / li > * < / ul > * / public int getOffsetAtLine ( int lineIndex ) { if ( lineIndex = = 0 ) return 0 ; if ( ( lineIndex > = lineCount ) ( lineIndex < 0 ) ) error ( SWT . ERROR_INVALID_ARGUMENT ) ; int start = lines lineIndex 0 ; if ( start > gapEnd ) { return start - ( gapEnd - gapStart ) ; } else { return start ; } }', '/ * * * Increases the line indexes array to accomodate more lines . * < p > * * param numLines the number to increase the array by * / void expandLinesBy ( int numLines ) { int size = lines . length ; if ( size - lineCount > = numLines ) { return ; } int newLines = new int size + Math . max ( 10 , numLines ) 2 ; System . arraycopy ( lines , 0 , newLines , 0 , size ) ; lines = newLines ; }', '/ * * * Reports an SWT error . * < p > * * param code the error code * / void error ( int code ) { SWT . error ( code ) ; }', '/ * * * Returns whether or not a gap exists in the text store . * < p > * * return true if gap exists , false otherwise * / boolean gapExists ( ) { return gapStart ! = gapEnd ; }', '/ * * * Returns a string representing the continous content of * the text store . * < p > * * param start the physical start offset of the text to return * param length the physical length of the text to return * return the text * / String getPhysicalText ( int start , int length ) { return new String ( textStore , start , length ) ; }', '/ * * * Returns a string representing the logical content of * the text store ( i . e . , gap stripped out ) . * < p > * * param start the logical start offset of the text to return * param length the logical length of the text to return * return the text * / public String getTextRange ( int start , int length ) { if ( textStore = = null ) return "" ; if ( length = = 0 ) return "" ; int end = start + length ; if ( ! gapExists ( ) ( end < gapStart ) ) return new String ( textStore , start , length ) ; if ( gapStart < start ) { int gapLength = gapEnd - gapStart ; return new String ( textStore , start + gapLength , length ) ; } StringBuffer buf = new StringBuffer ( ) ; buf . append ( textStore , start , gapStart - start ) ; buf . append ( textStore , gapEnd , end - gapStart ) ; return buf . toString ( ) ; }', '/ * * * Removes the specified < code > TextChangeListener < / code > . * < p > * * param listener the listener * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeTextChangeListener ( TextChangeListener listener ) { if ( listener = = null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; for ( int i = 0 ; i < textListeners . size ( ) ; i + + ) { TypedListener typedListener = ( TypedListener ) textListeners . elementAt ( i ) ; if ( typedListener . getEventListener ( ) = = listener ) { textListeners . removeElementAt ( i ) ; break ; } } }', '/ * * * Replaces the text with < code > newText < / code > starting at position < code > start < / code > * for a length of < code > replaceLength < / code > . Notifies the appropriate listeners . * < p > * * When sending the TextChangingEvent , < code > newLineCount < / code > is the number of * lines that are going to be inserted and < code > replaceLineCount < / code > is * the number of lines that are going to be deleted , based on the change * that occurs visually . For example : * < ul > * < li > ( replaceText , newText ) = = > ( replaceLineCount , newLineCount ) * < li > ( "" , " n" ) = = > ( 0 , 1 ) * < li > ( " n n" , "a" ) = = > ( 2 , 0 ) * < / ul > * < / p > * * param start start offset of text to replace * param replaceLength start offset of text to replace * param newText start offset of text to replace * * exception SWTException < ul > * < li > ERROR_INVALID_ARGUMENT when the text change results in a multi byte * line delimiter being split or partially deleted . Splitting a line * delimiter by inserting text between the CR and LF characters of the * r n delimiter or deleting part of this line delimiter is not supported < / li > * < / ul > * / public void replaceTextRange ( int start , int replaceLength , String newText ) { / / check for invalid replace operations if ( ! isValidReplace ( start , replaceLength , newText ) ) SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; / / inform listeners StyledTextEvent event = new StyledTextEvent ( this ) ; event . type = StyledText . TextChanging ; event . start = start ; event . replaceLineCount = lineCount ( start , replaceLength ) ; event . text = newText ; event . newLineCount = lineCount ( newText ) ; event . replaceCharCount = replaceLength ; event . newCharCount = newText . length ( ) ; sendTextEvent ( event ) ; / / first delete the text to be replaced delete ( start , replaceLength , event . replaceLineCount + 1 ) ; / / then insert the new text insert ( start , newText ) ; / / inform listeners event = new StyledTextEvent ( this ) ; event . type = StyledText . TextChanged ; sendTextEvent ( event ) ; / / printLines ( ) ; }', '/ * * * Sends the text listeners the TextChanged event . * / void sendTextEvent ( StyledTextEvent event ) { for ( int i = 0 ; i < textListeners . size ( ) ; i + + ) { ( ( StyledTextListener ) textListeners . elementAt ( i ) ) . handleEvent ( event ) ; } }', '/ * * * Sets the content to text and removes the gap since there are no sensible predictions * about where the next change will occur . * < p > * * param text the text * / public void setText ( String text ) { textStore = text . toCharArray ( ) ; gapStart = - 1 ; gapEnd = - 1 ; expandExp = 1 ; indexLines ( ) ; StyledTextEvent event = new StyledTextEvent ( this ) ; event . type = StyledText . TextSet ; event . text = "" ; sendTextEvent ( event ) ; }', '/ * * * Deletes text . * < p > * param position the position at which the text to delete starts * param length the length of the text to delete * param numLines the number of lines that are being deleted * / void delete ( int position , int length , int numLines ) { if ( length = = 0 ) return ; int startLine = getLineAtOffset ( position ) ; int startLineOffset = getOffsetAtLine ( startLine ) ; int endLine = getLineAtOffset ( position + length ) ; String endText = "" ; boolean splittingDelimiter = false ; if ( position + length < getCharCount ( ) ) { endText = getTextRange ( position + length - 1 , 2 ) ; if ( ( endText . charAt ( 0 ) = = SWT . CR ) ( endText . charAt ( 1 ) = = SWT . LF ) ) { splittingDelimiter = true ; } } adjustGap ( position + length , - length , startLine ) ; int oldLines = indexLines ( position , length + ( gapEnd - gapStart ) , numLines ) ; / / enlarge the gap - the gap can be enlarged either to the / / right or left if ( position + length = = gapStart ) { gapStart - = length ; } else { gapEnd + = length ; } / / figure out the length of the new concatenated line , do so by / / finding the first line delmiter after position int j = position ; boolean eol = false ; while ( j < textStore . length ! eol ) { if ( j < gapStart j > = gapEnd ) { char ch = textStore j ; if ( isDelimiter ( ch ) ) { if ( j + 1 < textStore . length ) if ( ch = = SWT . CR ( textStore j + 1 = = SWT . LF ) ) j + + ; eol = true ; } } j + + ; } / / update the line where the deletion started lines startLine 1 = ( position - startLineOffset ) + ( j - position ) ; / / figure out the number of lines that have been deleted int numOldLines = oldLines . length - 1 ; if ( splittingDelimiter ) numOldLines - = 1 ; / / shift up the lines after the last deleted line , no need to update / / the offset or length of the lines for ( int i = endLine + 1 ; i < lineCount ; i + + ) { lines i - numOldLines = lines i ; } lineCount - = numOldLines ; gapLine = getLineAtPhysicalOffset ( gapStart ) ; }'], 'label': 0}
{'guid': '1839d9b_4612053c46da308a27eff3119440a216ed07221b', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new default line styler . * < p > * * param content the text to which the styles apply * / public DefaultLineStyler ( StyledTextContent content ) { this . content = content ; lineCount = content . getLineCount ( ) ; lineBackgrounds = new Color lineCount ; }', '/ * * * Inserts a style at the given location . * < p > * * param style the new style * param index the index at which to insert the style ( the new style * will reside at this index ) * * / void insertStyle ( StyleRange style , int index ) { int size = styles . length ; if ( styleCount = = size ) { / / expand the styles array by powers of 2 StyleRange newStyles = new StyleRange size + Compatibility . pow2 ( styleExpandExp ) ; System . arraycopy ( styles , 0 , newStyles , 0 , size ) ; styles = newStyles ; styleExpandExp + + ; } / / shift the styles down to make room for the new style for ( int i = styleCount - 1 ; i > = index ; i - - ) { styles i + 1 = styles i ; } styles index = style ; styleCount + + ; }', '/ * * * Inserts a style , merging it with adjacent styles if possible . * < p > * * param style the new style * param index the index at which to insert the style ( the new style * will reside at this index ) * return true if the style was inserted , false if the style was merged with an adjacent * style * / boolean insertMergeStyle ( StyleRange style , int index ) { if ( mergeStyleBefore ( style , index ) ) return false ; if ( mergeStyleAfter ( style , index ) ) return false ; insertStyle ( style , index ) ; return true ; }', '/ * * * Merges the style with the style before it if possible . * < p > * * param style the new style * param index the index at which to attempt the merge . * return true if the style was merged , false otherwise * / boolean mergeStyleBefore ( StyleRange style , int index ) { / / see if the style is similar to the style before it and merge the / / styles if possible if ( index > 0 ) { StyleRange previous = styles index - 1 ; if ( style . similarTo ( previous ) ) { / / the start of style needs to be in the range of the previous style / / and the end of style needs to be < the start of the next style int previousEnd = previous . start + previous . length ; if ( ( style . start < = previousEnd ) ( style . start > = previous . start ) ) { int styleEnd = style . start + style . length ; if ( ( index = = styleCount ) ( styleEnd < = styles index . start ) ) { previous . length = style . start + style . length - previous . start ; return true ; } } } } return false ; }', '/ * * * Merges the style with the style after it if possible . * < p > * * param style the new style * param index the index at which to attempt the merge . * return true if the style was merged , false otherwise * / boolean mergeStyleAfter ( StyleRange style , int index ) { / / see if the style is similar to the style that will be after it and / / merge the styles if possible if ( index < styleCount ) { StyleRange next = styles index ; if ( style . similarTo ( next ) ) { / / the end of style needs to be in the range of the next style and / / the start of style needs to be > the end of the previous style int styleEnd = style . start + style . length ; int nextEnd = next . start + next . length ; if ( ( styleEnd < = nextEnd ) ( styleEnd > = next . start ) ) { if ( ( index = = 0 ) ( style . start > = styles index - 1 . start + styles index - 1 . length ) ) { next . length = next . start + next . length - style . start ; next . start = style . start ; return true ; } } } } return false ; }', '/ * * * Removes style information that is defined for the range of text in < code > clearStyle < / code > . * < p > * * param clearStyle the style information to use for clearing * / void clearStyle ( StyleRange clearStyle ) { Point pt = getOverlappingStyles ( clearStyle . start , clearStyle . length ) ; int clearStyleEnd = clearStyle . start + clearStyle . length - 1 ; / / no overlapped styles exist if ( ( pt = = null ) ( pt . y = = 0 ) ) return ; / / the newStyle overlaps one or more of the existing styles / / pt . x is the index of the first overlapped style , pt . y is the number of overlapped / / styles int count = 0 ; for ( int i = pt . x ; count < pt . y ; i + + ) { StyleRange overlap = styles i ; int overlapEnd = overlap . start + overlap . length - 1 ; if ( overlap . start < clearStyle . start ) { if ( overlapEnd < = clearStyleEnd ) { / / the end of overlap needs to be cleared overlap . length = clearStyle . start - overlap . start ; } else { / / middle of overlap needs to be cleared , this will / / cause overlap to be broken into two StyleRange endStyle = ( StyleRange ) overlap . clone ( ) ; endStyle . start = clearStyleEnd + 1 ; endStyle . length = overlapEnd - clearStyleEnd ; overlap . length = clearStyle . start - overlap . start ; insertStyle ( endStyle , i + 1 ) ; break ; } } else { if ( overlapEnd < = clearStyleEnd ) { / / entire overlap needs to be cleared deleteStyle ( i ) ; i - - ; } else { / / beginning of overlap needs to be cleared overlap . start = clearStyleEnd + 1 ; overlap . length = overlapEnd - overlap . start + 1 ; break ; } } count + + ; } }', '/ * * * Increases the < code > linebackgrounds < / code > array to accomodate new line background * information . * < p > * * param numLines the number to increase the array by * / void expandLinesBy ( int numLines ) { int size = lineBackgrounds . length ; if ( size - lineCount > = numLines ) { return ; } Color newLines = new Color size + Math . max ( Compatibility . pow2 ( lineExpandExp ) , numLines ) ; System . arraycopy ( lineBackgrounds , 0 , newLines , 0 , size ) ; lineBackgrounds = newLines ; lineExpandExp + + ; }', '/ * * * Deletes the style at < code > index < / code > . * < p > * * param index the index of the style to be deleted * / void deleteStyle ( int index ) { / / move the styles up for ( int i = index + 1 ; i < styleCount ; i + + ) { styles i - 1 = styles i ; } styles styleCount - 1 = null ; styleCount - - ; }', '/ * * * Returns the styles that are defined . * < p > * * return the copied array of styles * / StyleRange getStyleRanges ( ) { StyleRange newStyles = new StyleRange styleCount ; System . arraycopy ( styles , 0 , newStyles , 0 , styleCount ) ; return newStyles ; }', '/ * * * Handles the get line background color callback . * < p > * * param event . lineOffset line number ( input ) * param event . lineText line text ( input ) * param event . background line background color ( output ) * / public void lineGetBackground ( LineBackgroundEvent event ) { int lineIndex = content . getLineAtOffset ( event . lineOffset ) ; event . lineBackground = lineBackgrounds lineIndex ; }', '/ * * * Handles the get line style information callback . * < p > * * param event . lineOffset line number ( input ) * param event . lineText line text ( input ) * param event . styles array of StyleRanges , need to be in order ( output ) * / public void lineGetStyle ( LineStyleEvent event ) { int lineStart = event . lineOffset ; int lineEnd = lineStart + event . lineText . length ( ) ; int high = searchForStyle ( lineStart , lineEnd ) ; StyleRange style = null ; Vector lineStyles = new Vector ( ) ; / / index will represent a style that / / - - starts after the line ( end processing ) / / - - ends before the line ( continue processing ) / / - - starts before the line , ends in the line ( add range ) / / - - starts in the line , ends in the line ( add range ) / / - - starts in the line , ends after the line ( add range ) / / - - starts before the line , ends after the line ( add range ) for ( int index = high ; index < styleCount ; index + + ) { style = styles index ; if ( style . start > lineEnd ) / / style starts after the line , end looping break ; int styleEnd = style . start + style . length - 1 ; if ( styleEnd > = lineStart ) lineStyles . addElement ( style ) ; } event . styles = new StyleRange lineStyles . size ( ) ; lineStyles . copyInto ( event . styles ) ; }', '/ * * * Searches for the first style in the < code > start < / code > - < code > end < / code > range . * < p > * * return the index of the first style that overlaps the input range * / int searchForStyle ( int start , int end ) { int high = styleCount ; int low = - 1 ; int index = high ; / / find the index of the first style for the given range , use a binary search while ( high - low > 1 ) { index = ( high + low ) / 2 ; StyleRange style = styles index ; int styleEnd = style . start + style . length - 1 ; if ( start < = style . start end < = styleEnd ( start > style . start styleEnd > = start styleEnd < end ) ) { high = index ; } else { low = index ; } } return high ; }', '/ * * * Updates the line background colors to reflect a new color . Called by StyledText . * < p > * * param startLine index of the first line to color * param lineCount number of lines to color starting at startLine * param background the background color for the lines * / void setLineBackground ( int startLine , int count , Color background ) { for ( int i = startLine ; i < startLine + count ; i + + ) { lineBackgrounds i = background ; } }', '/ * * * Update the styles to reflect the new style . < code > newStyle < / code > will * replace any old style for the range . When this method is called , the * DefaultLineStyler may merge the new style with an existing style ( if possible ) . * Called by StyledText when a style is added . Called by StyledText . * < p > * * param newStyle the new style information . * / void setStyleRange ( StyleRange newStyle ) { if ( newStyle = = null ) { styles = new StyleRange 0 ; styleExpandExp = 1 ; styleCount = 0 ; return ; } if ( newStyle . length = = 0 ) return ; if ( newStyle . isUnstyled ( ) ) { clearStyle ( newStyle ) ; return ; } Point pt = getOverlappingStyles ( newStyle . start , newStyle . length ) ; int newStyleEnd = newStyle . start + newStyle . length - 1 ; / / no styles exist if ( pt = = null ) { insertStyle ( newStyle , 0 ) ; return ; } / / newStyle does not overlap any other styles if ( pt . y = = 0 ) { insertMergeStyle ( newStyle , pt . x ) ; return ; } / / the newStyle overlaps one or more of the existing styles boolean added = false ; / / indicates whether or not the new style has been added int count = 0 ; / / pt . x is the index of the first overlapped style , pt . y is the number of overlapped / / styles for ( int i = pt . x ; count < pt . y ; i + + ) { StyleRange overlap = styles i ; int overlapEnd = overlap . start + overlap . length - 1 ; if ( overlap . start < newStyle . start ) { if ( overlapEnd < = newStyleEnd ) { / / the end of overlap needs to be replaced by newStyle if ( newStyle . similarTo ( overlap ) ) { / / update overlap to accomodate the new style overlap . length = newStyle . start + newStyle . length - overlap . start ; } else { overlap . length = newStyle . start - overlap . start ; / / see if newStyle can be merged with the style after overlap , if so , / / processing is done if ( mergeStyleAfter ( newStyle , i + 1 ) ) break ; / / otherwise , insert the newStyle , newStyle may still overlap other / / styles after it so continue processing insertStyle ( newStyle , i + 1 ) ; i + + ; } added = true ; } else { / / middle of overlap needs to be replaced by newStyle , this will / / cause overlap to be broken into two if ( newStyle . similarTo ( overlap ) ) break ; StyleRange endStyle = ( StyleRange ) overlap . clone ( ) ; endStyle . start = newStyleEnd + 1 ; endStyle . length = overlapEnd - newStyleEnd ; overlap . length = newStyle . start - overlap . start ; insertStyle ( newStyle , i + 1 ) ; i + + ; insertStyle ( endStyle , i + 1 ) ; / / when newStyle overlaps the middle of a style , this implies that / / processing is done ( no more overlapped styles ) break ; } } else { if ( overlapEnd < = newStyleEnd ) { / / overlap will be replaced by the newStyle , make sure newStyle / / hasn t already been added , if it has just delete overlap if ( ! added ) { styles i = newStyle ; added = true ; } else { deleteStyle ( i ) ; i - - ; } } else { / / beginning of overlap needs to be replaced by newStyle overlap . start = newStyleEnd + 1 ; overlap . length = overlapEnd - overlap . start + 1 ; if ( ! added ) { insertMergeStyle ( newStyle , i ) ; } / / when newStyle overlaps only the beginning of a style , this implies / / that processing is done ( no more overlapped styles ) break ; } } count + + ; } }', '/ * * * Sets the array of styles and discards old styles . Called by StyledText . * < p > * * param styles the new styles , must be in order and non - overlapping * / void setStyleRanges ( StyleRange styles ) { this . styles = new StyleRange styles . length ; System . arraycopy ( styles , 0 , this . styles , 0 , styles . length ) ; styleCount = styles . length ; styleExpandExp = 1 ; }', '/ * * * Updates the style ranges and line backgrounds to reflect a pending text * change . * Called by StyledText when a TextChangingEvent is received . * < p > * * param event the event with the text change information * / public void textChanging ( TextChangingEvent event ) { int startLine = content . getLineAtOffset ( event . start ) ; int startLineOffset = content . getOffsetAtLine ( startLine ) ; textChanging ( event . start , - event . replaceCharCount ) ; textChanging ( event . start , event . newCharCount ) ; if ( event . replaceCharCount = = content . getCharCount ( ) ) { / / all text is going to be replaced , clear line backgrounds linesChanging ( 0 , - lineCount ) ; linesChanging ( 0 , content . getLineCount ( ) - event . replaceLineCount + event . newLineCount ) ; return ; } if ( event . start ! = startLineOffset ) { startLine = startLine + 1 ; } linesChanging ( startLine , - event . replaceLineCount ) ; linesChanging ( startLine , event . newLineCount ) ; }', 'void linesChanging ( int start , int delta ) { if ( delta = = 0 ) return ; boolean inserting = delta > 0 ; if ( inserting ) { / / shift the lines down to make room for new lines expandLinesBy ( delta ) ; for ( int i = lineCount - 1 ; i > = start ; i - - ) { lineBackgrounds i + delta = lineBackgrounds i ; } for ( int i = start ; i < start + delta ; i + + ) { lineBackgrounds i = null ; } } else { / / shift up the lines for ( int i = start - delta ; i < lineCount ; i + + ) { lineBackgrounds i + delta = lineBackgrounds i ; } } lineCount + = delta ; }', 'void textChanging ( int start , int delta ) { if ( delta = = 0 ) return ; StyleRange style ; / / find the index of the first style for the given offset , use a binary search / / to find the index int end ; boolean inserting = delta > 0 ; if ( inserting ) { end = ( start + delta ) - 1 ; } else { end = ( start - delta ) - 1 ; } int high = searchForStyle ( start , end ) ; int index ; / / update the styles that are in the affected range for ( index = high ; index < styleCount ; index + + ) { style = styles index ; if ( inserting ) { if ( style . start > = start ) break ; / / in the insert case only one style range will be directly affected , / / it will need to be split into two and then the newStyle inserted StyleRange beforeStyle = ( StyleRange ) style . clone ( ) ; beforeStyle . length = start - style . start ; style . start = start ; style . length = style . length - beforeStyle . length ; if ( beforeStyle . length ! = 0 ) insertStyle ( beforeStyle , index ) ; index + + ; break ; } else { int styleEnd = style . start + style . length - 1 ; if ( style . start > end ) break ; / / in the delete case , any style that overlaps the change range will be / / affected if ( style . start < start ) { if ( styleEnd < = end ) { / / style starts before change range , ends in change range style . length = start - style . start ; } else { / / style starts before change range , ends after change range style . length = style . length + delta ; index + + ; break ; } } else { if ( styleEnd < = end ) { / / style starts in change range , ends in change range deleteStyle ( index ) ; index - - ; } else { / / style starts in change range , ends after change range style . start = start ; style . length = styleEnd - end ; index + + ; break ; } } } } / / change the offsets of the styles after the affected styles for ( int i = index ; i < styleCount ; i + + ) { style = styles i ; style . start = style . start + delta ; } }', '/ * * * Returns the indexes of the styles that overlap the given range . Styles that partially * or fully overlap the range will be returned . * < p > * * return Point where x is the index of the starting overlap style , y is the number of * styles that overlap the range * / Point getOverlappingStyles ( int start , int length ) { StyleRange style ; if ( styleCount = = 0 ) return null ; / / find the index of the first style for the given offset , use a binary search / / to find the index int end = start + length - 1 ; int high = searchForStyle ( start , end ) ; int count = 0 ; for ( int index = high ; index < styleCount ; index + + ) { style = styles index ; int styleEnd = style . start + style . length - 1 ; if ( style . start > end ) break ; if ( styleEnd > = start ) count + + ; } return new Point ( high , count ) ; }', '/ * * * Returns the background color of a line . Called by StyledText . It is safe to return * the existing Color object since the colors are set and managed by the client . * < p > * * param index the line index * return the background color of the line at the given index * / Color getLineBackground ( int index ) { return lineBackgrounds index ; }', '/ * * * Returns the style for the character at < code > offset < / code > . Called by StyledText . * Returns a new style . Does not return the existing style . * < p > * * param offset the character position in the text * return a cloned StyleRange with start = = offset and length = = 1 if a style is * specified or null if no style is specified * / StyleRange getStyleRangeAtOffset ( int offset ) { if ( styleCount = = 0 ) return null ; Point pt = getOverlappingStyles ( offset , 1 ) ; if ( pt = = null pt . y = = 0 ) return null ; StyleRange newStyle = ( StyleRange ) styles pt . x . clone ( ) ; newStyle . start = offset ; newStyle . length = 1 ; return newStyle ; }', '/ * * * Returns the styles for the given range . Returns the existing styles , * so be careful not to modify the return value . Styles are not cloned * in order to make this method as efficient as possible . * < p > * * param offset the start position of the text range * param length the length of the text range * return a StyleRange array or null if no styles are specified for the text * range * / StyleRange getStyleRangesFor ( int offset , int length ) { if ( styleCount = = 0 ) return null ; Point pt = getOverlappingStyles ( offset , length ) ; if ( pt = = null pt . y = = 0 ) return null ; StyleRange ranges = new StyleRange pt . y ; for ( int i = 0 ; i < pt . y ; i + + ) { StyleRange newStyle = styles pt . x + i ; ranges i = newStyle ; } return ranges ; }'], 'label': 0}
{'guid': '1839d9b_517471267da05d1b63274cbc357a47acc1516337', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public ExtendedModifyEvent ( StyledTextEvent e ) { super ( e ) ; start = e . start ; length = e . end - e . start ; replacedText = e . text ; }'], 'label': 0}
{'guid': '1839d9b_48c5929f83480fd039970ac6cbfb5cf77e15e40a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * This method is called after a text change occurs . * < p > * * param event . start the start offset of the new text ( input ) * param event . length the length of the new text ( input ) * param event . replacedText the replaced text ( input ) * / public void modifyText ( ExtendedModifyEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_711c84302da4e8ed979aa967beb81a3b2fa378d2', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public LineBackgroundEvent ( StyledTextEvent e ) { super ( e ) ; lineOffset = e . detail ; lineText = e . text ; }'], 'label': 0}
{'guid': '1839d9b_1460e264313d6226cdf8563ffea3b1987bd4e06a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * This method is called when a line is about to be drawn in order to get its * background color . * < p > * * param event . lineOffset line start offset ( input ) * param event . lineText line text ( input ) * param event . lineBackground line background color ( output ) * / public void lineGetBackground ( LineBackgroundEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_86a7e0c7a6ad10a945613ed3e6c7ebd0bb2d1fa6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public LineStyleEvent ( StyledTextEvent e ) { super ( e ) ; lineOffset = e . detail ; lineText = e . text ; styles = e . styles ; }'], 'label': 0}
{'guid': '1839d9b_e8e525ece8af6786cebcef0953c21a9a20d953c1', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * This method is called when a line is about to be drawn in order to get the * line s style information . * < p > * * param event . lineOffset line start offset ( input ) * param event . lineText line text ( input ) * param event . styles array of StyleRanges , need to be in order ( output ) * / public void lineGetStyle ( LineStyleEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_5f650a33969d7d310fb36eff7b6cde5294cb57ae', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a PopupList above the specified shell . * / public PopupList ( Shell parent ) { shell = new Shell ( parent , 0 ) ; list = new List ( shell , SWT . SINGLE SWT . V_SCROLL ) ; / / close dialog if user selects outside of the shell shell . addListener ( SWT . Deactivate , new Listener ( ) { public void handleEvent ( Event e ) { shell . setVisible ( false ) ; } ; } ) ; / / resize shell when list resizes shell . addControlListener ( new ControlListener ( ) { public void controlMoved ( ControlEvent e ) { } public void controlResized ( ControlEvent e ) { Rectangle shellSize = shell . getClientArea ( ) ; list . setSize ( shellSize . width , shellSize . height ) ; } } ) ; / / return list selection on Mouse Up or Carriage Return list . addMouseListener ( new MouseListener ( ) { public void mouseDoubleClick ( MouseEvent e ) { } ; public void mouseDown ( MouseEvent e ) { } ; public void mouseUp ( MouseEvent e ) { shell . setVisible ( false ) ; } ; } ) ; list . addKeyListener ( new KeyListener ( ) { public void keyReleased ( KeyEvent e ) { } ; public void keyPressed ( KeyEvent e ) { if ( e . character = = r ) { shell . setVisible ( false ) ; } } ; } ) ; }', 'public void handleEvent ( Event e ) { shell . setVisible ( false ) ; }', 'public void controlMoved ( ControlEvent e ) { }', 'public void controlResized ( ControlEvent e ) { Rectangle shellSize = shell . getClientArea ( ) ; list . setSize ( shellSize . width , shellSize . height ) ; }', 'public void mouseDoubleClick ( MouseEvent e ) { }', 'public void mouseDown ( MouseEvent e ) { }', 'public void mouseUp ( MouseEvent e ) { shell . setVisible ( false ) ; }', 'public void keyReleased ( KeyEvent e ) { }', 'public void keyPressed ( KeyEvent e ) { if ( e . character = = r ) { shell . setVisible ( false ) ; } }', '/ * * * Gets the widget font . * < p > * return the widget font * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public Font getFont ( ) { return list . getFont ( ) ; }', '/ * * * Gets the items . * < p > * This operation will fail if the items cannot * be queried from the OS . * * return the items in the widget * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_CANNOT_GET_ITEM when the operation fails < / li > * < / ul > * / public String getItems ( ) { return list . getItems ( ) ; }', '/ * * * Gets the minimum width of the list . * * return the minimum width of the list * / public int getMinimumWidth ( ) { return minimumWidth ; }', '/ * * * Launches the Popup List , waits for an item to be selected and then closes PopupList . * * param rect the initial size and location of the PopupList ; the dialog will be * positioned so that it does not run off the screen and the largest number of items are visible * * return the text of the selected item or null if no item is selected * / public String open ( Rectangle rect ) { Point listSize = list . computeSize ( rect . width , SWT . DEFAULT ) ; Rectangle screenSize = shell . getDisplay ( ) . getBounds ( ) ; / / Position the dialog so that it does not run off the screen and the largest number of items are visible int spaceBelow = screenSize . height - ( rect . y + rect . height ) - 30 ; int spaceAbove = rect . y - 30 ; int y = 0 ; if ( spaceAbove > spaceBelow listSize . y > spaceBelow ) { / / place popup list above table cell if ( listSize . y > spaceAbove ) { listSize . y = spaceAbove ; } else { listSize . y + = 2 ; } y = rect . y - listSize . y ; } else { / / place popup list below table cell if ( listSize . y > spaceBelow ) { listSize . y = spaceBelow ; } else { listSize . y + = 2 ; } y = rect . y + rect . height ; } / / Make dialog as wide as the cell listSize . x = rect . width ; / / dialog width should not be les than minimumwidth if ( listSize . x < minimumWidth ) listSize . x = minimumWidth ; / / Align right side of dialog with right side of cell int x = rect . x + rect . width - listSize . x ; shell . setBounds ( x , y , listSize . x , listSize . y ) ; shell . open ( ) ; list . setFocus ( ) ; Display display = shell . getDisplay ( ) ; while ( ! shell . isDisposed ( ) shell . isVisible ( ) ) { if ( ! display . readAndDispatch ( ) ) display . sleep ( ) ; } String result = null ; if ( ! shell . isDisposed ( ) ) { String strings = list . getSelection ( ) ; shell . dispose ( ) ; if ( strings . length ! = 0 ) result = strings 0 ; } return result ; }', '/ * * * Selects an item with text that starts with specified String . * < p > * If the item is not currently selected , it is selected . * If the item at an index is selected , it remains selected . * If the string is not matched , it is ignored . * * param string the text of the item * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void select ( String string ) { String items = list . getItems ( ) ; / / find the first entry in the list that starts with the / / specified string if ( string ! = null ) { for ( int i = 0 ; i < items . length ; i + + ) { if ( items i . startsWith ( string ) ) { int index = list . indexOf ( items i ) ; list . select ( index ) ; break ; } } } }', '/ * * * Sets the widget font . * < p > * When new font is null , the font reverts * to the default system font for the widget . * * param font the new font ( or null ) * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void setFont ( Font font ) { list . setFont ( font ) ; }', '/ * * * Sets all items . * < p > * The previous selection is cleared . * The previous items are deleted . * The new items are added . * The top index is set to 0 . * * param items the array of items * * This operation will fail when an item is null * or could not be added in the OS . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when items is null < / li > * < li > ERROR_ITEM_NOT_ADDED when the operation fails < / li > * < / ul > * / public void setItems ( String strings ) { list . setItems ( strings ) ; }', '/ * * * Sets the minimum width of the list . * * param width the minimum width of the list * / public void setMinimumWidth ( int width ) { if ( width < 0 ) throw new SWTError ( SWT . ERROR_INVALID_ARGUMENT ) ; minimumWidth = width ; }'], 'label': 0}
{'guid': '1839d9b_5be042724e469e20fb890c4ee44695b433de04b5', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_d445dfa41b2a13bb7e2662e6587432b7e751be5a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public SashForm ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; if ( ( style SWT . VERTICAL ) ! = 0 ) { orientation = SWT . VERTICAL ; } this . addListener ( SWT . Resize , new Listener ( ) { public void handleEvent ( Event e ) { layout ( true ) ; } } ) ; sashListener = new Listener ( ) { public void handleEvent ( Event e ) { onDragSash ( e ) ; } } ; }', 'public void handleEvent ( Event e ) { layout ( true ) ; }', 'public void handleEvent ( Event e ) { onDragSash ( e ) ; }', 'private static int checkStyle ( int style ) { int mask = SWT . BORDER ; return style mask ; }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; Control controls = getControls ( true ) ; if ( controls . length = = 0 ) return new Point ( wHint , hHint ) ; int width = 0 ; int height = 0 ; boolean vertical = ( orientation = = SWT . VERTICAL ) ; if ( vertical ) { width = wHint ; height + = ( controls . length - 1 ) * SASH_WIDTH ; } else { height = hHint ; width + = controls . length * SASH_WIDTH ; } for ( int i = 0 ; i < controls . length ; i + + ) { if ( vertical ) { Point size = controls i . computeSize ( wHint , SWT . DEFAULT ) ; height + = size . y ; } else { Point size = controls i . computeSize ( SWT . DEFAULT , hHint ) ; width + = size . x ; } } if ( wHint ! = SWT . DEFAULT ) width = wHint ; if ( hHint ! = SWT . DEFAULT ) height = hHint ; return new Point ( width , height ) ; }', '/ * * * Returns SWT . HORIZONTAL if the controls in the SashForm are laid out side by side * or SWT . VERTICAL if the controls in the SashForm are laid out top to bottom . * * return SWT . HORIZONTAL or SWT . VERTICAL * / public int getOrientation ( ) { / / checkWidget ( ) ; return orientation ; }', '/ * * * Answer the control that currently is maximized in the SashForm . * This value may be null . * * return the control that currently is maximized or null * / public Control getMaximizedControl ( ) { / / checkWidget ( ) ; return this . maxControl ; }', '/ * * * Answer the relative weight of each child in the SashForm . The weight represents the * percent of the total width ( if SashForm has Horizontal orientation ) or * total height ( if SashForm has Vertical orientation ) each control occupies . * The weights are returned in order of the creation of the widgets ( weight 0 * corresponds to the weight of the first child created ) . * * return the relative weight of each child * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getWeights ( ) { checkWidget ( ) ; Control cArray = getControls ( false ) ; float ratios = new float cArray . length ; for ( int i = 0 ; i < cArray . length ; i + + ) { Float ratio = ( Float ) cArray i . getData ( "layout ratio" ) ; if ( ratio ! = null ) { ratios i = ratio . floatValue ( ) ; } else { ratios i = ( float ) 0 . 2 ; } } int weights = new int cArray . length ; for ( int i = 0 ; i < weights . length ; i + + ) { weights i = ( int ) ( ratios i * 1000 ) ; } return weights ; }', 'private Control getControls ( boolean onlyVisible ) { Control children = getChildren ( ) ; Control controls = new Control 0 ; for ( int i = 0 ; i < children . length ; i + + ) { if ( children i instanceof Sash ) continue ; if ( onlyVisible ! children i . getVisible ( ) ) continue ; Control newControls = new Control controls . length + 1 ; System . arraycopy ( controls , 0 , newControls , 0 , controls . length ) ; newControls controls . length = children i ; controls = newControls ; } return controls ; }', 'public void layout ( boolean changed ) { checkWidget ( ) ; Rectangle area = getClientArea ( ) ; if ( area . width = = 0 area . height = = 0 ) return ; Control newControls = getControls ( true ) ; if ( controls . length = = 0 newControls . length = = 0 ) return ; controls = newControls ; if ( maxControl ! = null ! maxControl . isDisposed ( ) ) { for ( int i = 0 ; i < controls . length ; i + + ) { if ( controls i ! = maxControl ) { controls i . setBounds ( - 200 , - 200 , 0 , 0 ) ; } else { controls i . setBounds ( area ) ; } } return ; } / / keep just the right number of sashes if ( sashes . length < controls . length - 1 ) { Sash newSashes = new Sash controls . length - 1 ; System . arraycopy ( sashes , 0 , newSashes , 0 , sashes . length ) ; int sashOrientation = ( orientation = = SWT . HORIZONTAL ) ? SWT . VERTICAL : SWT . HORIZONTAL ; for ( int i = sashes . length ; i < newSashes . length ; i + + ) { newSashes i = new Sash ( this , sashOrientation ) ; newSashes i . addListener ( SWT . Selection , sashListener ) ; } sashes = newSashes ; } if ( sashes . length > controls . length - 1 ) { if ( controls . length = = 0 ) { for ( int i = 0 ; i < sashes . length ; i + + ) { sashes i . dispose ( ) ; } sashes = new Sash 0 ; } else { Sash newSashes = new Sash controls . length - 1 ; System . arraycopy ( sashes , 0 , newSashes , 0 , newSashes . length ) ; for ( int i = controls . length - 1 ; i < sashes . length ; i + + ) { sashes i . dispose ( ) ; } sashes = newSashes ; } } if ( controls . length = = 0 ) return ; / / get the ratios float ratios = new float controls . length ; float total = 0 ; for ( int i = 0 ; i < controls . length ; i + + ) { Float ratio = ( Float ) controls i . getData ( "layout ratio" ) ; if ( ratio ! = null ) { ratios i = ratio . floatValue ( ) ; } else { ratios i = ( float ) 0 . 2 ; } total + = ratios i ; } if ( orientation = = SWT . HORIZONTAL ) { total + = ( float ) sashes . length * ( ( float ) SASH_WIDTH / ( float ) area . width ) ; } else { total + = ( float ) sashes . length * ( ( float ) SASH_WIDTH / ( float ) area . height ) ; } if ( orientation = = SWT . HORIZONTAL ) { int width = ( int ) ( ( ratios 0 / total ) * ( float ) area . width ) ; int x = area . x ; controls 0 . setBounds ( x , area . y , width , area . height ) ; x + = width ; for ( int i = 1 ; i < controls . length - 1 ; i + + ) { sashes i - 1 . setBounds ( x , area . y , SASH_WIDTH , area . height ) ; x + = SASH_WIDTH ; width = ( int ) ( ( ratios i / total ) * ( float ) area . width ) ; controls i . setBounds ( x , area . y , width , area . height ) ; x + = width ; } if ( controls . length > 1 ) { sashes sashes . length - 1 . setBounds ( x , area . y , SASH_WIDTH , area . height ) ; x + = SASH_WIDTH ; width = area . width - x ; controls controls . length - 1 . setBounds ( x , area . y , width , area . height ) ; } } else { int height = ( int ) ( ( ratios 0 / total ) * ( float ) area . height ) ; int y = area . y ; controls 0 . setBounds ( area . x , y , area . width , height ) ; y + = height ; for ( int i = 1 ; i < controls . length - 1 ; i + + ) { sashes i - 1 . setBounds ( area . x , y , area . width , SASH_WIDTH ) ; y + = SASH_WIDTH ; height = ( int ) ( ( ratios i / total ) * ( float ) area . height ) ; controls i . setBounds ( area . x , y , area . width , height ) ; y + = height ; } if ( controls . length > 1 ) { sashes sashes . length - 1 . setBounds ( area . x , y , area . width , SASH_WIDTH ) ; y + = SASH_WIDTH ; height = area . height - y ; controls controls . length - 1 . setBounds ( area . x , y , area . width , height ) ; } } }', 'private void onDragSash ( Event event ) { if ( event . detail = = SWT . DRAG ) { / / constrain feedback Rectangle area = getClientArea ( ) ; if ( orientation = = SWT . HORIZONTAL ) { event . x = Math . min ( Math . max ( DRAG_MINIMUM , event . x ) , area . width - DRAG_MINIMUM ) ; } else { event . y = Math . min ( Math . max ( DRAG_MINIMUM , event . y ) , area . height - DRAG_MINIMUM ) ; } return ; } Sash sash = ( Sash ) event . widget ; int sashIndex = - 1 ; for ( int i = 0 ; i < sashes . length ; i + + ) { if ( sashes i = = sash ) { sashIndex = i ; break ; } } if ( sashIndex = = - 1 ) return ; Control c1 = controls sashIndex ; Control c2 = controls sashIndex + 1 ; Rectangle b1 = c1 . getBounds ( ) ; Rectangle b2 = c2 . getBounds ( ) ; Rectangle sashBounds = sash . getBounds ( ) ; Rectangle area = getClientArea ( ) ; if ( orientation = = SWT . HORIZONTAL ) { int shift = event . x - sashBounds . x ; b1 . width + = shift ; b2 . x + = shift ; b2 . width - = shift ; if ( b1 . width < DRAG_MINIMUM b2 . width < DRAG_MINIMUM ) { return ; } c1 . setData ( "layout ratio" , new Float ( ( float ) b1 . width / ( float ) area . width ) ) ; c2 . setData ( "layout ratio" , new Float ( ( float ) b2 . width / ( float ) area . width ) ) ; } else { int shift = event . y - sashBounds . y ; b1 . height + = shift ; b2 . y + = shift ; b2 . height - = shift ; if ( b1 . height < DRAG_MINIMUM b2 . height < DRAG_MINIMUM ) { return ; } c1 . setData ( "layout ratio" , new Float ( ( float ) b1 . height / ( float ) area . height ) ) ; c2 . setData ( "layout ratio" , new Float ( ( float ) b2 . height / ( float ) area . height ) ) ; } c1 . setBounds ( b1 ) ; sash . setBounds ( event . x , event . y , event . width , event . height ) ; c2 . setBounds ( b2 ) ; }', '/ * * * If orientation is SWT . HORIZONTAL , lay the controls in the SashForm * out side by side . If orientation is SWT . VERTICAL , lay the * controls in the SashForm out top to bottom . * * param orientation SWT . HORIZONTAL or SWT . VERTICAL * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if the value of orientation is not SWT . HORIZONTAL or SWT . VERTICAL * < / ul > * / public void setOrientation ( int orientation ) { checkWidget ( ) ; if ( this . orientation = = orientation ) return ; if ( orientation ! = SWT . HORIZONTAL orientation ! = SWT . VERTICAL ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } this . orientation = orientation ; int sashOrientation = ( orientation = = SWT . HORIZONTAL ) ? SWT . VERTICAL : SWT . HORIZONTAL ; for ( int i = 0 ; i < sashes . length ; i + + ) { sashes i . dispose ( ) ; sashes i = new Sash ( this , sashOrientation ) ; sashes i . addListener ( SWT . Selection , sashListener ) ; } layout ( ) ; }', 'public void setLayout ( Layout layout ) { checkWidget ( ) ; }', '/ * * * Specify the control that should take up the entire client area of the SashForm . * If one control has been maximized , and this method is called with a different control , * the previous control will be minimized and the new control will be maximized . . * if the value of control is null , the SashForm will minimize all controls and return to * the default layout where all controls are laid out separated by sashes . * * param control the control to be maximized or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setMaximizedControl ( Control control ) { checkWidget ( ) ; if ( control = = null ) { if ( maxControl ! = null ) { this . maxControl = null ; layout ( ) ; for ( int i = 0 ; i < sashes . length ; i + + ) { sashes i . setVisible ( true ) ; } } return ; } for ( int i = 0 ; i < sashes . length ; i + + ) { sashes i . setVisible ( false ) ; } maxControl = control ; layout ( ) ; }', '/ * * * Specify the relative weight of each child in the SashForm . This will determine * what percent of the total width ( if SashForm has Horizontal orientation ) or * total height ( if SashForm has Vertical orientation ) each control will occupy . * The weights must be positive values and there must be an entry for each * non - sash child of the SashForm . * * param weights the relative weight of each child * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if the weights value is null or of incorrect length ( must match the number of children ) < / li > * < / ul > * / public void setWeights ( int weights ) { checkWidget ( ) ; Control cArray = getControls ( false ) ; if ( weights = = null weights . length ! = cArray . length ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } int total = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { if ( weights i < 0 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } total + = weights i ; } if ( total = = 0 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } for ( int i = 0 ; i < cArray . length ; i + + ) { cArray i . setData ( "layout ratio" , new Float ( ( float ) weights i / ( float ) total ) ) ; } layout ( ) ; }'], 'label': 0}
{'guid': '1839d9b_73335890ec3010053295c70170fc6b95de867b41', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public ScrolledComposite ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; ScrollBar hBar = getHorizontalBar ( ) ; if ( hBar ! = null ) { hBar . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event e ) { hScroll ( ) ; } } ) ; } ScrollBar vBar = getVerticalBar ( ) ; if ( vBar ! = null ) { vBar . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event e ) { vScroll ( ) ; } } ) ; } addListener ( SWT . Resize , new Listener ( ) { public void handleEvent ( Event e ) { resize ( ) ; } } ) ; contentListener = new Listener ( ) { public void handleEvent ( Event e ) { if ( e . type ! = SWT . Resize ) return ; resize ( ) ; } } ; }', 'public void handleEvent ( Event e ) { hScroll ( ) ; }', 'public void handleEvent ( Event e ) { vScroll ( ) ; }', 'public void handleEvent ( Event e ) { resize ( ) ; }', 'public void handleEvent ( Event e ) { if ( e . type ! = SWT . Resize ) return ; resize ( ) ; }', 'private static int checkStyle ( int style ) { int mask = SWT . H_SCROLL SWT . V_SCROLL SWT . BORDER ; return style mask ; }', '/ * * * Returns the Always Show Scrollbars flag . True if the scrollbars are * always shown even if they are not required . False if the scrollbars are only * visible when some part of the composite needs to be scrolled to be seen . * The H_SCROLL and V_SCROLL style bits are also required to enable scrollbars in the * horizontal and vertical directions . * * return the Always Show Scrollbars flag value * / public boolean getAlwaysShowScrollBars ( ) { / / checkWidget ( ) ; return alwaysShowScroll ; }', '/ * * * Get the content that is being scrolled . * * return the control displayed in the content area * / public Control getContent ( ) { / / checkWidget ( ) ; return content ; }', 'private void hScroll ( ) { if ( content = = null ) return ; Point location = content . getLocation ( ) ; ScrollBar hBar = getHorizontalBar ( ) ; int hSelection = hBar . getSelection ( ) ; content . setLocation ( - hSelection , location . y ) ; }', 'public void layout ( boolean changed ) { checkWidget ( ) ; if ( content = = null ) return ; Rectangle contentRect = content . getBounds ( ) ; ScrollBar hBar = getHorizontalBar ( ) ; ScrollBar vBar = getVerticalBar ( ) ; if ( ! alwaysShowScroll ) { boolean hVisible = needHScroll ( contentRect , false ) ; boolean vVisible = needVScroll ( contentRect , hVisible ) ; if ( ! hVisible vVisible ) hVisible = needHScroll ( contentRect , vVisible ) ; if ( hBar ! = null ) hBar . setVisible ( hVisible ) ; if ( vBar ! = null ) vBar . setVisible ( vVisible ) ; } Rectangle hostRect = getClientArea ( ) ; if ( expandHorizontal ) { contentRect . width = Math . max ( minWidth , hostRect . width ) ; } if ( expandVertical ) { contentRect . height = Math . max ( minHeight , hostRect . height ) ; } if ( hBar ! = null ) { hBar . setMaximum ( contentRect . width ) ; hBar . setThumb ( Math . min ( contentRect . width , hostRect . width ) ) ; int hPage = contentRect . width - hostRect . width ; int hSelection = hBar . getSelection ( ) ; if ( hSelection > = hPage ) { if ( hPage < = 0 ) { hSelection = 0 ; hBar . setSelection ( 0 ) ; } contentRect . x = - hSelection ; } } if ( vBar ! = null ) { vBar . setMaximum ( contentRect . height ) ; vBar . setThumb ( Math . min ( contentRect . height , hostRect . height ) ) ; int vPage = contentRect . height - hostRect . height ; int vSelection = vBar . getSelection ( ) ; if ( vSelection > = vPage ) { if ( vPage < = 0 ) { vSelection = 0 ; vBar . setSelection ( 0 ) ; } contentRect . y = - vSelection ; } } content . setBounds ( contentRect ) ; }', 'private boolean needHScroll ( Rectangle contentRect , boolean vVisible ) { ScrollBar hBar = getHorizontalBar ( ) ; if ( hBar = = null ) return false ; Rectangle hostRect = getBounds ( ) ; int border = getBorderWidth ( ) ; hostRect . width - = 2 * border ; ScrollBar vBar = getVerticalBar ( ) ; if ( vVisible vBar ! = null ) hostRect . width - = vBar . getSize ( ) . x ; if ( ! expandHorizontal contentRect . width > hostRect . width ) return true ; if ( expandHorizontal minWidth > hostRect . width ) return true ; return false ; }', 'private boolean needVScroll ( Rectangle contentRect , boolean hVisible ) { ScrollBar vBar = getVerticalBar ( ) ; if ( vBar = = null ) return false ; Rectangle hostRect = getBounds ( ) ; int border = getBorderWidth ( ) ; hostRect . height - = 2 * border ; ScrollBar hBar = getHorizontalBar ( ) ; if ( hVisible hBar ! = null ) hostRect . height - = hBar . getSize ( ) . y ; if ( ! expandHorizontal contentRect . height > hostRect . height ) return true ; if ( expandHorizontal minHeight > hostRect . height ) return true ; return false ; }', 'private void resize ( ) { if ( inResize ) return ; inResize = true ; layout ( ) ; inResize = false ; }', '/ * * * Set the Always Show Scrollbars flag . True if the scrollbars are * always shown even if they are not required . False if the scrollbars are only * visible when some part of the composite needs to be scrolled to be seen . * The H_SCROLL and V_SCROLL style bits are also required to enable scrollbars in the * horizontal and vertical directions . * * param show true to show the scrollbars even when not required , false to show scrollbars only when required * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setAlwaysShowScrollBars ( boolean show ) { checkWidget ( ) ; if ( show = = alwaysShowScroll ) return ; alwaysShowScroll = show ; ScrollBar hBar = getHorizontalBar ( ) ; if ( hBar ! = null alwaysShowScroll ) hBar . setVisible ( true ) ; ScrollBar vBar = getVerticalBar ( ) ; if ( vBar ! = null alwaysShowScroll ) vBar . setVisible ( true ) ; layout ( ) ; }', '/ * * * Set the content that will be scrolled . * * param content the control to be displayed in the content area * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setContent ( Control content ) { checkWidget ( ) ; if ( this . content ! = null ! this . content . isDisposed ( ) ) { this . content . removeListener ( SWT . Resize , contentListener ) ; this . content . setBounds ( new Rectangle ( - 200 , - 200 , 0 , 0 ) ) ; } this . content = content ; ScrollBar vBar = getVerticalBar ( ) ; ScrollBar hBar = getHorizontalBar ( ) ; if ( this . content ! = null ) { if ( vBar ! = null ) { vBar . setMaximum ( 0 ) ; vBar . setThumb ( 0 ) ; vBar . setSelection ( 0 ) ; } if ( hBar ! = null ) { hBar . setMaximum ( 0 ) ; hBar . setThumb ( 0 ) ; hBar . setSelection ( 0 ) ; } content . setLocation ( 0 , 0 ) ; layout ( ) ; this . content . addListener ( SWT . Resize , contentListener ) ; } else { if ( hBar ! = null ) hBar . setVisible ( alwaysShowScroll ) ; if ( vBar ! = null ) vBar . setVisible ( alwaysShowScroll ) ; } }', '/ * * * Configure the ScrolledComposite to resize the content object to be as wide as the * ScrolledComposite when the width of the ScrolledComposite is greater than the * minimum width specified in setMinWidth . If the ScrolledComposite is less than the * minimum width , the content will not resized and instead the horizontal scroll bar will be * used to view the entire width . * If expand is false , this behaviour is turned off . By default , this behaviour is turned off . * * param expand true to expand the content control to fill available horizontal space * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setExpandHorizontal ( boolean expand ) { checkWidget ( ) ; if ( expand = = expandHorizontal ) return ; expandHorizontal = expand ; layout ( ) ; }', '/ * * * Configure the ScrolledComposite to resize the content object to be as tall as the * ScrolledComposite when the height of the ScrolledComposite is greater than the * minimum height specified in setMinHeight . If the ScrolledComposite is less than the * minimum height , the content will not resized and instead the vertical scroll bar will be * used to view the entire height . * If expand is false , this behaviour is turned off . By default , this behaviour is turned off . * * param expand true to expand the content control to fill available vertical space * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setExpandVertical ( boolean expand ) { checkWidget ( ) ; if ( expand = = expandVertical ) return ; expandVertical = expand ; layout ( ) ; }', 'public void setLayout ( Layout layout ) { / / do not allow a layout to be set on this class because layout is being handled by the resize listener checkWidget ( ) ; return ; }', '/ * * * Specify the minimum height at which the ScrolledComposite will begin scrolling the * content with the vertical scroll bar . This value is only relevant if * setExpandVertical ( true ) has been set . * * param height the minimum height or 0 for default height * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setMinHeight ( int height ) { setMinSize ( minWidth , height ) ; }', '/ * * * Specify the minimum width and height at which the ScrolledComposite will begin scrolling the * content with the horizontal scroll bar . This value is only relevant if * setExpandHorizontal ( true ) and setExpandVertical ( true ) have been set . * * param size the minimum size or null for the default size * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setMinSize ( Point size ) { if ( size = = null ) { setMinSize ( 0 , 0 ) ; } else { setMinSize ( size . x , size . y ) ; } }', '/ * * * Specify the minimum width and height at which the ScrolledComposite will begin scrolling the * content with the horizontal scroll bar . This value is only relevant if * setExpandHorizontal ( true ) and setExpandVertical ( true ) have been set . * * param width the minimum width or 0 for default width * param height the minimum height or 0 for default height * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setMinSize ( int width , int height ) { checkWidget ( ) ; if ( width = = minWidth height = = minHeight ) return ; minWidth = Math . max ( 0 , width ) ; minHeight = Math . max ( 0 , height ) ; layout ( ) ; }', '/ * * * Specify the minimum width at which the ScrolledComposite will begin scrolling the * content with the horizontal scroll bar . This value is only relevant if * setExpandHorizontal ( true ) has been set . * * param width the minimum width or 0 for default width * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setMinWidth ( int width ) { setMinSize ( width , minHeight ) ; }', 'private void vScroll ( ) { Control children = getChildren ( ) ; if ( children . length = = 0 ) return ; Control content = children 0 ; Point location = content . getLocation ( ) ; ScrollBar vBar = getVerticalBar ( ) ; int vSelection = vBar . getSelection ( ) ; content . setLocation ( location . x , - vSelection ) ; }'], 'label': 0}
{'guid': '1839d9b_fda4247584e976c45286d4b14485f561c194ce61', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['protected Point computeSize ( Composite composite , int wHint , int hHint , boolean flushCache ) { Control children = composite . getChildren ( ) ; int maxWidth = 0 ; int maxHeight = 0 ; for ( int i = 0 ; i < children . length ; i + + ) { Point size = children i . computeSize ( wHint , hHint , flushCache ) ; maxWidth = Math . max ( size . x , maxWidth ) ; maxHeight = Math . max ( size . y , maxHeight ) ; } int width = wHint , height = hHint ; if ( wHint = = SWT . DEFAULT ) width = maxWidth ; if ( hHint = = SWT . DEFAULT ) height = maxHeight ; return new Point ( width + 2 * marginWidth , height + 2 * marginHeight ) ; }', 'protected void layout ( Composite composite , boolean flushCache ) { Control children = composite . getChildren ( ) ; Rectangle rect = composite . getClientArea ( ) ; rect . x + = marginWidth ; rect . y + = marginHeight ; rect . width - = 2 * marginWidth ; rect . height - = 2 * marginHeight ; for ( int i = 0 ; i < children . length ; i + + ) { children i . setBounds ( rect ) ; children i . setVisible ( children i = = topControl ) ; } }'], 'label': 0}
{'guid': '1839d9b_9fd1bda9f734266cf4b977b1cfcd9a587900e823', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public StyleRange ( ) { }', '/ * * * Create a new style range . * < p > * * param start start offset of the style * param length length of the style * param foreground foreground color of the style , null if none * param background background color of the style , null if none * / public StyleRange ( int start , int length , Color foreground , Color background ) { this . start = start ; this . length = length ; this . foreground = foreground ; this . background = background ; }', '/ * * * Create a new style range . * < p > * * param start start offset of the style * param length length of the style * param foreground foreground color of the style , null if none * param background background color of the style , null if none * param fontStyle font style of the style , may be SWT . NORMAL or SWT . BOLD * / public StyleRange ( int start , int length , Color foreground , Color background , int fontStyle ) { this . start = start ; this . length = length ; this . foreground = foreground ; this . background = background ; this . fontStyle = fontStyle ; }', '/ * * * Compare the specified object to this StyleRange and answer if the two * are equal . The object must be an instance of StyleRange and have the * same field values . * < p > * * param object the object to compare with this object * return true if the objects are equal , false otherwise * / public boolean equals ( Object object ) { StyleRange style ; if ( object = = this ) return true ; if ( object instanceof StyleRange ) style = ( StyleRange ) object ; else return false ; if ( this . start ! = style . start ) return false ; if ( this . length ! = style . length ) return false ; if ( this . foreground ! = null ) { if ( ! this . foreground . equals ( style . foreground ) ) return false ; } else if ( style . foreground ! = null ) return false ; if ( this . background ! = null ) { if ( ! this . background . equals ( style . background ) ) return false ; } else if ( style . background ! = null ) return false ; if ( this . fontStyle ! = style . fontStyle ) return false ; return true ; }', '/ * * * Returns an integer hash code for the receiver . Objects which are * equal answer the same value for this method . * < p > * * return the receiver s hash * / public int hashCode ( ) { return start + length + foreground . hashCode ( ) + background . hashCode ( ) + fontStyle ; }', '/ * * * Returns whether or not the receiver is unstyled ( i . e . , does not have any * style attributes specified ) . * < p > * * return true if the receiver is unstyled , false otherwise . * / public boolean isUnstyled ( ) { if ( this . foreground ! = null ) return false ; if ( this . background ! = null ) return false ; if ( this . fontStyle ! = SWT . NORMAL ) return false ; return true ; }', '/ * * * Compares the specified object to this StyleRange and answer if the two * are similar . The object must be an instance of StyleRange and have the * same field values for except for start and length . * < p > * * param object the object to compare with this object * return true if the objects are similar , false otherwise * / public boolean similarTo ( StyleRange style ) { if ( this . foreground ! = null ) { if ( ! this . foreground . equals ( style . foreground ) ) return false ; } else if ( style . foreground ! = null ) return false ; if ( this . background ! = null ) { if ( ! this . background . equals ( style . background ) ) return false ; } else if ( style . background ! = null ) return false ; if ( this . fontStyle ! = style . fontStyle ) return false ; return true ; }', '/ * * * Answers a new StyleRange with the same values as this StyleRange . * < p > * * return a shallow copy of this StyleRange * / public Object clone ( ) { StyleRange style = new StyleRange ( start , length , foreground , background , fontStyle ) ; return style ; }', '/ * * * Answers a string description of the receiver . * < p > * * return a printable representation for the receiver . * / public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( start + " , " + length + " fg : " + foreground + " bg : " + background + " fStyle : " ) ; if ( fontStyle = = SWT . NORMAL ) { buf . append ( "normal" ) ; } else if ( fontStyle = = SWT . BOLD ) { buf . append ( "bold" ) ; } return buf . toString ( ) ; }'], 'label': 0}
{'guid': '1839d9b_a7c2cefef628a11bcf5fa10cb97e31d8cf9eff2e', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a RTF writer that writes content starting at offset "start" * in the document . < code > start < / code > and < code > length < / code > can be set to specify partial * lines . * < p > * * param start start offset of content to write , 0 based from * beginning of document * param length length of content to write * / public RTFWriter ( int start , int length ) { super ( start , length ) ; colorTable . addElement ( getForeground ( ) ) ; colorTable . addElement ( getBackground ( ) ) ; }', '/ * * * Closes the RTF writer . Once closed no more content can be written . * < b > NOTE : < / b > < code > toString ( ) < / code > does not return a valid RTF string until * < code > close ( ) < / code > has been called . * / public void close ( ) { if ( isClosed ( ) = = false ) { writeHeader ( ) ; write ( " n } } 0" ) ; super . close ( ) ; } }', '/ * * * Returns the index of the specified color in the RTF color table . * < p > * * param color the color * param defaultIndex return value if color is null * return the index of the specified color in the RTF color table * or "defaultIndex" if "color" is null . * / int getColorIndex ( Color color , int defaultIndex ) { int index ; if ( color = = null ) { index = defaultIndex ; } else { index = colorTable . indexOf ( color ) ; if ( index = = - 1 ) { index = colorTable . size ( ) ; colorTable . addElement ( color ) ; } } return index ; }', '/ * * * Writes the RTF header including font table and color table . * / void writeHeader ( ) { StringBuffer header = new StringBuffer ( ) ; FontData fontData = getFont ( ) . getFontData ( ) 0 ; header . append ( " { rtf1 ansi deff0 { fonttbl { f0 fnil" ) ; / / specify code page , necessary for copy to work in bidi / / systems String cpg = System . getProperty ( "file . encoding" ) ; if ( cpg . startsWith ( "Cp" ) cpg . startsWith ( "MS" ) ) { cpg = cpg . substring ( 2 , cpg . length ( ) ) ; header . append ( " cpg" ) ; header . append ( cpg ) ; } header . append ( " " ) ; header . append ( fontData . getName ( ) ) ; header . append ( " ; } } n { colortbl" ) ; for ( int i = 0 ; i < colorTable . size ( ) ; i + + ) { Color color = ( Color ) colorTable . elementAt ( i ) ; header . append ( " red" ) ; header . append ( color . getRed ( ) ) ; header . append ( " green" ) ; header . append ( color . getGreen ( ) ) ; header . append ( " blue" ) ; header . append ( color . getBlue ( ) ) ; header . append ( " ; " ) ; } / / some RTF readers ignore the deff0 font tag . Explicitly / / set the font for the whole document to work around this . header . append ( " } n { f0 fs" ) ; / / font size is specified in half points header . append ( fontData . getHeight ( ) * 2 ) ; header . append ( " " ) ; write ( header . toString ( ) , 0 ) ; }', '/ * * * Appends the specified line text to the RTF data . Lines will be formatted * using the styles queried from the LineStyleListener , if set , or those set * directly in the widget . * < p > * * param line line text to write as RTF . Must not contain line breaks * Line breaks should be written using writeLineDelimiter ( ) * param lineOffset offset of the line . 0 based from the start of the * widget document . Any text occurring before the start offset or after the * end offset specified during object creation is ignored . * exception SWTException < ul > * < li > ERROR_IO when the writer is closed . < / li > * < / ul > * / public void writeLine ( String line , int lineOffset ) { StyleRange styles = new StyleRange 0 ; Color lineBackground = null ; StyledTextEvent event ; if ( isClosed ( ) ) { SWT . error ( SWT . ERROR_IO ) ; } event = getLineStyleData ( lineOffset , line ) ; if ( event ! = null ) { styles = event . styles ; } event = getLineBackgroundData ( lineOffset , line ) ; if ( event ! = null ) { lineBackground = event . lineBackground ; } if ( lineBackground = = null ) { lineBackground = getBackground ( ) ; } writeStyledLine ( line , lineOffset , styles , lineBackground ) ; }', '/ * * * Appends the specified line delmimiter to the RTF data . * < p > * * param lineDelimiter line delimiter to write as RTF . * exception SWTException < ul > * < li > ERROR_IO when the writer is closed . < / li > * < / ul > * / public void writeLineDelimiter ( String lineDelimiter ) { if ( isClosed ( ) ) { SWT . error ( SWT . ERROR_IO ) ; } write ( lineDelimiter , 0 , lineDelimiter . length ( ) ) ; write ( " par " ) ; }', '/ * * * Appends the specified segment of "string" to the RTF data . * Copy from < code > start < / code > up to , but excluding , < code > end < / code > . * < p > * * param string string to copy a segment from . Must not contain * line breaks . Line breaks should be written using writeLineDelimiter ( ) * param start start offset of segment . 0 based . * param end end offset of segment * / void write ( String string , int start , int end ) { int index ; for ( index = start ; index < end ; index + + ) { char c = string . charAt ( index ) ; if ( c = = } c = = { c = = ) { break ; } } if ( index = = end ) { write ( string . substring ( start , end ) ) ; / / string doesn t contain RTF formatting characters , write as is } else { / / string needs to be transformed char text = new char end - start ; string . getChars ( start , end , text , 0 ) ; for ( index = 0 ; index < text . length ; index + + ) { switch ( text index ) { case } : case { : case : write ( " " ) ; default : write ( text index ) ; } } } }', '/ * * * Appends the specified line text to the RTF data . * Use the colors and font styles specified in "styles" and "lineBackground" . * Formatting is written to reflect the text rendering by the text widget . * Style background colors take precedence over the line background color . * Background colors are written using the highlight tag ( vs . the cb tag ) . * < p > * * param line line text to write as RTF . Must not contain line breaks * Line breaks should be written using writeLineDelimiter ( ) * param lineOffset offset of the line . 0 based from the start of the * widget document . Any text occurring before the start offset or after the * end offset specified during object creation is ignored . * param styles styles to use for formatting . Must not be null . * param linebackground line background color to use for formatting . * May be null . * / void writeStyledLine ( String line , int lineOffset , StyleRange styles , Color lineBackground ) { int lineLength = line . length ( ) ; int lineIndex ; int copyEnd ; int startOffset = getStart ( ) ; int endOffset = startOffset + super . getCharCount ( ) ; int writeOffset = startOffset - lineOffset ; if ( writeOffset > = line . length ( ) ) { return ; / / whole line is outside write range } else if ( writeOffset > 0 ) { lineIndex = writeOffset ; / / line starts before RTF write start } else { lineIndex = 0 ; } if ( lineBackground ! = null ) { write ( " { highlight" ) ; write ( getColorIndex ( lineBackground , DEFAULT_BACKGROUND ) ) ; write ( " " ) ; } for ( int i = 0 ; i < styles . length ; i + + ) { StyleRange style = styles i ; int start = style . start - lineOffset ; int end = start + style . length ; int colorIndex ; / / skip over partial first line if ( end < writeOffset ) { continue ; } / / break on partial last line if ( style . start > endOffset ) { break ; } / / write any unstyled text if ( lineIndex < start ) { / / copy to start of style or end of write range ( specified / / during object creation ) or end of line copyEnd = Math . min ( start , endOffset - lineOffset ) ; copyEnd = Math . min ( copyEnd , lineLength ) ; write ( line , lineIndex , copyEnd ) ; lineIndex = copyEnd ; if ( copyEnd ! = start ) { break ; } } / / write styled text colorIndex = getColorIndex ( style . background , DEFAULT_BACKGROUND ) ; write ( " { cf" ) ; write ( getColorIndex ( style . foreground , DEFAULT_FOREGROUND ) ) ; if ( colorIndex ! = DEFAULT_BACKGROUND ) { write ( " highlight" ) ; write ( colorIndex ) ; } if ( style . fontStyle = = SWT . BOLD ) { write ( " b" ) ; } write ( " " ) ; / / copy to end of style or end of write range ( specified / / during object creation ) or end of line copyEnd = Math . min ( end , endOffset - lineOffset ) ; copyEnd = Math . min ( copyEnd , lineLength ) ; write ( line , lineIndex , copyEnd ) ; if ( style . fontStyle = = SWT . BOLD ) { write ( " b0" ) ; } write ( " } " ) ; lineIndex = copyEnd ; if ( copyEnd ! = end ) { break ; } } copyEnd = Math . min ( lineLength , endOffset - lineOffset ) ; if ( lineIndex < copyEnd ) { write ( line , lineIndex , copyEnd ) ; } if ( lineBackground ! = null ) { write ( " } " ) ; } }', '/ * * * Creates a writer that writes content starting at offset "start" * in the document . < code > start < / code > and < code > length < / code > can be set to specify partial lines . * < p > * * param start start offset of content to write , 0 based from beginning of document * param length length of content to write * / public TextWriter ( int start , int length ) { buffer = new StringBuffer ( length ) ; startOffset = start ; endOffset = start + length ; }', '/ * * * Closes the writer . Once closed no more content can be written . * < b > NOTE : < / b > < code > toString ( ) < / code > is not guaranteed to return a valid string unless * the writer is closed . * / public void close ( ) { if ( isClosed = = false ) { isClosed = true ; } }', '/ * * * Returns the number of characters to write . * / public int getCharCount ( ) { return endOffset - startOffset ; }', '/ * * * Returns the offset where writing starts . 0 based from the start of * the widget text . Used to write partial lines . * / public int getStart ( ) { return startOffset ; }', '/ * * * Returns whether the writer is closed . * / public boolean isClosed ( ) { return isClosed ; }', '/ * * * Returns the string . < code > close ( ) < / code > must be called before < code > toString ( ) < / code > * is guaranteed to return a valid string . * < p > * * return the string * / public String toString ( ) { return buffer . toString ( ) ; }', '/ * * * Appends the given string to the data . * / void write ( String string ) { buffer . append ( string ) ; }', '/ * * * Inserts the given string to the data at the specified offset . * Do nothing if "offset" is < 0 or > getCharCount ( ) * < p > * * param string text to insert * param offset offset in the existing data to insert "string" at . * / void write ( String string , int offset ) { if ( offset < 0 offset > buffer . length ( ) ) { return ; } buffer . insert ( offset , string ) ; }', '/ * * * Appends the given int to the data . * / void write ( int i ) { buffer . append ( i ) ; }', '/ * * * Appends the given character to the data . * / void write ( char i ) { buffer . append ( i ) ; }', '/ * * * Appends the specified line text to the data . * < p > * * param line line text to write . Must not contain line breaks * Line breaks should be written using writeLineDelimiter ( ) * param lineOffset offset of the line . 0 based from the start of the * widget document . Any text occurring before the start offset or after the * end offset specified during object creation is ignored . * exception SWTException < ul > * < li > ERROR_IO when the writer is closed . < / li > * < / ul > * / public void writeLine ( String line , int lineOffset ) { int lineLength = line . length ( ) ; int lineIndex ; int copyEnd ; int writeOffset = startOffset - lineOffset ; if ( isClosed ) { SWT . error ( SWT . ERROR_IO ) ; } if ( writeOffset > = lineLength ) { return ; / / whole line is outside write range } else if ( writeOffset > 0 ) { lineIndex = writeOffset ; / / line starts before write start } else { lineIndex = 0 ; } copyEnd = Math . min ( lineLength , endOffset - lineOffset ) ; if ( lineIndex < copyEnd ) { write ( line . substring ( lineIndex , copyEnd ) ) ; } }', '/ * * * Appends the specified line delmimiter to the data . * < p > * * param lineDelimiter line delimiter to write * exception SWTException < ul > * < li > ERROR_IO when the writer is closed . < / li > * < / ul > * / public void writeLineDelimiter ( String lineDelimiter ) { if ( isClosed ) { SWT . error ( SWT . ERROR_IO ) ; } write ( lineDelimiter ) ; }', '/ * * * Calculates the lines in the specified range . * < p > * * param startLine first line to calculate * param lineCount number of lines to calculate * / public void calculate ( int startLine , int lineCount ) ;', '/ * * * Returns a width that will be used by the < code > StyledText < / code > * widget to size a horizontal scroll bar . * < p > * * return the line width * / public int getWidth ( ) ;', '/ * * * Resets the lines in the specified range . * This method is called in < code > StyledText . redraw ( ) < / code > * and allows implementors to call redraw themselves during reset . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = implementors should retain a * valid width even if it is affected by the reset operation . * false = the width may be set to 0 * / public void redrawReset ( int startLine , int lineCount , boolean calculateMaxWidth ) ;', '/ * * * Resets the lines in the specified range . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = implementors should retain a * valid width even if it is affected by the reset operation . * false = the width may be set to 0 * / public void reset ( int startLine , int lineCount , boolean calculateMaxWidth ) ;', '/ * * * Called when a text change occurred . * < p > * * param startOffset the start offset of the text change * param newLineCount the number of inserted lines * param replaceLineCount the number of deleted lines * param newCharCount the number of new characters * param replaceCharCount the number of deleted characters * / public void textChanged ( int startOffset , int newLineCount , int replaceLineCount , int newCharCount , int replaceCharCount ) ;', '/ * * * Creates a new < code > ContentWidthCache < / code > and allocates space * for the given number of lines . * < p > * * param parent the StyledText widget used to create a GC for * line measuring * param lineCount initial number of lines to allocate space for * / public ContentWidthCache ( StyledText parent , int lineCount ) { this . lineCount = lineCount ; this . parent = parent ; lineWidth = new int lineCount ; reset ( 0 , lineCount , false ) ; }', '/ * * * Calculates the width of each line in the given range if it has * not been calculated yet . * If any line in the given range is wider than the currently widest * line , the maximum line width is updated , * < p > * * param startLine first line to calculate the line width of * param lineCount number of lines to calculate the line width for * / public void calculate ( int startLine , int lineCount ) { GC gc = null ; FontData currentFont = null ; int caretWidth = 0 ; int stopLine = startLine + lineCount ; for ( int i = startLine ; i < stopLine ; i + + ) { if ( lineWidth i = = - 1 ) { String line = content . getLine ( i ) ; int lineOffset = content . getOffsetAtLine ( i ) ; if ( gc = = null ) { gc = new GC ( parent ) ; caretWidth = getCaretWidth ( ) ; if ( isBidi ( ) = = false ) { currentFont = gc . getFont ( ) . getFontData ( ) 0 ; } } lineWidth i = contentWidth ( line , lineOffset , gc , currentFont ) + caretWidth ; } if ( lineWidth i > maxWidth ) { maxWidth = lineWidth i ; maxWidthLineIndex = i ; } } if ( gc ! = null ) { gc . dispose ( ) ; } }', '/ * * * Calculates the width of the visible lines in the specified * range . * < p > * * param startLine the first changed line * param newLineCount the number of inserted lines * / void calculateVisible ( int startLine , int newLineCount ) { int topIndex = parent . getTopIndex ( ) ; int bottomLine = Math . min ( getPartialBottomIndex ( ) , startLine + newLineCount ) ; startLine = Math . max ( startLine , topIndex ) ; calculate ( startLine , bottomLine - startLine + 1 ) ; }', '/ * * * Measures the width of the given line . * < p > * * param line the line to measure * param lineOffset start offset of the line to measure , relative * to the start of the document * param gc the GC to use for measuring the line * param currentFont the font currently set in gc . Cached for better * performance . Null when running in a bidi locale . * return the width of the given line * / int contentWidth ( String line , int lineOffset , GC gc , FontData currentFont ) { int width ; if ( isBidi ( ) ) { StyledTextBidi bidi = getStyledTextBidi ( line , lineOffset , gc ) ; width = bidi . getTextWidth ( ) ; } else { StyledTextEvent event = getLineStyleData ( lineOffset , line ) ; StyleRange styles = null ; if ( event ! = null ) { styles = filterLineStyles ( event . styles ) ; } width = textWidth ( line , lineOffset , 0 , line . length ( ) , styles , 0 , gc , currentFont ) ; } return width ; }', '/ * * * Grows the < code > lineWidth < / code > array to accomodate new line width * information . * < p > * * param numLines the number of elements to increase the array by * / void expandLines ( int numLines ) { int size = lineWidth . length ; if ( size - lineCount > = numLines ) { return ; } int newLines = new int Math . max ( size * 2 , size + numLines ) ; System . arraycopy ( lineWidth , 0 , newLines , 0 , size ) ; lineWidth = newLines ; reset ( size , lineWidth . length - size , false ) ; }', '/ * * * Returns the width of the longest measured line . * < p > * * return the width of the longest measured line . * / public int getWidth ( ) { return maxWidth ; }', '/ * * * Updates the line width array to reflect inserted or deleted lines . * < p > * * param start the starting line of the change that took place * param delta the number of lines in the change , > 0 indicates lines inserted , * < 0 indicates lines deleted * / void linesChanged ( int startLine , int delta ) { boolean inserting = delta > 0 ; if ( delta = = 0 ) { return ; } if ( inserting ) { / / shift the lines down to make room for new lines expandLines ( delta ) ; for ( int i = lineCount - 1 ; i > = startLine ; i - - ) { lineWidth i + delta = lineWidth i ; } / / reset the new lines for ( int i = startLine + 1 ; i < = startLine + delta i < lineWidth . length ; i + + ) { lineWidth i = - 1 ; } / / have new lines been inserted above the longest line ? if ( maxWidthLineIndex > = startLine ) { maxWidthLineIndex + = delta ; } } else { / / shift up the lines for ( int i = startLine - delta ; i < lineCount ; i + + ) { lineWidth i + delta = lineWidth i ; } / / has the longest line been removed ? if ( maxWidthLineIndex > startLine maxWidthLineIndex < = startLine - delta ) { maxWidth = 0 ; maxWidthLineIndex = - 1 ; } else if ( maxWidthLineIndex > = startLine - delta ) { maxWidthLineIndex + = delta ; } } lineCount + = delta ; }', '/ * * * Resets the line width of the lines in the specified range . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = if the widest line is being * reset the maximum width of all remaining cached lines is * calculated . false = the maximum width is set to 0 if the * widest line is being reset . * / public void redrawReset ( int startLine , int lineCount , boolean calculateMaxWidth ) { reset ( startLine , lineCount , calculateMaxWidth ) ; }', '/ * * * Resets the line width of the lines in the specified range . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = if the widest line is being * reset the maximum width of all remaining cached lines is * calculated . false = the maximum width is set to 0 if the * widest line is being reset . * / public void reset ( int startLine , int lineCount , boolean calculateMaxWidth ) { int endLine = startLine + lineCount ; if ( startLine < 0 endLine > lineWidth . length ) { return ; } for ( int i = startLine ; i < endLine ; i + + ) { lineWidth i = - 1 ; } / / if the longest line is one of the reset lines , the maximum line / / width is no longer valid if ( maxWidthLineIndex > = startLine maxWidthLineIndex < endLine ) { maxWidth = 0 ; maxWidthLineIndex = - 1 ; if ( calculateMaxWidth ) { for ( int i = 0 ; i < lineCount ; i + + ) { if ( lineWidth i > maxWidth ) { maxWidth = lineWidth i ; maxWidthLineIndex = i ; } } } } }', '/ * * * Updates the line width array to reflect a text change . * Lines affected by the text change will be reset . * < p > * * param startOffset the start offset of the text change * param newLineCount the number of inserted lines * param replaceLineCount the number of deleted lines * param newCharCount the number of new characters * param replaceCharCount the number of deleted characters * / public void textChanged ( int startOffset , int newLineCount , int replaceLineCount , int newCharCount , int replaceCharCount ) { int startLine = parent . getLineAtOffset ( startOffset ) ; boolean removedMaxLine = ( maxWidthLineIndex > startLine maxWidthLineIndex < = startLine + replaceLineCount ) ; / / entire text deleted ? if ( startLine = = 0 replaceLineCount = = lineCount ) { lineCount = newLineCount ; lineWidth = new int lineCount ; reset ( 0 , lineCount , false ) ; maxWidth = 0 ; } else { linesChanged ( startLine , - replaceLineCount ) ; linesChanged ( startLine , newLineCount ) ; lineWidth startLine = - 1 ; } / / only calculate the visible lines . otherwise measurements of changed lines / / outside the visible area may subsequently change again without the / / lines ever being visible . calculateVisible ( startLine , newLineCount ) ; / / maxWidthLineIndex will be - 1 ( i . e . , unknown line width ) if the widget has / / not been visible yet and the changed lines have therefore not been / / calculated above . if ( removedMaxLine ( maxWidthLineIndex ! = - 1 lineWidth maxWidthLineIndex < maxWidth ) ) { / / longest line has been removed or changed and is now shorter . / / need to recalculate maximum content width for all lines maxWidth = 0 ; for ( int i = 0 ; i < lineCount ; i + + ) { if ( lineWidth i > maxWidth ) { maxWidth = lineWidth i ; maxWidthLineIndex = i ; } } } }', '/ * * * Creates a new < code > WordWrapCache < / code > and calculates an initial * line wrapping . * < p > * * param parent the StyledText widget to wrap content in . * param content the content provider that does the actual line wrapping . * / public WordWrapCache ( StyledText parent , WrappedContent content ) { this . parent = parent ; visualContent = content ; visualContent . wrapLines ( ) ; }', '/ * * * Do nothing . Lines are wrapped immediately after reset . * < p > * * param startLine first line to calculate * param lineCount number of lines to calculate * / public void calculate ( int startLine , int lineCount ) { }', '/ * * * Returns the client area width . Lines are wrapped so there * is no horizontal scroll bar . * < p > * * return the line width * / public int getWidth ( ) { return parent . getClientArea ( ) . width ; }', '/ * * * Wraps the lines in the specified range . * This method is called in < code > StyledText . redraw ( ) < / code > . * A redraw is therefore not necessary . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = implementors should retain a * valid width even if it is affected by the reset operation . * false = the width may be set to 0 * / public void redrawReset ( int startLine , int lineCount , boolean calculateMaxWidth ) { if ( lineCount = = visualContent . getLineCount ( ) ) { / / do a full rewrap if all lines are reset visualContent . wrapLines ( ) ; } else { visualContent . reset ( startLine , lineCount ) ; } }', '/ * * * Rewraps the lines in the specified range and redraws * the widget if the line wrapping has changed . * < p > * * param startLine the first line to reset * param lineCount the number of lines to reset * param calculateMaxWidth true = implementors should retain a * valid width even if it is affected by the reset operation . * false = the width may be set to 0 * / public void reset ( int startLine , int lineCount , boolean calculateMaxWidth ) { int endLine = startLine + lineCount ; int itemCount = getPartialBottomIndex ( ) - topIndex + 1 ; int oldLineOffsets = new int itemCount ; for ( int i = 0 ; i < itemCount ; i + + ) { oldLineOffsets i = visualContent . getOffsetAtLine ( i + topIndex ) ; } redrawReset ( startLine , lineCount , calculateMaxWidth ) ; / / check for cases which will require a full redraw if ( getPartialBottomIndex ( ) - topIndex + 1 ! = itemCount ) { / / number of visible lines has changed parent . internalRedraw ( ) ; } else { for ( int i = 0 ; i < itemCount ; i + + ) { if ( visualContent . getOffsetAtLine ( i + topIndex ) ! = oldLineOffsets i ) { / / wrapping of one of the visible lines has changed parent . internalRedraw ( ) ; break ; } } } }', '/ * * * Passes the text change notification to the line wrap content . * < p > * * param startOffset the start offset of the text change * param newLineCount the number of inserted lines * param replaceLineCount the number of deleted lines * param newCharCount the number of new characters * param replaceCharCount the number of deleted characters * / public void textChanged ( int startOffset , int newLineCount , int replaceLineCount , int newCharCount , int replaceCharCount ) { visualContent . textChanged ( startOffset , newLineCount , replaceLineCount , newCharCount , replaceCharCount ) ; parent . internalRedraw ( ) ; }', 'public StyledText ( Composite parent , int style ) { super ( parent , checkStyle ( style SWT . NO_REDRAW_RESIZE SWT . NO_BACKGROUND ) ) ; Display display = getDisplay ( ) ; isBidi = StyledTextBidi . isBidiPlatform ( ) ; if ( ( style SWT . READ_ONLY ) ! = 0 ) { setEditable ( false ) ; } clipboard = new Clipboard ( display ) ; calculateLineHeight ( ) ; calculateTabWidth ( ) ; installDefaultContent ( ) ; initializeFonts ( ) ; if ( ( style SWT . WRAP ) ! = 0 ) { setWordWrap ( true ) ; } else { lineCache = new ContentWidthCache ( this , content . getLineCount ( ) ) ; } if ( isBidi ( ) = = false ) { Caret caret = new Caret ( this , SWT . NULL ) ; caret . setSize ( 1 , caret . getSize ( ) . y ) ; } else { createCaretBitmaps ( ) ; createBidiCaret ( ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { / / setBidiCaretLocation calculates caret location like during / / cursor movement and takes keyboard language into account . / / Fixes 1GKPYMK setBidiCaretLocation ( null ) ; } } ; StyledTextBidi . addLanguageListener ( this , runnable ) ; } if ( ( style SWT . BORDER ) = = 0 ( style SWT . SINGLE ) = = 0 ) { leftMargin = topMargin = rightMargin = bottomMargin = 0 ; } / / set the caret width , the height of the caret will default to the line height calculateScrollBars ( ) ; createKeyBindings ( ) ; ibeamCursor = new Cursor ( display , SWT . CURSOR_IBEAM ) ; setCursor ( ibeamCursor ) ; installListeners ( ) ; installDefaultLineStyler ( ) ; }', 'public void run ( ) { / / setBidiCaretLocation calculates caret location like during / / cursor movement and takes keyboard language into account . / / Fixes 1GKPYMK setBidiCaretLocation ( null ) ; }', '/ * * * Adds an extended modify listener . An ExtendedModify event is sent by the * widget when the widget text has changed . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addExtendedModifyListener ( ExtendedModifyListener extendedModifyListener ) { checkWidget ( ) ; if ( extendedModifyListener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; StyledTextListener typedListener = new StyledTextListener ( extendedModifyListener ) ; addListener ( ExtendedModify , typedListener ) ; }', '/ * * * Maps a key to an action . * One action can be associated with N keys . However , each key can only * have one action ( key : action is N : 1 relation ) . * < p > * * param key a key code defined in SWT . java or a character . * Optionally ORd with a state mask ( one or more of SWT . CTRL , SWT . SHIFT , SWT . ALT ) * param action one of the predefined actions defined in ST . java . * Use SWT . NULL to remove a key binding . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setKeyBinding ( int key , int action ) { checkWidget ( ) ; if ( action = = SWT . NULL ) { keyActionMap . remove ( new Integer ( key ) ) ; } else { keyActionMap . put ( new Integer ( key ) , new Integer ( action ) ) ; } }', '/ * * * Adds a bidirectional segment listener . A BidiSegmentEvent is sent * whenever a line of text is measured or rendered . The user can * specify text ranges in the line that should be treated as if they * had a different direction than the surrounding text . * This may be used when adjacent segments of right - to - left text should * not be reordered relative to each other . * E . g . , Multiple Java string literals in a right - to - left language * should generally remain in logical order to each other , that is , the * way they are stored . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * see BidiSegmentEvent * since 2 . 0 * / public void addBidiSegmentListener ( BidiSegmentListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } StyledTextListener typedListener = new StyledTextListener ( listener ) ; addListener ( LineGetSegments , typedListener ) ; }', '/ * * * Adds a line background listener . A LineGetBackground event is sent by the * widget to determine the background color for a line . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addLineBackgroundListener ( LineBackgroundListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( userLineBackground = = false ) { removeLineBackgroundListener ( defaultLineStyler ) ; defaultLineStyler . setLineBackground ( 0 , logicalContent . getLineCount ( ) , null ) ; userLineBackground = true ; } StyledTextListener typedListener = new StyledTextListener ( listener ) ; addListener ( LineGetBackground , typedListener ) ; }', '/ * * * Adds a line style listener . A LineGetStyle event is sent by the widget to * determine the styles for a line . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addLineStyleListener ( LineStyleListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( userLineStyle = = false ) { removeLineStyleListener ( defaultLineStyler ) ; defaultLineStyler . setStyleRange ( null ) ; userLineStyle = true ; } StyledTextListener typedListener = new StyledTextListener ( listener ) ; addListener ( LineGetStyle , typedListener ) ; }', '/ * * * Adds a modify listener . A Modify event is sent by the widget when the widget text * has changed . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addModifyListener ( ModifyListener modifyListener ) { checkWidget ( ) ; if ( modifyListener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } TypedListener typedListener = new TypedListener ( modifyListener ) ; addListener ( SWT . Modify , typedListener ) ; }', '/ * * * Adds a selection listener . A Selection event is sent by the widget when the * selection has changed . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Selection , typedListener ) ; }', '/ * * * Adds a verify key listener . A VerifyKey event is sent by the widget when a key * is pressed . The widget ignores the key press if the listener sets the doit field * of the event to false . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addVerifyKeyListener ( VerifyKeyListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } StyledTextListener typedListener = new StyledTextListener ( listener ) ; addListener ( VerifyKey , typedListener ) ; }', '/ * * * Adds a verify listener . A Verify event is sent by the widget when the widget text * is about to change . The listener can set the event text and the doit field to * change the text that is set in the widget or to force the widget to ignore the * text change . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addVerifyListener ( VerifyListener verifyListener ) { checkWidget ( ) ; if ( verifyListener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } TypedListener typedListener = new TypedListener ( verifyListener ) ; addListener ( SWT . Verify , typedListener ) ; }', '/ * * * Appends a string to the text at the end of the widget . * < p > * * param string the string to be appended * see replaceTextRange ( int , int , String ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void append ( String string ) { checkWidget ( ) ; if ( string = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } int lastChar = Math . max ( getCharCount ( ) , 0 ) ; replaceTextRange ( lastChar , 0 , string ) ; }', '/ * * * Returns the width of the specified text . * < p > * * param text text to be measured . * param startOffset offset of the character to start measuring and * expand tabs . * param length number of characters to measure . Tabs are counted * as one character in this parameter . * param startXOffset x position of "startOffset" in "text" . Used for * calculating tab stops * param bidi the bidi object to use for measuring text in bidi locales . * return width of the text with tabs expanded to tab stops or 0 if the * startOffset or length is outside the specified text . * / int bidiTextWidth ( String text , int startOffset , int length , int startXOffset , StyledTextBidi bidi ) { int endOffset = startOffset + length ; int textLength = text . length ( ) ; if ( startOffset < 0 startOffset > = textLength endOffset > textLength ) { return 0 ; } / / Use lastCaretDirection in order to get same results as during / / caret positioning ( setBidiCaretLocation ) . Fixes 1GKU4C5 . return bidi . getCaretPosition ( endOffset , lastCaretDirection ) - startXOffset ; }', '/ * * * Calculates the width of the widest visible line . * / void calculateContentWidth ( ) { if ( lineHeight ! = 0 ) { lineCache = getLineCache ( content ) ; lineCache . calculate ( topIndex , getPartialBottomIndex ( ) - topIndex + 1 ) ; } }', '/ * * * Calculates the line height * / void calculateLineHeight ( ) { GC gc = new GC ( this ) ; lineHeight = gc . getFontMetrics ( ) . getHeight ( ) ; gc . dispose ( ) ; }', '/ * * * Calculates the width in pixel of a tab character * / void calculateTabWidth ( ) { StringBuffer tabBuffer = new StringBuffer ( tabLength ) ; GC gc = new GC ( this ) ; for ( int i = 0 ; i < tabLength ; i + + ) { tabBuffer . append ( ) ; } tabWidth = gc . stringExtent ( tabBuffer . toString ( ) ) . x ; gc . dispose ( ) ; }', '/ * * * Calculates the scroll bars * / void calculateScrollBars ( ) { ScrollBar horizontalBar = getHorizontalBar ( ) ; ScrollBar verticalBar = getVerticalBar ( ) ; setScrollBars ( ) ; if ( verticalBar ! = null ) { verticalBar . setIncrement ( getVerticalIncrement ( ) ) ; } if ( horizontalBar ! = null ) { horizontalBar . setIncrement ( getHorizontalIncrement ( ) ) ; } }', '/ * * * Hides the scroll bars if widget is created in single line mode . * / static int checkStyle ( int style ) { if ( ( style SWT . SINGLE ) ! = 0 ) { style = ( SWT . H_SCROLL SWT . V_SCROLL ) ; } return style ; }', '/ * * * Scrolls down the text to use new space made available by a resize or by * deleted lines . * / void claimBottomFreeSpace ( ) { int newVerticalOffset = Math . max ( 0 , content . getLineCount ( ) * lineHeight - getClientArea ( ) . height ) ; if ( newVerticalOffset < verticalScrollOffset ) { / / Scroll up so that empty lines below last text line are used . / / Fixes 1GEYJM0 setVerticalScrollOffset ( newVerticalOffset , true ) ; } }', '/ * * * Scrolls text to the right to use new space made available by a resize . * / void claimRightFreeSpace ( ) { int newHorizontalOffset = Math . max ( 0 , lineCache . getWidth ( ) - ( getClientArea ( ) . width - leftMargin - rightMargin ) ) ; if ( newHorizontalOffset < horizontalScrollOffset ) { / / item is no longer drawn past the right border of the client area / / align the right end of the item with the right border of the / / client area ( window is scrolled right ) . scrollHorizontalBar ( newHorizontalOffset - horizontalScrollOffset ) ; } }', '/ * * * Removes the widget selection . * < p > * * param sendEvent a Selection event is sent when set to true and when the selection is actually reset . * / void clearSelection ( boolean sendEvent ) { int selectionStart = selection . x ; int selectionEnd = selection . y ; int length = content . getCharCount ( ) ; resetSelection ( ) ; / / redraw old selection , if any if ( selectionEnd - selectionStart > 0 ) { / / called internally to remove selection after text is removed / / therefore make sure redraw range is valid . int redrawStart = Math . min ( selectionStart , length ) ; int redrawEnd = Math . min ( selectionEnd , length ) ; if ( redrawEnd - redrawStart > 0 ) { internalRedrawRange ( redrawStart , redrawEnd - redrawStart , true ) ; } if ( sendEvent = = true ) { sendSelectionEvent ( ) ; } } }', '/ * * * Computes the preferred size . * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int count , width , height ; boolean singleLine = ( getStyle ( ) SWT . SINGLE ) ! = 0 ; if ( singleLine ) { count = 1 ; } else { count = content . getLineCount ( ) ; } if ( wordWrap ) { if ( wHint ! = SWT . DEFAULT ) { width = wHint ; } else { width = DEFAULT_WIDTH ; } if ( singleLine = = false ) { ( ( WrappedContent ) content ) . wrapLines ( width ) ; count = content . getLineCount ( ) ; } } else if ( wHint ! = SWT . DEFAULT ) { width = wHint ; } else { / / Only calculate what can actually be displayed . / / Do this because measuring each text line is a / / time - consuming process . int visibleCount = Math . min ( count , getDisplay ( ) . getBounds ( ) . height / lineHeight ) ; lineCache . calculate ( 0 , visibleCount ) ; width = lineCache . getWidth ( ) + leftMargin + rightMargin ; } / / If a height or width has been specified ( via hHint and wHint ) , / / use those values . Otherwise calculate the size based on the / / text that is defined . if ( hHint ! = SWT . DEFAULT ) { height = hHint ; } else { height = count * lineHeight + topMargin + bottomMargin ; } / / Use default values if no text is defined . if ( width = = 0 ) { width = DEFAULT_WIDTH ; } if ( height = = 0 ) { if ( singleLine ) { height = lineHeight ; } else { height = DEFAULT_HEIGHT ; } } Rectangle rect = computeTrim ( 0 , 0 , width , height ) ; return new Point ( rect . width , rect . height ) ; }', '/ * * * Copies the selected text to the clipboard . The text will be put in the * clipboard in plain text format and RTF format . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void copy ( ) { checkWidget ( ) ; int length = selection . y - selection . x ; if ( length > 0 ) { RTFTransfer rtfTransfer = RTFTransfer . getInstance ( ) ; TextTransfer plainTextTransfer = TextTransfer . getInstance ( ) ; RTFWriter rtfWriter = new RTFWriter ( selection . x , length ) ; TextWriter plainTextWriter = new TextWriter ( selection . x , length ) ; String rtfText = getPlatformDelimitedText ( rtfWriter ) ; String plainText = getPlatformDelimitedText ( plainTextWriter ) ; try { clipboard . setContents ( new String { rtfText , plainText } , new Transfer { rtfTransfer , plainTextTransfer } ) ; } catch ( SWTError error ) { / / Copy to clipboard failed . This happens when another application / / is accessing the clipboard while we copy . Ignore the error . / / Fixes 1GDQAVN } } }', '/ * * * Returns a string that uses only the line delimiter specified by the * StyledTextContent implementation . * Returns only the first line if the widget has the SWT . SINGLE style . * < p > * * param text the text that may have line delimiters that don t * match the model line delimiter . Possible line delimiters * are CR ( r ) , LF ( n ) , CR / LF ( " r n" ) * return the converted text that only uses the line delimiter * specified by the model . Returns only the first line if the widget * has the SWT . SINGLE style . * / String getModelDelimitedText ( String text ) { StringBuffer convertedText ; String delimiter = getLineDelimiter ( ) ; int length = text . length ( ) ; int crIndex = 0 ; int lfIndex = 0 ; int i = 0 ; if ( length = = 0 ) { return text ; } convertedText = new StringBuffer ( length ) ; while ( i < length ) { if ( crIndex ! = - 1 ) { crIndex = text . indexOf ( SWT . CR , i ) ; } if ( lfIndex ! = - 1 ) { lfIndex = text . indexOf ( SWT . LF , i ) ; } if ( lfIndex = = - 1 crIndex = = - 1 ) { / / no more line breaks ? break ; } else / / CR occurs before LF or no LF present ? if ( ( crIndex < lfIndex crIndex ! = - 1 ) lfIndex = = - 1 ) { convertedText . append ( text . substring ( i , crIndex ) ) ; if ( lfIndex = = crIndex + 1 ) { / / CR / LF combination ? i = lfIndex + 1 ; } else { i = crIndex + 1 ; } } else { / / LF occurs before CR ! convertedText . append ( text . substring ( i , lfIndex ) ) ; i = lfIndex + 1 ; } if ( isSingleLine ( ) ) { break ; } convertedText . append ( delimiter ) ; } / / copy remaining text if any and if not in single line mode or no / / text copied thus far ( because there only is one line ) if ( i < length ( isSingleLine ( ) = = false convertedText . length ( ) = = 0 ) ) { convertedText . append ( text . substring ( i ) ) ; } return convertedText . toString ( ) ; }', '/ * * * Creates default key bindings . * / void createKeyBindings ( ) { / / Navigation setKeyBinding ( SWT . ARROW_UP , ST . LINE_UP ) ; setKeyBinding ( SWT . ARROW_DOWN , ST . LINE_DOWN ) ; setKeyBinding ( SWT . HOME , ST . LINE_START ) ; setKeyBinding ( SWT . END , ST . LINE_END ) ; setKeyBinding ( SWT . ARROW_LEFT , ST . COLUMN_PREVIOUS ) ; setKeyBinding ( SWT . ARROW_RIGHT , ST . COLUMN_NEXT ) ; setKeyBinding ( SWT . PAGE_UP , ST . PAGE_UP ) ; setKeyBinding ( SWT . PAGE_DOWN , ST . PAGE_DOWN ) ; setKeyBinding ( SWT . ARROW_LEFT SWT . CTRL , ST . WORD_PREVIOUS ) ; setKeyBinding ( SWT . ARROW_RIGHT SWT . CTRL , ST . WORD_NEXT ) ; setKeyBinding ( SWT . HOME SWT . CTRL , ST . TEXT_START ) ; setKeyBinding ( SWT . END SWT . CTRL , ST . TEXT_END ) ; setKeyBinding ( SWT . PAGE_UP SWT . CTRL , ST . WINDOW_START ) ; setKeyBinding ( SWT . PAGE_DOWN SWT . CTRL , ST . WINDOW_END ) ; / / Selection setKeyBinding ( SWT . ARROW_UP SWT . SHIFT , ST . SELECT_LINE_UP ) ; setKeyBinding ( SWT . ARROW_DOWN SWT . SHIFT , ST . SELECT_LINE_DOWN ) ; setKeyBinding ( SWT . HOME SWT . SHIFT , ST . SELECT_LINE_START ) ; setKeyBinding ( SWT . END SWT . SHIFT , ST . SELECT_LINE_END ) ; setKeyBinding ( SWT . ARROW_LEFT SWT . SHIFT , ST . SELECT_COLUMN_PREVIOUS ) ; setKeyBinding ( SWT . ARROW_RIGHT SWT . SHIFT , ST . SELECT_COLUMN_NEXT ) ; setKeyBinding ( SWT . PAGE_UP SWT . SHIFT , ST . SELECT_PAGE_UP ) ; setKeyBinding ( SWT . PAGE_DOWN SWT . SHIFT , ST . SELECT_PAGE_DOWN ) ; setKeyBinding ( SWT . ARROW_LEFT SWT . CTRL SWT . SHIFT , ST . SELECT_WORD_PREVIOUS ) ; setKeyBinding ( SWT . ARROW_RIGHT SWT . CTRL SWT . SHIFT , ST . SELECT_WORD_NEXT ) ; setKeyBinding ( SWT . HOME SWT . CTRL SWT . SHIFT , ST . SELECT_TEXT_START ) ; setKeyBinding ( SWT . END SWT . CTRL SWT . SHIFT , ST . SELECT_TEXT_END ) ; setKeyBinding ( SWT . PAGE_UP SWT . CTRL SWT . SHIFT , ST . SELECT_WINDOW_START ) ; setKeyBinding ( SWT . PAGE_DOWN SWT . CTRL SWT . SHIFT , ST . SELECT_WINDOW_END ) ; / / Modification / / Cut , Copy , Paste / / CUA style setKeyBinding ( u0018 SWT . CTRL , ST . CUT ) ; setKeyBinding ( u0003 SWT . CTRL , ST . COPY ) ; setKeyBinding ( u0016 SWT . CTRL , ST . PASTE ) ; / / Wordstar style setKeyBinding ( SWT . DEL SWT . SHIFT , ST . CUT ) ; setKeyBinding ( SWT . INSERT SWT . CTRL , ST . COPY ) ; setKeyBinding ( SWT . INSERT SWT . SHIFT , ST . PASTE ) ; setKeyBinding ( SWT . BS SWT . SHIFT , ST . DELETE_PREVIOUS ) ; setKeyBinding ( SWT . BS , ST . DELETE_PREVIOUS ) ; setKeyBinding ( SWT . DEL , ST . DELETE_NEXT ) ; / / Miscellaneous setKeyBinding ( SWT . INSERT , ST . TOGGLE_OVERWRITE ) ; }', '/ * * * Create the bidi caret . Use the caret for the current keyboard * mode . * / void createBidiCaret ( ) { Caret caret = getCaret ( ) ; if ( caret = = null ) { caret = new Caret ( this , SWT . NULL ) ; } int direction = StyledTextBidi . getKeyboardLanguageDirection ( ) ; if ( direction = = caretDirection ) { return ; } caretDirection = direction ; if ( caretDirection = = SWT . LEFT ) { caret . setImage ( leftCaretBitmap ) ; } else if ( caretDirection = = SWT . RIGHT ) { caret . setImage ( rightCaretBitmap ) ; } }', '/ * * * Create the bitmaps to use for the caret in bidi mode . This * method only needs to be called upon widget creation and when the * font changes ( the caret bitmap height needs to match font height ) . * / void createCaretBitmaps ( ) { int caretWidth = BIDI_CARET_WIDTH ; Display display = getDisplay ( ) ; if ( caretPalette = = null ) { caretPalette = new PaletteData ( new RGB { new RGB ( 0 , 0 , 0 ) , new RGB ( 255 , 255 , 255 ) } ) ; } if ( leftCaretBitmap ! = null ) { leftCaretBitmap . dispose ( ) ; } ImageData imageData = new ImageData ( caretWidth , lineHeight , 1 , caretPalette ) ; leftCaretBitmap = new Image ( display , imageData ) ; GC gc = new GC ( leftCaretBitmap ) ; gc . setForeground ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; gc . drawLine ( 0 , 0 , 0 , lineHeight ) ; gc . drawLine ( 0 , 0 , caretWidth - 1 , 0 ) ; gc . drawLine ( 0 , 1 , 1 , 1 ) ; gc . dispose ( ) ; if ( rightCaretBitmap ! = null ) { rightCaretBitmap . dispose ( ) ; } rightCaretBitmap = new Image ( display , imageData ) ; gc = new GC ( rightCaretBitmap ) ; gc . setForeground ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; gc . drawLine ( caretWidth - 1 , 0 , caretWidth - 1 , lineHeight ) ; gc . drawLine ( 0 , 0 , caretWidth - 1 , 0 ) ; gc . drawLine ( caretWidth - 1 , 1 , 1 , 1 ) ; gc . dispose ( ) ; }', '/ * * * Moves the selected text to the clipboard . The text will be put in the * clipboard in plain text format and RTF format . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void cut ( ) { checkWidget ( ) ; if ( selection . y > selection . x ) { copy ( ) ; doDelete ( ) ; } }', '/ * * * A mouse move event has occurred . See if we should start autoscrolling . If * the move position is outside of the client area , initiate autoscrolling . * Otherwise , we ve moved back into the widget so end autoscrolling . * / void doAutoScroll ( Event event ) { Rectangle area = getClientArea ( ) ; if ( event . y > area . height ) { doAutoScroll ( SWT . DOWN ) ; } else if ( event . y < 0 ) { doAutoScroll ( SWT . UP ) ; } else if ( event . x < 0 wordWrap = = false ) { doAutoScroll ( SWT . LEFT ) ; } else if ( event . x > area . width - leftMargin - rightMargin wordWrap = = false ) { doAutoScroll ( SWT . RIGHT ) ; } else { endAutoScroll ( ) ; } }', '/ * * * Initiates autoscrolling . * < p > * * param direction SWT . UP , SWT . DOWN , SWT . RIGHT , SWT . LEFT * / void doAutoScroll ( int direction ) { Runnable timer = null ; final int TIMER_INTERVAL = 5 ; / / If we re already autoscrolling in the given direction do nothing if ( autoScrollDirection = = direction ) { return ; } final Display display = getDisplay ( ) ; / / Set a timer that will simulate the user pressing and holding / / down a cursor key ( i . e . , arrowUp , arrowDown ) . if ( direction = = SWT . UP ) { timer = new Runnable ( ) { public void run ( ) { if ( autoScrollDirection = = SWT . UP ) { doLineUp ( ) ; doSelection ( SWT . LEFT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } } } ; } else if ( direction = = SWT . DOWN ) { timer = new Runnable ( ) { public void run ( ) { if ( autoScrollDirection = = SWT . DOWN ) { doLineDown ( ) ; doSelection ( SWT . RIGHT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } } } ; } else if ( direction = = SWT . RIGHT ) { timer = new Runnable ( ) { public void run ( ) { if ( autoScrollDirection = = SWT . RIGHT ) { doColumnRight ( ) ; doSelection ( SWT . RIGHT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } } } ; } else if ( direction = = SWT . LEFT ) { timer = new Runnable ( ) { public void run ( ) { if ( autoScrollDirection = = SWT . LEFT ) { doColumnLeft ( ) ; doSelection ( SWT . LEFT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } } } ; } if ( timer ! = null ) { autoScrollDirection = direction ; display . timerExec ( TIMER_INTERVAL , timer ) ; } }', 'public void run ( ) { if ( autoScrollDirection = = SWT . UP ) { doLineUp ( ) ; doSelection ( SWT . LEFT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } }', 'public void run ( ) { if ( autoScrollDirection = = SWT . DOWN ) { doLineDown ( ) ; doSelection ( SWT . RIGHT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } }', 'public void run ( ) { if ( autoScrollDirection = = SWT . RIGHT ) { doColumnRight ( ) ; doSelection ( SWT . RIGHT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } }', 'public void run ( ) { if ( autoScrollDirection = = SWT . LEFT ) { doColumnLeft ( ) ; doSelection ( SWT . LEFT ) ; display . timerExec ( TIMER_INTERVAL , this ) ; } }', '/ * * * Deletes the previous character . Delete the selected text if any . * Move the caret in front of the deleted text . * / void doBackspace ( ) { Event event = new Event ( ) ; event . text = "" ; if ( selection . x ! = selection . y ) { event . start = selection . x ; event . end = selection . y ; sendKeyEvent ( event ) ; } else if ( caretOffset > 0 ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; if ( caretOffset = = lineOffset ) { lineOffset = content . getOffsetAtLine ( line - 1 ) ; event . start = lineOffset + content . getLine ( line - 1 ) . length ( ) ; event . end = caretOffset ; } else { event . start = caretOffset - 1 ; event . end = caretOffset ; } sendKeyEvent ( event ) ; } }', '/ * * * Moves the caret to the specified location . * < p > * * param x x location of the new caret position * param y y location of the new caret position * param select the location change is a selection operation . * include the line delimiter in the selection * / void doBidiMouseLocationChange ( int x , int y , boolean select ) { int line = ( y + verticalScrollOffset ) / lineHeight ; int lineCount = content . getLineCount ( ) ; if ( line > lineCount - 1 ) { line = lineCount - 1 ; } / / allow caret to be placed below first line only if receiver is / / not in single line mode . fixes 4820 . if ( line = = 0 ( isSingleLine ( ) = = false line > 0 ) ) { int newCaretOffset = getBidiOffsetAtMouseLocation ( x , line ) ; if ( x > = 0 content . getLineAtOffset ( newCaretOffset ) ! = content . getLineAtOffset ( caretOffset ) ) { / / Only change the caret offset when the mouse is within / / the left client area border or on a different line . / / Otherwise the autoscroll selection may be reset . / / Fixes 1GKM3XS caretOffset = newCaretOffset ; caretLine = line ; if ( select ) { doMouseSelection ( ) ; } setBidiCaretLocation ( null ) ; setBidiKeyboardLanguage ( ) ; } if ( select = = false ) { clearSelection ( true ) ; } } }', '/ * * * Moves the caret one character to the left . Do not go to the previous line . * When in a bidi locale and at a R2L character the caret is moved to the * beginning of the R2L segment ( visually right ) and then one character to the * left ( visually left because it s now in a L2R segment ) . * / void doColumnLeft ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = caretOffset - lineOffset ; if ( isBidi ( ) ) { String lineText = content . getLine ( line ) ; int lineLength = lineText . length ( ) ; GC gc = new GC ( this ) ; StyledTextBidi bidi = getStyledTextBidi ( lineText , lineOffset , gc ) ; if ( horizontalScrollOffset > 0 offsetInLine > 0 ) { if ( offsetInLine < lineLength bidi . isRightToLeft ( offsetInLine ) ) { / / advance caret logically if in R2L segment ( move visually left ) caretOffset + + ; doSelection ( SWT . RIGHT ) ; if ( caretOffset - lineOffset = = lineLength ) { / / if the line end is reached in a R2L segment , make the / / caret position ( visual left border ) visible before / / jumping to segment start showCaret ( ) ; } / / end of R2L segment reached ( visual left side ) ? if ( bidi . isRightToLeft ( caretOffset - lineOffset ) = = false ) { if ( bidi . getCaretPosition ( caretOffset - lineOffset ) < horizontalScrollOffset ) { / / make beginning of R2L segment visible before going / / left , to L2R segment important if R2L segment ends / / at visual left in order to scroll all the way to the / / left . Fixes 1GKM3XS showCaret ( ) ; } / / go to beginning of R2L segment ( visually end of next L2R / / segment ) / beginning of line caretOffset - - ; while ( caretOffset - lineOffset > 0 bidi . isRightToLeft ( caretOffset - lineOffset ) ) { caretOffset - - ; } } } else if ( offsetInLine = = lineLength bidi . getCaretPosition ( lineLength ) ! = XINSET ) { / / at logical line end in R2L segment but there s more text ( a / / L2R segment ) go to end of R2L segment ( visually left of next / / L2R segment ) / end of line caretOffset - - ; while ( caretOffset - lineOffset > 0 bidi . isRightToLeft ( caretOffset - lineOffset ) ) { caretOffset - - ; } } else if ( offsetInLine > 0 bidi . isRightToLeft ( offsetInLine ) = = false ) { / / decrease caret logically if in L2R segment ( move visually left ) caretOffset - - ; doSelection ( SWT . LEFT ) ; / / end of L2R segment reached ( visual left side of preceeding R2L / / segment ) ? if ( caretOffset - lineOffset > 0 bidi . isRightToLeft ( caretOffset - lineOffset - 1 ) ) { / / go to beginning of R2L segment ( visually start of next L2R / / segment ) / beginning of line caretOffset - - ; while ( caretOffset - lineOffset > 0 bidi . isRightToLeft ( caretOffset - lineOffset - 1 ) ) { caretOffset - - ; } } } / / if new caret position is to the left of the client area if ( bidi . getCaretPosition ( caretOffset - lineOffset ) < horizontalScrollOffset ) { / / scroll to the caret position showCaret ( ) ; } else { / / otherwise just update caret position without scrolling it into view setCaretLocation ( ) ; setBidiKeyboardLanguage ( ) ; } / / Beginning of line reached ( auto scroll finished ) but not scrolled / / completely to the left ? Fixes 1GKM193 if ( caretOffset - lineOffset = = 0 horizontalScrollOffset > 0 horizontalScrollOffset < = XINSET ) { scrollHorizontalBar ( - horizontalScrollOffset ) ; } } gc . dispose ( ) ; } else if ( offsetInLine > 0 ) { caretOffset - - ; showCaret ( ) ; } }', '/ * * * Moves the caret one character to the right . Do not go to the next line . * When in a bidi locale and at a R2L character the caret is moved to the * end of the R2L segment ( visually left ) and then one character to the * right ( visually right because it s now in a L2R segment ) . * / void doColumnRight ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = caretOffset - lineOffset ; String lineText = content . getLine ( line ) ; int lineLength = lineText . length ( ) ; if ( isBidi ( ) ) { GC gc = new GC ( this ) ; StyledTextBidi bidi = getStyledTextBidi ( lineText , lineOffset , gc ) ; if ( bidi . getTextWidth ( ) > horizontalScrollOffset + getClientArea ( ) . width offsetInLine < lineLength ) { if ( bidi . isRightToLeft ( offsetInLine ) = = false offsetInLine < lineLength ) { / / advance caret logically if in L2R segment ( move visually right ) caretOffset + + ; doSelection ( SWT . RIGHT ) ; / / end of L2R segment reached ( visual right side ) ? if ( bidi . isRightToLeft ( caretOffset - lineOffset ) ) { / / go to end of R2L segment ( visually left of next R2L segment ) / / / end of line caretOffset + + ; while ( caretOffset < lineOffset + lineLength bidi . isRightToLeft ( caretOffset - lineOffset ) ) { caretOffset + + ; } } } else if ( offsetInLine > 0 ( bidi . isRightToLeft ( offsetInLine ) bidi . getTextWidth ( ) > horizontalScrollOffset + getClientArea ( ) . width offsetInLine < lineLength ) ) { / / advance caret visually if in R2L segment or logically at line end / / but right end of line is not fully visible yet caretOffset - - ; doSelection ( SWT . LEFT ) ; offsetInLine = caretOffset - lineOffset ; / / end of R2L segment reached ( visual right side ) ? if ( offsetInLine > 0 bidi . isRightToLeft ( offsetInLine ) = = false ) { / / go to end of R2L segment ( visually left of next L2R segment ) / / / end of line caretOffset + + ; while ( caretOffset < lineOffset + lineLength bidi . isRightToLeft ( caretOffset - lineOffset ) ) { caretOffset + + ; } } } else if ( offsetInLine = = 0 bidi . getCaretPosition ( 0 ) ! = bidi . getTextWidth ( ) ) { / / at logical line start in R2L segment but there s more text ( a L2R / / segment ) go to end of R2L segment ( visually left of next L2R / / segment ) / end of line caretOffset + + ; while ( caretOffset < lineOffset + lineLength bidi . isRightToLeft ( caretOffset - lineOffset - 1 ) ) { caretOffset + + ; } } offsetInLine = caretOffset - lineOffset ; / / if new caret position is to the right of the client area if ( bidi . getCaretPosition ( offsetInLine ) > = horizontalScrollOffset ) { / / scroll to the caret position showCaret ( ) ; } else { / / otherwise just update caret position without scrolling it into view setCaretLocation ( ) ; setBidiKeyboardLanguage ( ) ; } if ( offsetInLine > 0 offsetInLine < lineLength - 1 ) { int clientAreaEnd = horizontalScrollOffset + getClientArea ( ) . width ; boolean directionChange = bidi . isRightToLeft ( offsetInLine - 1 ) = = false bidi . isRightToLeft ( offsetInLine ) ; int textWidth = bidi . getTextWidth ( ) ; / / between L2R and R2L segment and second character of R2L segment is / / left of right border and logical line end is left of right border / / but visual line end is not left of right border if ( directionChange bidi . isRightToLeft ( offsetInLine + 1 ) bidi . getCaretPosition ( offsetInLine + 1 ) < clientAreaEnd bidi . getCaretPosition ( lineLength ) < clientAreaEnd textWidth > clientAreaEnd ) { / / make visual line end visible scrollHorizontalBar ( textWidth - clientAreaEnd ) ; } } } gc . dispose ( ) ; } else if ( offsetInLine < lineLength ) { caretOffset + + ; showCaret ( ) ; } }', '/ * * * Replaces the selection with the character or insert the character at the * current caret position if no selection exists . * If a carriage return was typed replace it with the line break character * used by the widget on this platform . * < p > * * param key the character typed by the user * / void doContent ( char key ) { Event event ; if ( textLimit > 0 content . getCharCount ( ) - ( selection . y - selection . x ) > = textLimit ) { return ; } event = new Event ( ) ; event . start = selection . x ; event . end = selection . y ; / / replace a CR line break with the widget line break / / CR does not make sense on Windows since most ( all ? ) applications / / don t recognize CR as a line break . if ( key = = SWT . CR key = = SWT . LF ) { if ( isSingleLine ( ) = = false ) { event . text = getLineDelimiter ( ) ; } } / / no selection and overwrite mode is on and the typed key is not a / / tab character ( tabs are always inserted without overwriting ) ? else if ( selection . x = = selection . y overwrite = = true key ! = TAB ) { int lineIndex = content . getLineAtOffset ( event . end ) ; int lineOffset = content . getOffsetAtLine ( lineIndex ) ; String line = content . getLine ( lineIndex ) ; / / replace character at caret offset if the caret is not at the / / end of the line if ( event . end < lineOffset + line . length ( ) ) { event . end + + ; } event . text = new String ( new char { key } ) ; } else { event . text = new String ( new char { key } ) ; } if ( event . text ! = null ) { sendKeyEvent ( event ) ; } }', '/ * * * Moves the caret after the last character of the widget content . * / void doContentEnd ( ) { / / place caret at end of first line if receiver is in single / / line mode . fixes 4820 . if ( isSingleLine ( ) ) { doLineEnd ( ) ; } else { int length = content . getCharCount ( ) ; if ( caretOffset < length ) { caretOffset = length ; caretLine = content . getLineCount ( ) - 1 ; showCaret ( ) ; } } }', '/ * * * Moves the caret in front of the first character of the widget content . * / void doContentStart ( ) { if ( caretOffset > 0 ) { caretOffset = 0 ; caretLine = 0 ; showCaret ( ) ; } }', '/ * * * Moves the caret to the start of the selection if a selection exists . * Otherwise , if no selection exists move the cursor according to the * cursor selection rules . * < p > * * see doSelectionCursorPrevious * / void doCursorPrevious ( ) { if ( selection . y - selection . x > 0 ) { caretOffset = selection . x ; caretLine = content . getLineAtOffset ( caretOffset ) ; showCaret ( ) ; } else { doSelectionCursorPrevious ( ) ; } }', '/ * * * Moves the caret to the end of the selection if a selection exists . * Otherwise , if no selection exists move the cursor according to the * cursor selection rules . * < p > * * see doSelectionCursorNext * / void doCursorNext ( ) { if ( selection . y - selection . x > 0 ) { caretOffset = selection . y ; caretLine = content . getLineAtOffset ( caretOffset ) ; showCaret ( ) ; } else { doSelectionCursorNext ( ) ; } }', '/ * * * Deletes the next character . Delete the selected text if any . * / void doDelete ( ) { Event event = new Event ( ) ; event . text = "" ; if ( selection . x ! = selection . y ) { event . start = selection . x ; event . end = selection . y ; sendKeyEvent ( event ) ; } else if ( caretOffset < content . getCharCount ( ) ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int lineLength = content . getLine ( line ) . length ( ) ; if ( caretOffset = = lineOffset + lineLength ) { event . start = caretOffset ; event . end = content . getOffsetAtLine ( line + 1 ) ; } else { event . start = caretOffset ; event . end = caretOffset + 1 ; } sendKeyEvent ( event ) ; } }', '/ * * * Moves the caret one line down and to the same character offset relative * to the beginning of the line . Move the caret to the end of the new line * if the new line is shorter than the character offset . * Make the new caret position visible . * / void doLineDown ( ) { doSelectionLineDown ( ) ; showCaret ( ) ; }', '/ * * * Moves the caret to the end of the line . * / void doLineEnd ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int lineLength = content . getLine ( line ) . length ( ) ; int lineEndOffset = lineOffset + lineLength ; if ( wordWrap line ! = caretLine ) { / / caret is at the start of a visual line lineEndOffset = content . getOffsetAtLine ( caretLine ) + content . getLine ( caretLine ) . length ( ) ; } if ( caretOffset < lineEndOffset ) { caretOffset = lineEndOffset ; showCaret ( ) ; } }', '/ * * * Moves the caret to the beginning of the line . * / void doLineStart ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; if ( caretOffset > lineOffset line = = caretLine ) { caretOffset = lineOffset ; showCaret ( ) ; } }', '/ * * * Moves the caret one line up and to the same character offset relative * to the beginning of the line . Move the caret to the end of the new line * if the new line is shorter than the character offset . * / void doLineUp ( ) { int line = content . getLineAtOffset ( caretOffset ) ; if ( line ! = caretLine ) { / / caret is at end of visual line / start of next visual line in / / word wrap mode line = caretLine ; } if ( line > 0 ) { String lineText = content . getLine ( line ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = caretOffset - lineOffset ; int caretX = getXAtOffset ( lineText , line , offsetInLine ) ; caretLine = - - line ; if ( isBidi ( ) ) { caretOffset = getBidiOffsetAtMouseLocation ( caretX , line ) ; } else { caretOffset = getOffsetAtMouseLocation ( caretX , line ) ; } showCaret ( ) ; } }', '/ * * * Moves the caret to the specified location . * < p > * * param x x location of the new caret position * param y y location of the new caret position * param select the location change is a selection operation . * include the line delimiter in the selection * / void doMouseLocationChange ( int x , int y , boolean select ) { int line = ( y + verticalScrollOffset ) / lineHeight ; int lineCount = content . getLineCount ( ) ; if ( line > lineCount - 1 ) { line = lineCount - 1 ; } / / allow caret to be placed below first line only if receiver is / / not in single line mode . fixes 4820 . if ( line = = 0 ( isSingleLine ( ) = = false line > 0 ) ) { int newCaretOffset = getOffsetAtMouseLocation ( x , line ) ; if ( newCaretOffset ! = caretOffset ) { caretOffset = newCaretOffset ; caretLine = line ; if ( select ) { doMouseSelection ( ) ; } setCaretLocation ( ) ; } if ( select = = false ) { clearSelection ( true ) ; } } }', '/ * * * Updates the selection based on the caret position * / void doMouseSelection ( ) { if ( caretOffset < = selection . x ( caretOffset > selection . x caretOffset < selection . y selectionAnchor = = selection . x ) ) { doSelection ( SWT . LEFT ) ; } else { doSelection ( SWT . RIGHT ) ; } }', '/ * * * Scrolls one page down so that the last line ( truncated or whole ) * of the current page becomes the fully visible top line . * The caret is scrolled the same number of lines so that its location * relative to the top line remains the same . The exception is the end * of the text where a full page scroll is not possible . In this case * the caret is moved after the last character . * < p > * * param select whether or not to select the page * / void doPageDown ( boolean select ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineCount = content . getLineCount ( ) ; / / do nothing if in single line mode . fixes 5673 if ( line < lineCount - 1 isSingleLine ( ) = = false ) { int offsetInLine = caretOffset - content . getOffsetAtLine ( line ) ; int verticalMaximum = content . getLineCount ( ) * getVerticalIncrement ( ) ; int pageSize = getClientArea ( ) . height ; int scrollLines = Math . min ( lineCount - line - 1 , getLineCountWhole ( ) ) ; int scrollOffset ; int caretX = getXAtOffset ( content . getLine ( line ) , line , offsetInLine ) ; / / ensure that scrollLines never gets negative and at leat one / / line is scrolled . fixes bug 5602 . scrollLines = Math . max ( 1 , scrollLines ) ; line + = scrollLines ; caretLine = line ; if ( isBidi ( ) ) { caretOffset = getBidiOffsetAtMouseLocation ( caretX , line ) ; } else { caretOffset = getOffsetAtMouseLocation ( caretX , line ) ; } if ( select ) { doSelection ( SWT . RIGHT ) ; } / / scroll one page down or to the bottom scrollOffset = verticalScrollOffset + scrollLines * getVerticalIncrement ( ) ; if ( scrollOffset + pageSize > verticalMaximum ) { scrollOffset = verticalMaximum - pageSize ; } if ( scrollOffset > verticalScrollOffset ) { setVerticalScrollOffset ( scrollOffset , true ) ; } else { showCaret ( ) ; } } }', '/ * * * Moves the cursor to the end of the last fully visible line . * / void doPageEnd ( ) { / / go to end of line if in single line mode . fixes 5673 if ( isSingleLine ( ) ) { doLineEnd ( ) ; } else { int line = getBottomIndex ( ) ; int bottomCaretOffset = content . getOffsetAtLine ( line ) + content . getLine ( line ) . length ( ) ; if ( caretOffset < bottomCaretOffset ) { caretOffset = bottomCaretOffset ; caretLine = line ; showCaret ( ) ; } } }', '/ * * * Moves the cursor to the beginning of the first fully visible line . * / void doPageStart ( ) { int topCaretOffset = content . getOffsetAtLine ( topIndex ) ; if ( caretOffset > topCaretOffset ) { caretOffset = topCaretOffset ; caretLine = topIndex ; showCaret ( ) ; } }', '/ * * * Scrolls one page up so that the first line ( truncated or whole ) * of the current page becomes the fully visible last line . * The caret is scrolled the same number of lines so that its location * relative to the top line remains the same . The exception is the beginning * of the text where a full page scroll is not possible . In this case the * caret is moved in front of the first character . * / void doPageUp ( ) { int line = content . getLineAtOffset ( caretOffset ) ; if ( line > 0 ) { int offsetInLine = caretOffset - content . getOffsetAtLine ( line ) ; int scrollLines = Math . max ( 1 , Math . min ( line , getLineCountWhole ( ) ) ) ; int scrollOffset ; int caretX = getXAtOffset ( content . getLine ( line ) , line , offsetInLine ) ; line - = scrollLines ; caretLine = line ; if ( isBidi ( ) ) { caretOffset = getBidiOffsetAtMouseLocation ( caretX , line ) ; } else { caretOffset = getOffsetAtMouseLocation ( caretX , line ) ; } / / scroll one page up or to the top scrollOffset = Math . max ( 0 , verticalScrollOffset - scrollLines * getVerticalIncrement ( ) ) ; if ( scrollOffset < verticalScrollOffset ) { setVerticalScrollOffset ( scrollOffset , true ) ; } else { showCaret ( ) ; } } }', '/ * * * Updates the selection to extend to the current caret position . * / void doSelection ( int direction ) { int redrawStart = - 1 ; int redrawEnd = - 1 ; if ( selectionAnchor = = - 1 ) { selectionAnchor = selection . x ; } if ( direction = = SWT . LEFT ) { if ( caretOffset < selection . x ) { / / grow selection redrawEnd = selection . x ; redrawStart = selection . x = caretOffset ; / / check if selection has reversed direction if ( selection . y ! = selectionAnchor ) { redrawEnd = selection . y ; selection . y = selectionAnchor ; } } else / / test whether selection actually changed . Fixes 1G71EO1 if ( selectionAnchor = = selection . x caretOffset < selection . y ) { / / caret moved towards selection anchor ( left side of selection ) . / / shrink selection redrawEnd = selection . y ; redrawStart = selection . y = caretOffset ; } } else { if ( caretOffset > selection . y ) { / / grow selection redrawStart = selection . y ; redrawEnd = selection . y = caretOffset ; / / check if selection has reversed direction if ( selection . x ! = selectionAnchor ) { redrawStart = selection . x ; selection . x = selectionAnchor ; } } else / / test whether selection actually changed . Fixes 1G71EO1 if ( selectionAnchor = = selection . y caretOffset > selection . x ) { / / caret moved towards selection anchor ( right side of selection ) . / / shrink selection redrawStart = selection . x ; redrawEnd = selection . x = caretOffset ; } } if ( redrawStart ! = - 1 redrawEnd ! = - 1 ) { internalRedrawRange ( redrawStart , redrawEnd - redrawStart , true ) ; sendSelectionEvent ( ) ; } }', '/ * * * Moves the caret to the next character or to the beginning of the * next line if the cursor is at the end of a line . * / void doSelectionCursorNext ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int offsetInLine ; if ( line ! = caretLine ) { / / caret is at end of visual line / start of next visual line in / / word wrap mode line = caretLine ; } offsetInLine = caretOffset - content . getOffsetAtLine ( line ) ; if ( offsetInLine < content . getLine ( line ) . length ( ) ) { / / Remember the last direction . Always update lastCaretDirection , / / even though it s not used in non - bidi mode in order to avoid / / extra methods . lastCaretDirection = ST . COLUMN_NEXT ; caretOffset + + ; showCaret ( ) ; } else if ( line < content . getLineCount ( ) - 1 isSingleLine ( ) = = false ) { / / only go to next line if not in single line mode . fixes 5673 line + + ; caretOffset = content . getOffsetAtLine ( line ) ; caretLine = line ; showCaret ( ) ; } }', '/ * * * Moves the caret to the previous character or to the end of the previous * line if the cursor is at the beginning of a line . * / void doSelectionCursorPrevious ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset ; int offsetInLine ; if ( line ! = caretLine ) { / / caret is at end of visual line / start of next visual line in / / word wrap mode line = caretLine ; } lineOffset = content . getOffsetAtLine ( line ) ; offsetInLine = caretOffset - lineOffset ; if ( offsetInLine > 0 ) { / / Remember the last direction . Always update lastCaretDirection , / / even though it s not used in non - bidi mode in order to avoid / / extra methods . lastCaretDirection = ST . COLUMN_PREVIOUS ; caretOffset - - ; showCaret ( ) ; } else if ( line > 0 ) { line - - ; lineOffset = content . getOffsetAtLine ( line ) ; caretOffset = lineOffset + content . getLine ( line ) . length ( ) ; caretLine = line ; showCaret ( ) ; } }', '/ * * * Moves the caret one line down and to the same character offset relative * to the beginning of the line . Move the caret to the end of the new line * if the new line is shorter than the character offset . * / int doSelectionLineDown ( ) { int line = content . getLineAtOffset ( caretOffset ) ; if ( line ! = caretLine ) { / / caret is at end of visual line / start of next visual line in / / word wrap mode line = caretLine ; } / / allow line down action only if receiver is not in single line mode . / / fixes 4820 . if ( isSingleLine ( ) = = false line < content . getLineCount ( ) - 1 ) { String lineText = content . getLine ( line ) ; int offsetInLine = caretOffset - content . getOffsetAtLine ( line ) ; int caretX = getXAtOffset ( lineText , line , offsetInLine ) ; caretLine = + + line ; if ( isBidi ( ) ) { caretOffset = getBidiOffsetAtMouseLocation ( caretX , line ) ; } else { caretOffset = getOffsetAtMouseLocation ( caretX , line ) ; } } return line ; }', '/ * * * Moves the caret to the end of the next word . * / void doSelectionWordNext ( ) { int newCaretOffset = getWordEnd ( caretOffset ) ; / / don t change caret position if in single line mode and the cursor / / would be on a different line . fixes 5673 if ( isSingleLine ( ) = = false content . getLineAtOffset ( caretOffset ) = = content . getLineAtOffset ( newCaretOffset ) ) { lastCaretDirection = ST . COLUMN_NEXT ; caretOffset = newCaretOffset ; caretLine = content . getLineAtOffset ( caretOffset ) ; showCaret ( ) ; } }', '/ * * * Moves the caret to the start of the previous word . * / void doSelectionWordPrevious ( ) { lastCaretDirection = ST . COLUMN_PREVIOUS ; caretOffset = getWordStart ( caretOffset ) ; caretLine = content . getLineAtOffset ( caretOffset ) ; showCaret ( ) ; }', '/ * * * Moves the caret to the end of the next word . * If a selection exists , move the caret to the end of the selection * and remove the selection . * / void doWordNext ( ) { if ( selection . y - selection . x > 0 ) { caretOffset = selection . y ; showCaret ( ) ; } else { doSelectionWordNext ( ) ; } }', '/ * * * Moves the caret to the start of the previous word . * If a selection exists , move the caret to the start of the selection * and remove the selection . * / void doWordPrevious ( ) { if ( selection . y - selection . x > 0 ) { caretOffset = selection . x ; showCaret ( ) ; } else { doSelectionWordPrevious ( ) ; } }', '/ * * * Draws the specified rectangle . * Draw directly without invalidating the affected area when clearBackground is * false . * < p > * * param x the x position * param y the y position * param width the width * param height the height * param clearBackground true = clear the background by invalidating the requested * redraw area , false = draw the foreground directly without invalidating the * redraw area . * / void draw ( int x , int y , int width , int height , boolean clearBackground ) { if ( clearBackground ) { redraw ( x , y , width , height , true ) ; } else { int startLine = ( y + verticalScrollOffset ) / lineHeight ; int endY = y + height ; int paintYFromTopLine = ( startLine - topIndex ) * lineHeight ; int topLineOffset = ( topIndex * lineHeight - verticalScrollOffset ) ; int paintY = paintYFromTopLine + topLineOffset ; / / adjust y position for pixel based scrolling int lineCount = content . getLineCount ( ) ; Color background = getBackground ( ) ; Color foreground = getForeground ( ) ; GC gc = new GC ( this ) ; FontData fontData = gc . getFont ( ) . getFontData ( ) 0 ; if ( isSingleLine ( ) ) { lineCount = 1 ; if ( startLine > 1 ) { startLine = 1 ; } } for ( int i = startLine ; paintY < endY i < lineCount ; i + + , paintY + = lineHeight ) { String line = content . getLine ( i ) ; drawLine ( line , i , paintY , gc , background , foreground , fontData , clearBackground ) ; } gc . dispose ( ) ; } }', '/ * * * Draws a line of text at the specified location . * < p > * * param line the line to draw * param lineIndex index of the line to draw * param paintY y location to draw at * param gc GC to draw on * param widgetBackground the widget background color . * Used as the default rendering color . * param widgetForeground the widget foreground color . * Used as the default rendering color . * param currentFont the font currently set in gc . Cached for better performance . * / void drawLine ( String line , int lineIndex , int paintY , GC gc , Color widgetBackground , Color widgetForeground , FontData currentFont , boolean clearBackground ) { int lineOffset = content . getOffsetAtLine ( lineIndex ) ; int lineLength = line . length ( ) ; int selectionStart = selection . x ; int selectionEnd = selection . y ; StyleRange styles = new StyleRange 0 ; Color lineBackground = null ; StyledTextEvent event = getLineStyleData ( lineOffset , line ) ; StyledTextBidi bidi = null ; if ( event ! = null ) { styles = event . styles ; } if ( isBidi ( ) ) { setLineFont ( gc , currentFont , SWT . NORMAL ) ; bidi = getStyledTextBidi ( line , lineOffset , gc , styles ) ; } event = getLineBackgroundData ( lineOffset , line ) ; if ( event ! = null ) { lineBackground = event . lineBackground ; } if ( lineBackground = = null ) { lineBackground = widgetBackground ; } if ( clearBackground ( ( getStyle ( ) SWT . FULL_SELECTION ) = = 0 selectionStart > lineOffset selectionEnd < = lineOffset + lineLength ) ) { / / draw background if full selection is off or if line is not / / completely selected gc . setBackground ( lineBackground ) ; gc . setForeground ( lineBackground ) ; gc . fillRectangle ( 0 , paintY , getClientArea ( ) . width , lineHeight ) ; } if ( selectionStart ! = selectionEnd ) { drawLineSelectionBackground ( line , lineOffset , styles , paintY , gc , currentFont , bidi ) ; } if ( selectionStart ! = selectionEnd ( ( selectionStart > = lineOffset selectionStart < lineOffset + lineLength ) ( selectionStart < lineOffset selectionEnd > lineOffset ) ) ) { styles = getSelectionLineStyles ( styles ) ; } if ( isBidi ( ) ) { int paintX = bidiTextWidth ( line , 0 , 0 , 0 , bidi ) ; drawStyledLine ( line , lineOffset , 0 , styles , paintX , paintY , gc , lineBackground , widgetForeground , currentFont , bidi ) ; } else { drawStyledLine ( line , lineOffset , 0 , styles , 0 , paintY , gc , lineBackground , widgetForeground , currentFont , bidi ) ; } }', '/ * * * Draws the background of the line selection . * < p > * * param line the line to draw * param lineOffset offset of the first character in the line . * Relative to the start of the document . * param styles line styles * param paintY y location to draw at * param gc GC to draw on * param currentFont the font currently set in gc . Cached for * better performance . * param bidi the bidi object to use for measuring and rendering * text in bidi locales . null when not in bidi mode . * / void drawLineSelectionBackground ( String line , int lineOffset , StyleRange styles , int paintY , GC gc , FontData currentFont , StyledTextBidi bidi ) { int lineLength = line . length ( ) ; int paintX ; int selectionBackgroundWidth = - 1 ; int selectionStart = Math . max ( 0 , selection . x - lineOffset ) ; int selectionEnd = selection . y - lineOffset ; int selectionLength = selectionEnd - selectionStart ; if ( selectionEnd = = selectionStart selectionEnd < 0 selectionStart > lineLength ) { return ; } if ( bidi ! = null ) { paintX = bidiTextWidth ( line , 0 , selectionStart , 0 , bidi ) ; } else { paintX = textWidth ( line , lineOffset , 0 , selectionStart , filterLineStyles ( styles ) , 0 , gc , currentFont ) ; } / / selection extends past end of line ? if ( selectionEnd > lineLength ) { if ( ( getStyle ( ) SWT . FULL_SELECTION ) ! = 0 ) { / / use the greater of the client area width and the content / / width . fixes 1G8IYRD selectionBackgroundWidth = Math . max ( getClientArea ( ) . width , lineCache . getWidth ( ) ) ; } else { selectionLength = lineLength - selectionStart ; } } gc . setBackground ( getSelectionBackground ( ) ) ; gc . setForeground ( getSelectionForeground ( ) ) ; if ( selectionBackgroundWidth = = - 1 ) { boolean isWrappedLine = false ; if ( wordWrap ) { int lineEnd = lineOffset + lineLength ; int lineIndex = content . getLineAtOffset ( lineEnd ) ; / / is the start offset of the next line the same as the end / / offset of this line ? if ( lineIndex < content . getLineCount ( ) - 1 content . getOffsetAtLine ( lineIndex + 1 ) = = lineEnd ) { isWrappedLine = true ; } } if ( bidi ! = null ) { selectionBackgroundWidth = bidiTextWidth ( line , selectionStart , selectionLength , paintX , bidi ) ; } else { selectionBackgroundWidth = textWidth ( line , lineOffset , selectionStart , selectionLength , styles , paintX , gc , currentFont ) ; } if ( selectionBackgroundWidth < 0 ) { / / width can be negative when in R2L bidi segment paintX + = selectionBackgroundWidth ; selectionBackgroundWidth * = - 1 ; } if ( selectionEnd > lineLength isWrappedLine = = false ) { selectionEnd = selectionStart + selectionLength ; / / if the selection extends past this line , render an additional / / whitespace background at the end of the line to represent the / / selected line break if ( bidi ! = null selectionEnd > 0 bidi . isRightToLeft ( selectionEnd - 1 ) ) { int lineEndX = bidi . getTextWidth ( ) ; gc . fillRectangle ( lineEndX - horizontalScrollOffset , paintY , lineEndSpaceWidth , lineHeight ) ; } else { selectionBackgroundWidth + = lineEndSpaceWidth ; } } } / / handle empty line case if ( bidi ! = null ( paintX = = 0 ) ) { paintX = XINSET ; } / / fill the background first since expanded tabs are not / / drawn as spaces . tabs just move the draw position . gc . fillRectangle ( paintX - horizontalScrollOffset , paintY , selectionBackgroundWidth , lineHeight ) ; }', '/ * * * Draws the line at the specified location . * < p > * * param line the line to draw * param lineOffset offset of the first character in the line . * Relative to the start of the document . * param renderOffset offset of the first character that should * be rendered . Relative to the start of the line . * param styles the styles to use for rendering line segments . * May be empty but not null . * param paintX x location to draw at , not used in bidi mode * param paintY y location to draw at * param gc GC to draw on * param lineBackground line background color , used when no style * is specified for a line segment . * param lineForeground line foreground color , used when no style * is specified for a line segment . * param currentFont the font currently set in gc . Cached for better * performance . * param bidi the bidi object to use for measuring and rendering * text in bidi locales . null when not in bidi mode . * / void drawStyledLine ( String line , int lineOffset , int renderOffset , StyleRange styles , int paintX , int paintY , GC gc , Color lineBackground , Color lineForeground , FontData currentFont , StyledTextBidi bidi ) { int lineLength = line . length ( ) ; Color background = gc . getBackground ( ) ; Color foreground = gc . getForeground ( ) ; StyleRange style = null ; StyleRange filteredStyles = filterLineStyles ( styles ) ; int renderStopX = getClientArea ( ) . width + horizontalScrollOffset ; / / Always render the entire line when in a bidi locale . / / Since we render the line in logical order we may start past the end / / of the visual right border of the client area and work towards the / / left . for ( int i = 0 ; i < styles . length ( paintX < renderStopX bidi ! = null ) ; i + + ) { int styleLineLength ; int styleLineStart ; int styleLineEnd ; style = styles i ; styleLineEnd = style . start + style . length - lineOffset ; styleLineStart = Math . max ( style . start - lineOffset , 0 ) ; / / render unstyled text between the start of the current / / style range and the end of the previously rendered / / style range if ( styleLineStart > renderOffset ) { background = setLineBackground ( gc , background , lineBackground ) ; foreground = setLineForeground ( gc , foreground , lineForeground ) ; setLineFont ( gc , currentFont , SWT . NORMAL ) ; / / don t try to render more text than requested styleLineStart = Math . min ( lineLength , styleLineStart ) ; paintX = drawText ( line , renderOffset , styleLineStart - renderOffset , paintX , paintY , gc , bidi ) ; renderOffset = styleLineStart ; } else if ( styleLineEnd < = renderOffset ) { / / style ends before render start offset / / skip to the next style continue ; } if ( styleLineStart > = lineLength ) { / / there are line styles but no text for those styles / / possible when called with partial line text break ; } styleLineLength = Math . min ( styleLineEnd , lineLength ) - renderOffset ; / / set style background color if specified if ( style . background ! = null ) { background = setLineBackground ( gc , background , style . background ) ; foreground = setLineForeground ( gc , foreground , style . background ) ; if ( bidi ! = null ) { bidi . fillBackground ( renderOffset , styleLineLength , - horizontalScrollOffset , paintY , lineHeight ) ; } else { int fillWidth = textWidth ( line , lineOffset , renderOffset , styleLineLength , filteredStyles , paintX , gc , currentFont ) ; gc . fillRectangle ( paintX - horizontalScrollOffset , paintY , fillWidth , lineHeight ) ; } } else { background = setLineBackground ( gc , background , lineBackground ) ; } / / set style foreground color if specified if ( style . foreground ! = null ) { foreground = setLineForeground ( gc , foreground , style . foreground ) ; } else { foreground = setLineForeground ( gc , foreground , lineForeground ) ; } setLineFont ( gc , currentFont , style . fontStyle ) ; paintX = drawText ( line , renderOffset , styleLineLength , paintX , paintY , gc , bidi ) ; renderOffset + = styleLineLength ; } / / render unstyled text at the end of the line if ( ( style = = null renderOffset < lineLength ) ( paintX < renderStopX bidi ! = null ) ) { setLineBackground ( gc , background , lineBackground ) ; setLineForeground ( gc , foreground , lineForeground ) ; setLineFont ( gc , currentFont , SWT . NORMAL ) ; drawText ( line , renderOffset , lineLength - renderOffset , paintX , paintY , gc , bidi ) ; } }', '/ * * * Draws the text at the specified location . Expands tabs to tab * stops using the widget tab width . * < p > * * param text text to draw * param startOffset offset of the first character in text to draw * param length number of characters to draw * param paintX x location to start drawing at , not used in bidi mode * param paintY y location to draw at . Unused when draw is false * param gc GC to draw on * location where drawing would stop * param bidi the bidi object to use for measuring and rendering * text in bidi locales . null when not in bidi mode . * return x location where drawing stopped or 0 if the startOffset or * length is outside the specified text . In bidi mode this value is * the same as the paintX input parameter . * / int drawText ( String text , int startOffset , int length , int paintX , int paintY , GC gc , StyledTextBidi bidi ) { int endOffset = startOffset + length ; int textLength = text . length ( ) ; if ( startOffset < 0 startOffset > = textLength startOffset + length > textLength ) { return paintX ; } for ( int i = startOffset ; i < endOffset ; i + + ) { int tabIndex = text . indexOf ( TAB , i ) ; / / is tab not present or past the rendering range ? if ( tabIndex = = - 1 tabIndex > endOffset ) { tabIndex = endOffset ; } if ( tabIndex ! = i ) { String tabSegment = text . substring ( i , tabIndex ) ; if ( bidi ! = null ) { bidi . drawBidiText ( i , tabIndex - i , - horizontalScrollOffset , paintY ) ; } else { gc . drawString ( tabSegment , paintX - horizontalScrollOffset , paintY , true ) ; paintX + = gc . stringExtent ( tabSegment ) . x ; if ( tabIndex ! = endOffset tabWidth > 0 ) { paintX = getTabStop ( paintX ) ; } } i = tabIndex ; } else / / is tab at current rendering offset ? if ( tabWidth > 0 isBidi ( ) = = false ) { paintX = getTabStop ( paintX ) ; } } return paintX ; }', '/ * * * Ends the autoscroll process . * / void endAutoScroll ( ) { autoScrollDirection = SWT . NULL ; }', '/ * * * Filter the given style ranges based on the font style and * return the unchanged styles only if there is at least one * non - regular ( e . g . , bold ) font . * < p > * * param styles styles that may contain font styles . * return null if the styles contain only regular font styles , the * unchanged styles otherwise . * / StyleRange filterLineStyles ( StyleRange styles ) { if ( styles ! = null ) { int styleIndex = 0 ; while ( styleIndex < styles . length styles styleIndex . fontStyle = = SWT . NORMAL ) { styleIndex + + ; } if ( styleIndex = = styles . length ) { styles = null ; } } return styles ; }', '/ * * * see org . eclipse . swt . widgets . Control getBackground * / public Color getBackground ( ) { checkWidget ( ) ; if ( background = = null ) { return getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ; } return background ; }', '/ * * * Gets the BIDI coloring mode . When true the BIDI text display * algorithm is applied to segments of text that are the same * color . * * return the current coloring mode * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * < p > * deprecated use BidiSegmentListener instead . * < / p > * / public boolean getBidiColoring ( ) { checkWidget ( ) ; return bidiColoring ; }', '/ * * * Returns the offset at the specified x location in the specified line . * Also sets the caret direction so that the caret is placed correctly * depending on whether the mouse location is in a R2L or L2R segment . * < p > * * param x x location of the mouse location * param line line the mouse location is in * return the offset at the specified x location in the specified line , * relative to the beginning of the document * / int getBidiOffsetAtMouseLocation ( int x , int line ) { String lineText = content . getLine ( line ) ; int lineOffset = content . getOffsetAtLine ( line ) ; GC gc = new GC ( this ) ; StyledTextBidi bidi = getStyledTextBidi ( lineText , lineOffset , gc ) ; int values ; int offsetInLine ; x + = horizontalScrollOffset ; values = bidi . getCaretOffsetAndDirectionAtX ( x ) ; offsetInLine = values 0 ; lastCaretDirection = values 1 ; gc . dispose ( ) ; return lineOffset + offsetInLine ; }', '/ * * * Returns the index of the last fully visible line . * < p > * * return index of the last fully visible line . * / int getBottomIndex ( ) { return Math . min ( content . getLineCount ( ) - 1 , topIndex + Math . max ( 0 , getLineCountWhole ( ) - 1 ) ) ; }', '/ * * * Returns the caret position relative to the start of the text . * < p > * * return the caret position relative to the start of the text . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getCaretOffset ( ) { checkWidget ( ) ; return caretOffset ; }', '/ * * * Returns the caret offset at the given x location in the line . * The caret offset is the offset of the character where the caret will be * placed when a mouse click occurs . The caret offset will be the offset of * the character after the clicked one if the mouse click occurs at the second * half of a character . * Doesn t properly handle ligatures and other context dependent characters * unless the current locale is a bidi locale . * Ligatures are handled properly as long as they don t occur at lineXOffset . * < p > * * param line text of the line to calculate the offset in * param lineOffset offset of the first character in the line . * 0 based from the beginning of the document . * param lineXOffset x location in the line * return caret offset at the x location relative to the start of the line . * / int getCaretOffsetAtX ( String line , int lineOffset , int lineXOffset ) { int offset = 0 ; GC gc = new GC ( this ) ; FontData currentFont = gc . getFont ( ) . getFontData ( ) 0 ; StyleRange styles = null ; StyledTextEvent event = getLineStyleData ( lineOffset , line ) ; lineXOffset + = horizontalScrollOffset ; if ( event ! = null ) { styles = filterLineStyles ( event . styles ) ; } int low = - 1 ; int high = line . length ( ) ; while ( high - low > 1 ) { offset = ( high + low ) / 2 ; int x = textWidth ( line , lineOffset , 0 , offset , styles , 0 , gc , currentFont ) ; int charWidth = textWidth ( line , lineOffset , 0 , offset + 1 , styles , 0 , gc , currentFont ) - x ; if ( lineXOffset < = x + charWidth / 2 ) { high = offset ; } else { low = offset ; } } offset = high ; gc . dispose ( ) ; return offset ; }', '/ * * * Returns the caret width . * < p > * * return the caret width , 0 if caret is null . * / int getCaretWidth ( ) { Caret caret = getCaret ( ) ; if ( caret = = null ) return 0 ; return caret . getSize ( ) . x ; }', '/ * * * Returns the content implementation that is used for text storage * or null if no user defined content implementation has been set . * < p > * * return content implementation that is used for text storage or null * if no user defined content implementation has been set . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public StyledTextContent getContent ( ) { checkWidget ( ) ; return logicalContent ; }', '/ * * * Returns whether the widget implements double click mouse behavior . * < p > * * return true if double clicking a word selects the word , false if double clicks * have the same effect as regular mouse clicks * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public boolean getDoubleClickEnabled ( ) { checkWidget ( ) ; return doubleClickEnabled ; }', '/ * * * Returns whether the widget content can be edited . * < p > * * return true if content can be edited , false otherwise * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public boolean getEditable ( ) { checkWidget ( ) ; return editable ; }', '/ * * * Returns an array of text ranges that have a font style specified ( e . g . , SWT . BOLD ) . * < p > * param styles style ranges in the line * param lineOffset start index of the line , relative to the start of the document * param length of the line * return StyleRange , array of ranges with a font style specified , * null if styles parameter is null * / StyleRange getFontStyleRanges ( StyleRange styles , int lineOffset , int lineLength ) { int count = 0 ; StyleRange ranges = null ; if ( styles = = null ) { return null ; } / / figure out the number of ranges with font styles for ( int i = 0 ; i < styles . length ; i + + ) { StyleRange style = styles i ; if ( style . start - lineOffset < lineLength ) { if ( style . fontStyle = = SWT . BOLD ) { count + + ; } } } / / get the style information if ( count > 0 ) { ranges = new StyleRange count ; count = 0 ; for ( int i = 0 ; i < styles . length ; i + + ) { StyleRange style = styles i ; int styleLineStart = style . start - lineOffset ; if ( styleLineStart < lineLength ) { if ( style . fontStyle = = SWT . BOLD ) { StyleRange newStyle = new StyleRange ( ) ; newStyle . start = Math . max ( 0 , styleLineStart ) ; newStyle . length = ( Math . min ( styleLineStart + style . length , lineLength ) ) - newStyle . start ; ranges count = newStyle ; count + + ; } } } } return ranges ; }', '/ * * * see org . eclipse . swt . widgets . Control getForeground * / public Color getForeground ( ) { checkWidget ( ) ; if ( foreground = = null ) { return getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_FOREGROUND ) ; } return foreground ; }', '/ * * * Returns the horizontal scroll increment . * < p > * * return horizontal scroll increment . * / int getHorizontalIncrement ( ) { GC gc = new GC ( this ) ; int increment = gc . getFontMetrics ( ) . getAverageCharWidth ( ) ; gc . dispose ( ) ; return increment ; }', '/ * * * Returns the horizontal scroll offset relative to the start of the line . * < p > * * return horizontal scroll offset relative to the start of the line , * measured in character increments starting at 0 , if > 0 the content is scrolled * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getHorizontalIndex ( ) { checkWidget ( ) ; return horizontalScrollOffset / getHorizontalIncrement ( ) ; }', '/ * * * Returns the horizontal scroll offset relative to the start of the line . * < p > * * return the horizontal scroll offset relative to the start of the line , * measured in pixel starting at 0 , if > 0 the content is scrolled . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getHorizontalPixel ( ) { checkWidget ( ) ; return horizontalScrollOffset ; }', '/ * * * Returns the action assigned to the key . * Returns SWT . NULL if there is no action associated with the key . * < p > * * param key a key code defined in SWT . java or a character . * Optionally ORd with a state mask ( one or more of SWT . CTRL , SWT . SHIFT , SWT . ALT ) * return one of the predefined actions defined in ST . java or SWT . NULL * if there is no action associated with the key . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getKeyBinding ( int key ) { checkWidget ( ) ; Integer action = ( Integer ) keyActionMap . get ( new Integer ( key ) ) ; int intAction ; if ( action = = null ) { intAction = SWT . NULL ; } else { intAction = action . intValue ( ) ; } return intAction ; }', '/ * * * Gets the number of characters . * < p > * * return number of characters in the widget * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getCharCount ( ) { checkWidget ( ) ; return content . getCharCount ( ) ; }', '/ * * * Returns the background color of the line at the given index . * Returns null if a LineBackgroundListener has been set or if no background * color has been specified for the line . Should not be called if a * LineBackgroundListener has been set since the listener maintains the * line background colors . * < p > * * return the background color of the line at the given index . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when the index is invalid < / li > * < / ul > * / public Color getLineBackground ( int index ) { checkWidget ( ) ; Color lineBackground = null ; if ( index < 0 index > logicalContent . getLineCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( userLineBackground = = false ) { lineBackground = defaultLineStyler . getLineBackground ( index ) ; } return lineBackground ; }', '/ * * * Gets the number of text lines . * < p > * * return the number of lines in the widget * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getLineCount ( ) { checkWidget ( ) ; return getLineAtOffset ( getCharCount ( ) ) + 1 ; }', '/ * * * Returns the number of lines that are completely displayed in the * widget client area . * < p > * * return number of lines that are completely displayed in the widget * client area . * / int getLineCountWhole ( ) { int lineCount ; if ( lineHeight ! = 0 ) { lineCount = getClientArea ( ) . height / lineHeight ; } else { lineCount = 1 ; } return lineCount ; }', '/ * * * Returns the line at the specified offset in the text . * 0 < = offset < = getCharCount ( ) so that getLineAtOffset ( getCharCount ( ) ) * returns the line of the insert location . * < p > * * param offset offset relative to the start of the content . * 0 < = offset < = getCharCount ( ) * return line at the specified offset in the text * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when the offset is outside the valid range ( < 0 or > getCharCount ( ) ) < / li > * < / ul > * / public int getLineAtOffset ( int offset ) { checkWidget ( ) ; if ( offset < 0 offset > getCharCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } return logicalContent . getLineAtOffset ( offset ) ; }', '/ * * * Returns the line delimiter used for entering new lines by key down * or paste operation . * < p > * * return line delimiter used for entering new lines by key down * or paste operation . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public String getLineDelimiter ( ) { checkWidget ( ) ; return content . getLineDelimiter ( ) ; }', '/ * * * Returns the line height . * < p > * * return line height in pixel . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getLineHeight ( ) { checkWidget ( ) ; return lineHeight ; }', '/ * * * Returns a StyledTextEvent that can be used to request data such * as styles and background color for a line . * The specified line may be a visual ( wrapped ) line if in word * wrap mode . The returned object will always be for a logical * ( unwrapped ) line . * < p > * * param lineOffset offset of the line . This may be the offset of * a visual line if the widget is in word wrap mode . * param line line text . This may be the text of a visualline if * the widget is in word wrap mode . * return StyledTextEvent that can be used to request line data * for the given line . * / StyledTextEvent getLineEvent ( int lineOffset , String line ) { StyledTextEvent event = new StyledTextEvent ( logicalContent ) ; if ( wordWrap ) { / / if word wrap is on , the line offset and text may be visual ( wrapped ) int lineIndex = logicalContent . getLineAtOffset ( lineOffset ) ; event . detail = logicalContent . getOffsetAtLine ( lineIndex ) ; event . text = logicalContent . getLine ( lineIndex ) ; } else { event . detail = lineOffset ; event . text = line ; } return event ; }', '/ * * * Returns styles for the specified visual ( wrapped ) line . * < p > * * param logicalStyles the styles for a logical ( unwrapped ) line * param lineOffset offset of the visual line * param lineLength length of the visual line * return styles in the logicalStyles array that are at least * partially on the specified visual line . * / StyleRange getVisualLineStyleData ( StyleRange logicalStyles , int lineOffset , int lineLength ) { int lineEnd = lineOffset + lineLength ; int oldStyleCount = logicalStyles . length ; int newStyleCount = 0 ; for ( int i = 0 ; i < oldStyleCount ; i + + ) { StyleRange style = logicalStyles i ; if ( style . start < lineEnd style . start + style . length > lineOffset ) { newStyleCount + + ; } } if ( newStyleCount ! = oldStyleCount ) { StyleRange newStyles = new StyleRange newStyleCount ; for ( int i = 0 , j = 0 ; i < oldStyleCount ; i + + ) { StyleRange style = logicalStyles i ; if ( style . start < lineEnd style . start + style . length > lineOffset ) { newStyles j + + = logicalStyles i ; } } logicalStyles = newStyles ; } return logicalStyles ; }', '/ * * * Returns the line style data for the given line or null if there is * none . If there is a LineStyleListener but it does not set any styles , * the StyledTextEvent . styles field will be initialized to an empty * array . * < p > * * param lineOffset offset of the line start relative to the start of * the content . * param line line to get line styles for * return line style data for the given line . Styles may start before * line start and end after line end * / StyledTextEvent getLineStyleData ( int lineOffset , String line ) { if ( isListening ( LineGetStyle ) ) { StyledTextEvent event = getLineEvent ( lineOffset , line ) ; notifyListeners ( LineGetStyle , event ) ; if ( event . styles ! = null wordWrap ) { event . styles = getVisualLineStyleData ( event . styles , lineOffset , line . length ( ) ) ; } if ( event . styles = = null ) { event . styles = new StyleRange 0 ; } else if ( isBidi ( ) ) { GC gc = new GC ( this ) ; if ( StyledTextBidi . isLigated ( gc ) ) { / / Check for ligatures that are partially styled , if one is found / / automatically apply the style to the entire ligature . / / Since ligatures can t extend over multiple lines ( they aren t / / ligatures if they are separated by a line delimiter ) we can ignore / / style starts or ends that are not on the current line . / / Note that there is no need to deal with segments when checking for / / the ligatures . int lineLength = line . length ( ) ; StyledTextBidi bidi = new StyledTextBidi ( gc , line , new int { 0 , lineLength } ) ; for ( int i = 0 ; i < event . styles . length ; i + + ) { StyleRange range = event . styles i ; StyleRange newRange = null ; int relativeStart = range . start - lineOffset ; if ( relativeStart > = 0 ) { int startLigature = bidi . getLigatureStartOffset ( relativeStart ) ; if ( startLigature ! = relativeStart ) { newRange = ( StyleRange ) range . clone ( ) ; range = event . styles i = newRange ; range . start = range . start - ( relativeStart - startLigature ) ; range . length = range . length + ( relativeStart - startLigature ) ; } } int rangeEnd = range . start + range . length ; int relativeEnd = rangeEnd - lineOffset - 1 ; if ( relativeEnd < lineLength ) { int endLigature = bidi . getLigatureEndOffset ( relativeEnd ) ; if ( endLigature ! = relativeEnd ) { if ( newRange = = null ) { newRange = ( StyleRange ) range . clone ( ) ; range = event . styles i = newRange ; } range . length = range . length + ( endLigature - relativeEnd ) ; } } } } gc . dispose ( ) ; } return event ; } return null ; }', '/ * * * Returns the line background data for the given line or null if * there is none . * < p > * param lineOffset offset of the line start relative to the start * of the content . * param line line to get line background data for * return line background data for the given line . * / StyledTextEvent getLineBackgroundData ( int lineOffset , String line ) { if ( isListening ( LineGetBackground ) ) { StyledTextEvent event = getLineEvent ( lineOffset , line ) ; notifyListeners ( LineGetBackground , event ) ; return event ; } return null ; }', '/ * * * Returns a LineCache implementation . Depending on whether or not * word wrap is on this may be a line wrapping or line width * calculating implementaiton . * < p > * * param content StyledTextContent to create the LineCache on . * return a LineCache implementation * / LineCache getLineCache ( StyledTextContent content ) { LineCache lineCache ; if ( wordWrap ) { lineCache = new WordWrapCache ( this , ( WrappedContent ) content ) ; } else { lineCache = new ContentWidthCache ( this , content . getLineCount ( ) ) ; } return lineCache ; }', '/ * * * Returns the x , y location of the upper left corner of the character * bounding box at the specified offset in the text . The point is * relative to the upper left corner of the widget client area . * < p > * * param offset offset relative to the start of the content . * 0 < = offset < = getCharCount ( ) * return x , y location of the upper left corner of the character * bounding box at the specified offset in the text . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when the offset is outside the valid range ( < 0 or > getCharCount ( ) ) < / li > * < / ul > * / public Point getLocationAtOffset ( int offset ) { checkWidget ( ) ; if ( offset < 0 offset > getCharCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } int line = content . getLineAtOffset ( offset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; String lineContent = content . getLine ( line ) ; int x = getXAtOffset ( lineContent , line , offset - lineOffset ) ; int y = line * lineHeight - verticalScrollOffset ; return new Point ( x , y ) ; }', '/ * * * Returns the character offset of the first character of the given line . * < p > * * param lineIndex index of the line , 0 based relative to the first * line in the content . 0 < = lineIndex < getLineCount ( ) , except * lineIndex may always be 0 * return offset offset of the first character of the line , relative to * the beginning of the document . The first character of the document is * at offset 0 . * When there are not any lines , getOffsetAtLine ( 0 ) is a valid call that * answers 0 . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when the offset is outside the valid range ( < 0 or > getCharCount ( ) ) < / li > * < / ul > * since 2 . 0 * / public int getOffsetAtLine ( int lineIndex ) { checkWidget ( ) ; if ( lineIndex < 0 ( lineIndex > 0 lineIndex > = logicalContent . getLineCount ( ) ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } return logicalContent . getOffsetAtLine ( lineIndex ) ; }', '/ * * * Returns the offset of the character at the given location relative * to the first character in the document . * The return value reflects the character offset that the caret will * be placed at if a mouse click occurred at the specified location . * If the x coordinate of the location is beyond the center of a character * the returned offset will be behind the character . * < p > * * param point the origin of character bounding box relative to * the origin of the widget client area . * return offset of the character at the given location relative * to the first character in the document . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when point is null < / li > * < li > ERROR_INVALID_ARGUMENT when there is no character at the specified location < / li > * < / ul > * / public int getOffsetAtLocation ( Point point ) { checkWidget ( ) ; int line ; int lineOffset ; int offsetInLine ; String lineText ; if ( point = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } / / is y above first line or is x before first column ? if ( point . y + verticalScrollOffset < 0 point . x + horizontalScrollOffset < 0 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } line = ( getTopPixel ( ) + point . y ) / lineHeight ; / / does the referenced line exist ? if ( line > = content . getLineCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } lineText = content . getLine ( line ) ; lineOffset = content . getOffsetAtLine ( line ) ; offsetInLine = getOffsetAtX ( lineText , lineOffset , point . x ) ; / / is the x position within the line ? if ( offsetInLine = = - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } return lineOffset + offsetInLine ; }', '/ * * * Returns the offset at the specified x location in the specified line . * < p > * * param x x location of the mouse location * param line line the mouse location is in * return the offset at the specified x location in the specified line , * relative to the beginning of the document * / int getOffsetAtMouseLocation ( int x , int line ) { String lineText = content . getLine ( line ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = getCaretOffsetAtX ( lineText , lineOffset , x ) ; return lineOffset + offsetInLine ; }', '/ * * * Returns the offset of the character at the given x location in the line . * < p > * * param line text of the line to calculate the offset in * param lineOffset offset of the first character in the line . * 0 based from the beginning of the document . * param lineXOffset x location in the line * return offset of the character at the x location relative to the start * of the line . - 1 if the x location is past the end if the line . * / int getOffsetAtX ( String line , int lineOffset , int lineXOffset ) { GC gc = new GC ( this ) ; int offset ; lineXOffset + = horizontalScrollOffset ; if ( isBidi ( ) ) { StyledTextBidi bidi = getStyledTextBidi ( line , lineOffset , gc ) ; offset = bidi . getOffsetAtX ( lineXOffset ) ; } else { FontData currentFont = gc . getFont ( ) . getFontData ( ) 0 ; StyleRange styles = null ; StyledTextEvent event = getLineStyleData ( lineOffset , line ) ; if ( event ! = null ) { styles = filterLineStyles ( event . styles ) ; } int low = - 1 ; int high = line . length ( ) ; while ( high - low > 1 ) { offset = ( high + low ) / 2 ; / / Restrict right / high search boundary only if x is within searched text segment . / / Fixes 1GL4ZVE . if ( lineXOffset < textWidth ( line , lineOffset , 0 , offset + 1 , styles , 0 , gc , currentFont ) ) { high = offset ; } else if ( high = = line . length ( ) high - offset = = 1 ) { / / requested x location is past end of line high = - 1 ; } else { low = offset ; } } offset = high ; } gc . dispose ( ) ; return offset ; }', '/ * * * Returns the index of the last partially visible line . * * return index of the last partially visible line . * / int getPartialBottomIndex ( ) { int partialLineCount = Compatibility . ceil ( getClientArea ( ) . height , lineHeight ) ; return Math . min ( content . getLineCount ( ) , topIndex + partialLineCount ) - 1 ; }', '/ * * * Returns the content in the specified range using the platform line * delimiter to separate lines . * < p > * * param writer the TextWriter to write line text into * return the content in the specified range using the platform line * delimiter to separate lines as written by the specified TextWriter . * / String getPlatformDelimitedText ( TextWriter writer ) { int end = writer . getStart ( ) + writer . getCharCount ( ) ; int startLine = logicalContent . getLineAtOffset ( writer . getStart ( ) ) ; int endLine = logicalContent . getLineAtOffset ( end ) ; String endLineText = logicalContent . getLine ( endLine ) ; int endLineOffset = logicalContent . getOffsetAtLine ( endLine ) ; for ( int i = startLine ; i < = endLine ; i + + ) { writer . writeLine ( logicalContent . getLine ( i ) , logicalContent . getOffsetAtLine ( i ) ) ; if ( i < endLine ) { writer . writeLineDelimiter ( PlatformLineDelimiter ) ; } } if ( end > endLineOffset + endLineText . length ( ) ) { writer . writeLineDelimiter ( PlatformLineDelimiter ) ; } writer . close ( ) ; return writer . toString ( ) ; }', '/ * * * Returns the selection . * < p > * Text selections are specified in terms of caret positions . In a text * widget that contains N characters , there are N + 1 caret positions , * ranging from 0 . . N * < p > * * return start and end of the selection , x is the offset of the first * selected character , y is the offset after the last selected character * see getSelectionRange * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Point getSelection ( ) { checkWidget ( ) ; return new Point ( selection . x , selection . y ) ; }', '/ * * * Returns the selection . * < p > * * return start and length of the selection , x is the offset of the * first selected character , relative to the first character of the * widget content . y is the length of the selection . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Point getSelectionRange ( ) { checkWidget ( ) ; return new Point ( selection . x , selection . y - selection . x ) ; }', '/ * * * Merges the selection into the styles that are passed in . * The font style of existing style ranges is preserved in the selection . * < p > * param styles the existing styles that the selection should be * applied to . * return the selection style range merged with the existing styles * / / * Pseudo code for getSelectionLineStyles for each style { if ( style ends before selection start ) { add style to list } else if ( style overlaps selection start ( i . e . , starts before selection start , ends after selection start ) { change style end create new selection style with same font style starting at selection start ending at style end add selection style / / does style extend beyond selection ? if ( selection style end > selection end ) { selection style end = selection end / / preserve rest ( unselected part ) of old style style start = selection end style length = old style end - selection end add style } } else if ( style starts within selection ) { if ( no selection style created ) { create selection style with regular font style , starting at selection start , ending at style start add selection style if ( style start = = selection start ) { set selection style font to style font } } / / gap between current selection style end and new style start ? if ( style start > selection styke end selection style font style ! = NORMAL ) { create selection style with regular font style , starting at selection style end , ending at style start add selection style } if ( selection style font ! = style font ) { selection style end = style start add selection style create selection style with style font style , starting at style start , ending at style end } else { selection style end = style end } / / does style extend beyond selection ? if ( selection style end > selection end ) { selection style end = selection end / / preserve rest ( unselected part ) of old style style start = selection end style length = old style end - selection end style start = selection end add style } } else { if ( no selection style created ) { create selection style with regular font style , starting at selection start , ending at selection end add selection style } else if ( selection style end < selection end ) { if ( selection style font style ! = NORMAL ) { create selection style with regular font style , starting at selection style end , ending at selection end add selection style } else { selection style end = selection end } } add style } } if ( no selection style created ) { create selection style with regular font style , starting at selection start , ending at selection end add selection style to list } else if ( selection style end < selection end ) { if ( selection style font style ! = NORMAL ) { create selection style with regular font style , starting at selection style end , ending at selection end add selection style } else { selection style end = selection end } } * / StyleRange getSelectionLineStyles ( StyleRange styles ) { int selectionStart = selection . x ; int selectionEnd = selection . y ; Vector newStyles = new Vector ( styles . length ) ; StyleRange selectionStyle = null ; Color foreground = getSelectionForeground ( ) ; Color background = getSelectionBackground ( ) ; / / potential optimization : ignore styles if there is no bold style and the entire line is selected for ( int i = 0 ; i < styles . length ; i + + ) { StyleRange style = styles i ; int styleEnd = style . start + style . length ; if ( styleEnd < = selectionStart ) { newStyles . addElement ( style ) ; } else / / style overlaps selection start ? ( i . e . , starts before selection start , ends after selection start if ( style . start < selectionStart styleEnd > selectionStart ) { StyleRange newStyle = ( StyleRange ) style . clone ( ) ; newStyle . length - = styleEnd - selectionStart ; newStyles . addElement ( newStyle ) ; / / create new selection style with same font style starting at selection start ending at style end selectionStyle = new StyleRange ( selectionStart , styleEnd - selectionStart , foreground , background , newStyle . fontStyle ) ; newStyles . addElement ( selectionStyle ) ; / / if style extends beyond selection a new style is returned for the unselected part of the style newStyle = setSelectionStyleEnd ( selectionStyle , style ) ; if ( newStyle ! = null ) { newStyles . addElement ( newStyle ) ; } } else / / style starts within selection ? if ( style . start > = selectionStart style . start < selectionEnd ) { StyleRange newStyle ; int selectionStyleEnd ; / / no selection style created yet ? if ( selectionStyle = = null ) { / / create selection style with regular font style , starting at selection start , ending at style start selectionStyle = new StyleRange ( selectionStart , style . start - selectionStart , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; if ( style . start = = selectionStart ) { selectionStyle . fontStyle = style . fontStyle ; } } selectionStyleEnd = selectionStyle . start + selectionStyle . length ; / / gap between current selection style end and style start ? if ( style . start > selectionStyleEnd selectionStyle . fontStyle ! = SWT . NORMAL ) { / / create selection style with regular font style , starting at selection style end , ending at style start selectionStyle = new StyleRange ( selectionStyleEnd , style . start - selectionStyleEnd , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; } if ( selectionStyle . fontStyle ! = style . fontStyle ) { / / selection style end = style start selectionStyle . length = style . start - selectionStyle . start ; / / create selection style with style font style , starting at style start , ending at style end selectionStyle = new StyleRange ( style . start , style . length , foreground , background , style . fontStyle ) ; newStyles . addElement ( selectionStyle ) ; } else { / / selection style end = style end selectionStyle . length = styleEnd - selectionStyle . start ; } / / if style extends beyond selection a new style is returned for the unselected part of the style newStyle = setSelectionStyleEnd ( selectionStyle , style ) ; if ( newStyle ! = null ) { newStyles . addElement ( newStyle ) ; } } else { / / no selection style created yet ? if ( selectionStyle = = null ) { / / create selection style with regular font style , starting at selection start , ending at selection end selectionStyle = new StyleRange ( selectionStart , selectionEnd - selectionStart , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; } else / / does the current selection style end before the selection end ? if ( selectionStyle . start + selectionStyle . length < selectionEnd ) { if ( selectionStyle . fontStyle ! = SWT . NORMAL ) { int selectionStyleEnd = selectionStyle . start + selectionStyle . length ; / / create selection style with regular font style , starting at selection style end , ending at selection end selectionStyle = new StyleRange ( selectionStyleEnd , selectionEnd - selectionStyleEnd , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; } else { selectionStyle . length = selectionEnd - selectionStyle . start ; } } newStyles . addElement ( style ) ; } } if ( selectionStyle = = null ) { / / create selection style with regular font style , starting at selection start , ending at selection end selectionStyle = new StyleRange ( selectionStart , selectionEnd - selectionStart , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; } else / / does the current selection style end before the selection end ? if ( selectionStyle . start + selectionStyle . length < selectionEnd ) { if ( selectionStyle . fontStyle ! = SWT . NORMAL ) { int selectionStyleEnd = selectionStyle . start + selectionStyle . length ; / / create selection style with regular font style , starting at selection style end , ending at selection end selectionStyle = new StyleRange ( selectionStyleEnd , selectionEnd - selectionStyleEnd , foreground , background ) ; newStyles . addElement ( selectionStyle ) ; } else { selectionStyle . length = selectionEnd - selectionStyle . start ; } } styles = new StyleRange newStyles . size ( ) ; newStyles . copyInto ( styles ) ; return styles ; }', '/ * * * Returns the background color to be used for rendering selected text . * < p > * * return background color to be used for rendering selected text * / Color getSelectionBackground ( ) { return getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_SELECTION ) ; }', '/ * * * Gets the number of selected characters . * < p > * * return the number of selected characters . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getSelectionCount ( ) { checkWidget ( ) ; return getSelectionRange ( ) . y ; }', '/ * * * Returns the foreground color to be used for rendering selected text . * < p > * * return foreground color to be used for rendering selected text * / Color getSelectionForeground ( ) { return getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_SELECTION_TEXT ) ; }', '/ * * * Returns the selected text . * < p > * * return selected text , or an empty String if there is no selection . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public String getSelectionText ( ) { checkWidget ( ) ; return content . getTextRange ( selection . x , selection . y - selection . x ) ; }', '/ * * * Returns the text segments that should be treated as if they * had a different direction than the surrounding text . * < p > * * param lineOffset offset of the first character in the line . * 0 based from the beginning of the document . * param line text of the line to specify bidi segments for * return text segments that should be treated as if they had a * different direction than the surrounding text . Only the start * index of a segment is specified , relative to the start of the * line . Always starts with 0 and ends with the line length . * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT - if the segment indices returned * by the listener do not start with 0 , are not in ascending order , * exceed the line length or have duplicates < / li > * < / ul > * / int getBidiSegments ( int lineOffset , String line ) { if ( isListening ( LineGetSegments ) = = false ) { return getBidiSegmentsCompatibility ( line , lineOffset ) ; } StyledTextEvent event = getLineEvent ( lineOffset , line ) ; int lineLength = line . length ( ) ; int segments ; notifyListeners ( LineGetSegments , event ) ; if ( event . segments = = null event . segments . length = = 0 ) { segments = new int { 0 , lineLength } ; } else { int segmentCount = event . segments . length ; / / test segment index consistency if ( event . segments 0 ! = 0 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } for ( int i = 1 ; i < segmentCount ; i + + ) { if ( event . segments i < = event . segments i - 1 event . segments i > lineLength ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } } / / ensure that last segment index is line end offset if ( event . segments segmentCount - 1 ! = lineLength ) { segments = new int segmentCount + 1 ; System . arraycopy ( event . segments , 0 , segments , 0 , segmentCount ) ; segments segmentCount = lineLength ; } else { segments = event . segments ; } } return segments ; }', '/ * * * see getBidiSegments * Supports deprecated setBidiColoring API . Remove when API is removed . * / int getBidiSegmentsCompatibility ( String line , int lineOffset ) { StyledTextEvent event ; StyleRange styles = new StyleRange 0 ; int lineLength = line . length ( ) ; if ( bidiColoring = = false ) { return new int { 0 , lineLength } ; } event = getLineStyleData ( lineOffset , line ) ; if ( event ! = null ) { styles = event . styles ; } if ( styles . length = = 0 ) { return new int { 0 , lineLength } ; } int k = 0 , count = 1 ; while ( k < styles . length styles k . start = = 0 styles k . length = = lineLength ) { k + + ; } int offsets = new int ( styles . length - k ) * 2 + 2 ; for ( int i = k ; i < styles . length ; i + + ) { StyleRange style = styles i ; int styleLineStart = Math . max ( style . start - lineOffset , 0 ) ; int styleLineEnd = Math . max ( style . start + style . length - lineOffset , styleLineStart ) ; styleLineEnd = Math . min ( styleLineEnd , line . length ( ) ) ; if ( i > 0 count > 1 ( ( styleLineStart > = offsets count - 2 styleLineStart < = offsets count - 1 ) ( styleLineEnd > = offsets count - 2 styleLineEnd < = offsets count - 1 ) ) style . similarTo ( styles i - 1 ) ) { offsets count - 2 = Math . min ( offsets count - 2 , styleLineStart ) ; offsets count - 1 = Math . max ( offsets count - 1 , styleLineEnd ) ; } else { if ( styleLineStart > offsets count - 1 ) { offsets count = styleLineStart ; count + + ; } offsets count = styleLineEnd ; count + + ; } } / / add offset for last non - colored segment in line , if any if ( lineLength > offsets count - 1 ) { offsets count = lineLength ; count + + ; } if ( count = = offsets . length ) { return offsets ; } int result = new int count ; System . arraycopy ( offsets , 0 , result , 0 , count ) ; return result ; }', '/ * * * Returns the style range at the given offset . * Returns null if a LineStyleListener has been set or if a style is not set * for the offset . * Should not be called if a LineStyleListener has been set since the * listener maintains the styles . * < p > * * param offset the offset to return the style for . * 0 < = offset < getCharCount ( ) must be true . * return a StyleRange with start = = offset and length = = 1 , indicating * the style at the given offset . null if a LineStyleListener has been set * or if a style is not set for the given offset . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when the offset is invalid < / li > * < / ul > * / public StyleRange getStyleRangeAtOffset ( int offset ) { checkWidget ( ) ; if ( offset < 0 offset > = getCharCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( userLineStyle = = false ) { return defaultLineStyler . getStyleRangeAtOffset ( offset ) ; } return null ; }', '/ * * * Returns the styles . * Returns an empty array if a LineStyleListener has been set . * Should not be called if a LineStyleListener has been set since the * listener maintains the styles . * < p > * * return the styles or null if a LineStyleListener has been set . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public StyleRange getStyleRanges ( ) { checkWidget ( ) ; StyleRange styles ; if ( userLineStyle = = false ) { styles = defaultLineStyler . getStyleRanges ( ) ; } else { styles = new StyleRange 0 ; } return styles ; }', '/ * * * Returns a StyledTextBidi object for the specified line . * < p > * * param lineText the line that the StyledTextBidi object should * work on . * param lineOffset offset of the beginning of the line , relative * to the beginning of the document * param gc GC to use when creating a new StyledTextBidi object . * return a StyledTextBidi object for the specified line . * / StyledTextBidi getStyledTextBidi ( String lineText , int lineOffset , GC gc ) { return getStyledTextBidi ( lineText , lineOffset , gc , null ) ; }', '/ * * * Returns a StyledTextBidi object for the specified line . * < p > * * param lineText the line that the StyledTextBidi object should * work on . * param lineOffset offset of the beginning of the line , relative * to the beginning of the document * param gc GC to use when creating a new StyledTextBidi object . * param styles StyleRanges to use when creating a new StyledTextBidi * object . * return a StyledTextBidi object for the specified line . * / StyledTextBidi getStyledTextBidi ( String lineText , int lineOffset , GC gc , StyleRange styles ) { StyleRange fontStyles = null ; if ( styles = = null ) { StyledTextEvent event = getLineStyleData ( lineOffset , lineText ) ; if ( event ! = null ) { fontStyles = getFontStyleRanges ( event . styles , lineOffset , lineText . length ( ) ) ; } } else { fontStyles = getFontStyleRanges ( styles , lineOffset , lineText . length ( ) ) ; } return new StyledTextBidi ( gc , tabWidth , lineText , fontStyles , boldFont , getBidiSegments ( lineOffset , lineText ) ) ; }', '/ * * * Returns the tab width measured in characters . * * return tab width measured in characters * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getTabs ( ) { checkWidget ( ) ; return tabLength ; }', '/ * * * Returns the next tab stop for the specified x location . * < p > * * param x the x location in front of a tab * return the next tab stop for the specified x location . * / int getTabStop ( int x ) { int spaceWidth = tabWidth / tabLength ; / / make sure tab stop is at least one space width apart / / from the last character . fixes 4844 . if ( tabWidth - x tabWidth < spaceWidth ) { x + = tabWidth ; } x + = tabWidth ; x - = x tabWidth ; return x ; }', '/ * * * Returns a copy of the widget content . * < p > * * return copy of the widget content * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public String getText ( ) { checkWidget ( ) ; return content . getTextRange ( 0 , getCharCount ( ) ) ; }', '/ * * * Returns the widget content between the two offsets . * < p > * * param start offset of the first character in the returned String * param end offset of the last character in the returned String * return widget content starting at start and ending at end * see getTextRange ( int , int ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when start and / or end are outside the widget content < / li > * < / ul > * / public String getText ( int start , int end ) { checkWidget ( ) ; int contentLength = getCharCount ( ) ; if ( start < 0 start > = contentLength end < 0 end > = contentLength start > end ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } return content . getTextRange ( start , end - start + 1 ) ; }', '/ * * * Returns the widget content starting at start for length characters . * < p > * * param start offset of the first character in the returned String * param length number of characters to return * return widget content starting at start and extending length characters . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when start and / or length are outside the widget content < / li > * < / ul > * / public String getTextRange ( int start , int length ) { checkWidget ( ) ; int contentLength = getCharCount ( ) ; int end = start + length ; if ( start > end start < 0 end > contentLength ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } return content . getTextRange ( start , length ) ; }', '/ * * * Gets the text limit . The text limit specifies the amount of text that the user * can type into the widget . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getTextLimit ( ) { checkWidget ( ) ; return textLimit ; }', '/ * * * Gets the top index . The top index is the index of the fully visible line that * is currently at the top of the widget . The top index changes when the widget * is scrolled . Indexing is zero based . * < p > * * return the index of the top line * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getTopIndex ( ) { checkWidget ( ) ; int logicalTopIndex = topIndex ; if ( wordWrap ) { int visualLineOffset = content . getOffsetAtLine ( topIndex ) ; logicalTopIndex = logicalContent . getLineAtOffset ( visualLineOffset ) ; } return logicalTopIndex ; }', '/ * * * Gets the top pixel . The top pixel is the pixel position of the line that is * currently at the top of the widget . The text widget can be scrolled by pixels * by dragging the scroll thumb so that a partial line may be displayed at the top * the widget . The top pixel changes when the widget is scrolled . The top pixel * does not include the widget trimming . * < p > * * return pixel position of the top line * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getTopPixel ( ) { checkWidget ( ) ; return verticalScrollOffset ; }', '/ * * * Returns the vertical scroll increment . * < p > * * return vertical scroll increment . * / int getVerticalIncrement ( ) { return lineHeight ; }', '/ * * * Returns the offset of the character after the word at the specified * offset . * < p > * There are two classes of words formed by a sequence of characters : * < ul > * < li > from 0 - 9 and A - z ( ASCII 48 - 57 and 65 - 122 ) * < li > every other character except line breaks * < / ul > * < / p > * < p > * Space characters ( ASCII 20 ) are special as they are treated as * part of the word leading up to the space character . Line breaks are * treated as one word . * < / p > * / int getWordEnd ( int offset ) { int line = logicalContent . getLineAtOffset ( offset ) ; int lineOffset = logicalContent . getOffsetAtLine ( line ) ; String lineText = logicalContent . getLine ( line ) ; int lineLength = lineText . length ( ) ; if ( offset > = getCharCount ( ) ) { return offset ; } if ( offset = = lineOffset + lineLength ) { line + + ; offset = logicalContent . getOffsetAtLine ( line ) ; } else { offset - = lineOffset ; char ch = lineText . charAt ( offset ) ; boolean letterOrDigit = Compatibility . isLetterOrDigit ( ch ) ; while ( offset < lineLength - 1 Compatibility . isLetterOrDigit ( ch ) = = letterOrDigit ) { offset + + ; ch = lineText . charAt ( offset ) ; } / / skip over trailing whitespace while ( offset < lineLength - 1 Compatibility . isSpaceChar ( ch ) ) { offset + + ; ch = lineText . charAt ( offset ) ; } if ( offset = = lineLength - 1 ( Compatibility . isLetterOrDigit ( ch ) = = letterOrDigit Compatibility . isSpaceChar ( ch ) ) ) { offset + + ; } offset + = lineOffset ; } return offset ; }', '/ * * * Returns the offset of the character after the word at the specified * offset . * < p > * There are two classes of words formed by a sequence of characters : * < ul > * < li > from 0 - 9 and A - z ( ASCII 48 - 57 and 65 - 122 ) * < li > every other character except line breaks * < / ul > * < / p > * < p > * Spaces are ignored and do not represent a word . Line breaks are treated * as one word . * < / p > * / int getWordEndNoSpaces ( int offset ) { int line = logicalContent . getLineAtOffset ( offset ) ; int lineOffset = logicalContent . getOffsetAtLine ( line ) ; String lineText = logicalContent . getLine ( line ) ; int lineLength = lineText . length ( ) ; if ( offset > = getCharCount ( ) ) { return offset ; } if ( offset = = lineOffset + lineLength ) { line + + ; offset = logicalContent . getOffsetAtLine ( line ) ; } else { offset - = lineOffset ; char ch = lineText . charAt ( offset ) ; boolean letterOrDigit = Compatibility . isLetterOrDigit ( ch ) ; while ( offset < lineLength - 1 Compatibility . isLetterOrDigit ( ch ) = = letterOrDigit Compatibility . isSpaceChar ( ch ) = = false ) { offset + + ; ch = lineText . charAt ( offset ) ; } if ( offset = = lineLength - 1 Compatibility . isLetterOrDigit ( ch ) = = letterOrDigit Compatibility . isSpaceChar ( ch ) = = false ) { offset + + ; } offset + = lineOffset ; } return offset ; }', '/ * * * Returns the start offset of the word at the specified offset . * There are two classes of words formed by a sequence of characters : * < p > * < ul > * < li > from 0 - 9 and A - z ( ASCII 48 - 57 and 65 - 122 ) * < li > every other character except line breaks * < / ul > * < / p > * < p > * Space characters ( ASCII 20 ) are special as they are treated as * part of the word leading up to the space character . Line breaks are treated * as one word . * < / p > * / int getWordStart ( int offset ) { int line = logicalContent . getLineAtOffset ( offset ) ; int lineOffset = logicalContent . getOffsetAtLine ( line ) ; String lineText = logicalContent . getLine ( line ) ; if ( offset < = 0 ) { return offset ; } if ( offset = = lineOffset ) { line - - ; lineText = logicalContent . getLine ( line ) ; offset = logicalContent . getOffsetAtLine ( line ) + lineText . length ( ) ; } else { char ch ; boolean letterOrDigit ; offset - = lineOffset ; / / skip over trailing whitespace do { offset - - ; ch = lineText . charAt ( offset ) ; } while ( offset > 0 Compatibility . isSpaceChar ( ch ) ) ; letterOrDigit = Compatibility . isLetterOrDigit ( ch ) ; while ( offset > 0 Compatibility . isLetterOrDigit ( ch ) = = letterOrDigit Compatibility . isSpaceChar ( ch ) = = false ) { offset - - ; ch = lineText . charAt ( offset ) ; } if ( offset > 0 Compatibility . isLetterOrDigit ( ch ) ! = letterOrDigit ) { offset + + ; } offset + = lineOffset ; } return offset ; }', '/ * * * Returns whether the widget wraps lines . * < p > * * return true if widget wraps lines , false otherwise * since 2 . 0 * / public boolean getWordWrap ( ) { checkWidget ( ) ; return wordWrap ; }', '/ * * * Returns the x location of the character at the give offset in the line . * < b > NOTE : < / b > Does not return correct values for true italic fonts ( vs . slanted fonts ) . * < p > * * return x location of the character at the given offset in the line . * / int getXAtOffset ( String line , int lineIndex , int lineOffset ) { int x ; if ( lineOffset = = 0 isBidi ( ) = = false ) { x = 0 ; } else { GC gc = new GC ( this ) ; x = textWidth ( line , lineIndex , Math . min ( line . length ( ) , lineOffset ) , gc ) ; gc . dispose ( ) ; if ( lineOffset > line . length ( ) ) { / / offset is not on the line . return an x location one character / / after the line to indicate the line delimiter . x + = lineEndSpaceWidth ; } } return x - horizontalScrollOffset ; }', '/ * * * Inserts a string . The old selection is replaced with the new text . * < p > * * param string the string * see replaceTextRange ( int , int , String ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public void insert ( String string ) { checkWidget ( ) ; if ( string = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } Point sel = getSelectionRange ( ) ; replaceTextRange ( sel . x , sel . y , string ) ; }', '/ * * * Creates content change listeners and set the default content model . * / void installDefaultContent ( ) { textChangeListener = new TextChangeListener ( ) { public void textChanging ( TextChangingEvent event ) { handleTextChanging ( event ) ; } public void textChanged ( TextChangedEvent event ) { handleTextChanged ( event ) ; } public void textSet ( TextChangedEvent event ) { handleTextSet ( event ) ; } } ; logicalContent = content = new DefaultContent ( ) ; content . addTextChangeListener ( textChangeListener ) ; }', 'public void textChanging ( TextChangingEvent event ) { handleTextChanging ( event ) ; }', 'public void textChanged ( TextChangedEvent event ) { handleTextChanged ( event ) ; }', 'public void textSet ( TextChangedEvent event ) { handleTextSet ( event ) ; }', '/ * * * Creates a default line style listener . * Used to store line background colors and styles . * Removed when the user sets a LineStyleListener . * < p > * * see addLineStyleListener * / void installDefaultLineStyler ( ) { defaultLineStyler = new DefaultLineStyler ( logicalContent ) ; StyledTextListener typedListener = new StyledTextListener ( defaultLineStyler ) ; if ( userLineStyle = = false ) { addListener ( LineGetStyle , typedListener ) ; } if ( userLineBackground = = false ) { addListener ( LineGetBackground , typedListener ) ; } }', '/ * * * Adds event listeners * / void installListeners ( ) { ScrollBar verticalBar = getVerticalBar ( ) ; ScrollBar horizontalBar = getHorizontalBar ( ) ; addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { handleDispose ( ) ; } } ) ; addListener ( SWT . KeyDown , new Listener ( ) { public void handleEvent ( Event event ) { handleKeyDown ( event ) ; } } ) ; addListener ( SWT . MouseDown , new Listener ( ) { public void handleEvent ( Event event ) { handleMouseDown ( event ) ; } } ) ; addListener ( SWT . MouseUp , new Listener ( ) { public void handleEvent ( Event event ) { handleMouseUp ( event ) ; } } ) ; addListener ( SWT . MouseDoubleClick , new Listener ( ) { public void handleEvent ( Event event ) { handleMouseDoubleClick ( event ) ; } } ) ; addListener ( SWT . MouseMove , new Listener ( ) { public void handleEvent ( Event event ) { handleMouseMove ( event ) ; } } ) ; addListener ( SWT . Paint , new Listener ( ) { public void handleEvent ( Event event ) { handlePaint ( event ) ; } } ) ; addListener ( SWT . Resize , new Listener ( ) { public void handleEvent ( Event event ) { handleResize ( event ) ; } } ) ; addListener ( SWT . Traverse , new Listener ( ) { public void handleEvent ( Event event ) { handleTraverse ( event ) ; } } ) ; if ( verticalBar ! = null ) { verticalBar . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { handleVerticalScroll ( event ) ; } } ) ; } if ( horizontalBar ! = null ) { horizontalBar . addListener ( SWT . Selection , new Listener ( ) { public void handleEvent ( Event event ) { handleHorizontalScroll ( event ) ; } } ) ; } }', 'public void handleEvent ( Event event ) { handleDispose ( ) ; }', 'public void handleEvent ( Event event ) { handleKeyDown ( event ) ; }', 'public void handleEvent ( Event event ) { handleMouseDown ( event ) ; }', 'public void handleEvent ( Event event ) { handleMouseUp ( event ) ; }', 'public void handleEvent ( Event event ) { handleMouseDoubleClick ( event ) ; }', 'public void handleEvent ( Event event ) { handleMouseMove ( event ) ; }', 'public void handleEvent ( Event event ) { handlePaint ( event ) ; }', 'public void handleEvent ( Event event ) { handleResize ( event ) ; }', 'public void handleEvent ( Event event ) { handleTraverse ( event ) ; }', 'public void handleEvent ( Event event ) { handleVerticalScroll ( event ) ; }', 'public void handleEvent ( Event event ) { handleHorizontalScroll ( event ) ; }', '/ * * * Used by WordWrapCache to bypass StyledText . redraw which does * an unwanted cache reset . * / void internalRedraw ( ) { super . redraw ( ) ; }', '/ * * * Redraws the specified text range . * < p > * * param start offset of the first character to redraw * param length number of characters to redraw * param clearBackground true if the background should be cleared as * part of the redraw operation . If true , the entire redraw area will * be cleared before anything is redrawn . The redraw operation will * be faster and smoother if clearBackground is set to false . Whether * or not the flag can be set to false depends on the type of change * that has taken place . If font styles or background colors for the * redraw area have changed , clearBackground should be set to true . If * only foreground colors have changed for the redraw area , * clearBackground can be set to false . * / void internalRedrawRange ( int start , int length , boolean clearBackground ) { int end = start + length ; int firstLine = content . getLineAtOffset ( start ) ; int lastLine = content . getLineAtOffset ( end ) ; int offsetInFirstLine ; int partialBottomIndex = getPartialBottomIndex ( ) ; int partialTopIndex = verticalScrollOffset / lineHeight ; / / do nothing if redraw range is completely invisible if ( firstLine > partialBottomIndex lastLine < partialTopIndex ) { return ; } / / only redraw visible lines if ( partialTopIndex > firstLine ) { firstLine = partialTopIndex ; offsetInFirstLine = 0 ; } else { offsetInFirstLine = start - content . getOffsetAtLine ( firstLine ) ; } if ( partialBottomIndex + 1 < lastLine ) { lastLine = partialBottomIndex + 1 ; / / + 1 to redraw whole bottom line , including line break end = content . getOffsetAtLine ( lastLine ) ; } / / redraw first and last lines if ( isBidi ( ) ) { redrawBidiLines ( firstLine , offsetInFirstLine , lastLine , end , clearBackground ) ; } else { redrawLines ( firstLine , offsetInFirstLine , lastLine , end , clearBackground ) ; } / / redraw entire center lines if redraw range includes more than two lines if ( lastLine - firstLine > 1 ) { Rectangle clientArea = getClientArea ( ) ; int redrawStopY = lastLine * lineHeight - verticalScrollOffset ; int redrawY = ( firstLine + 1 ) * lineHeight - verticalScrollOffset ; draw ( 0 , redrawY , clientArea . width , redrawStopY - redrawY , clearBackground ) ; } }', '/ * * * Returns the widget text with style information encoded using RTF format * specification version 1 . 5 . * * return the widget text with style information encoded using RTF format * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / String getRtf ( ) { checkWidget ( ) ; RTFWriter rtfWriter = new RTFWriter ( 0 , getCharCount ( ) ) ; return getPlatformDelimitedText ( rtfWriter ) ; }', '/ * * * Frees resources . * / void handleDispose ( ) { clipboard . dispose ( ) ; ibeamCursor . dispose ( ) ; if ( boldFont ! = null ) { boldFont . dispose ( ) ; } if ( content ! = null ) { content . removeTextChangeListener ( textChangeListener ) ; } if ( leftCaretBitmap ! = null ) { leftCaretBitmap . dispose ( ) ; } if ( rightCaretBitmap ! = null ) { rightCaretBitmap . dispose ( ) ; } if ( isBidi ( ) ) { StyledTextBidi . removeLanguageListener ( this ) ; } }', '/ * * * Updates the caret location and selection if mouse button 1 has been * pressed . * / void handleMouseDoubleClick ( Event event ) { if ( event . button ! = 1 doubleClickEnabled = = false ) { return ; } event . x - = leftMargin ; event . y - = topMargin ; mouseDoubleClick = true ; caretOffset = getWordEndNoSpaces ( caretOffset ) ; resetSelection ( ) ; caretOffset = getWordStart ( caretOffset ) ; caretLine = content . getLineAtOffset ( caretOffset ) ; showCaret ( ) ; doMouseSelection ( ) ; }', '/ * * * Updates the caret location and selection if mouse button 1 has been * pressed . * / void handleMouseDown ( Event event ) { boolean select = ( event . stateMask SWT . SHIFT ) ! = 0 ; if ( event . button ! = 1 ) { return ; } mouseDoubleClick = false ; event . x - = leftMargin ; event . y - = topMargin ; if ( isBidi ( ) ) { doBidiMouseLocationChange ( event . x , event . y , select ) ; } else { doMouseLocationChange ( event . x , event . y , select ) ; } }', '/ * * * Autoscrolling ends when the mouse button is released . * / void handleMouseUp ( Event event ) { event . x - = leftMargin ; event . y - = topMargin ; endAutoScroll ( ) ; }', '/ * * * Updates the caret location and selection if mouse button 1 is pressed * during the mouse move . * / void handleMouseMove ( Event event ) { if ( mouseDoubleClick = = true ( event . stateMask SWT . BUTTON1 ) = = 0 ) { return ; } event . x - = leftMargin ; event . y - = topMargin ; if ( isBidi ( ) ) { doBidiMouseLocationChange ( event . x , event . y , true ) ; } else { doMouseLocationChange ( event . x , event . y , true ) ; } doAutoScroll ( event ) ; }', '/ * * * Scrolls the widget horizontally . * / void handleHorizontalScroll ( Event event ) { int scrollPixel = getHorizontalBar ( ) . getSelection ( ) - horizontalScrollOffset ; scrollHorizontal ( scrollPixel ) ; }', '/ * * * If a VerifyKey listener exists , verify that the key that was entered * should be processed . * < p > * * param event keyboard event * / void handleKeyDown ( Event event ) { Event verifyEvent = new Event ( ) ; verifyEvent . character = event . character ; verifyEvent . keyCode = event . keyCode ; verifyEvent . stateMask = event . stateMask ; verifyEvent . doit = true ; notifyListeners ( VerifyKey , verifyEvent ) ; if ( verifyEvent . doit = = true ) { handleKey ( event ) ; } }', '/ * * * If an action has been registered for the key stroke execute the action . * Otherwise , if a character has been entered treat it as new content . * < p > * * param event keyboard event * / void handleKey ( Event event ) { int action ; if ( event . keyCode ! = 0 ) { action = getKeyBinding ( event . keyCode event . stateMask ) ; } else { action = getKeyBinding ( event . character event . stateMask ) ; } if ( action = = SWT . NULL ) { / / ignore anything below SPACE and ignore DEL if ( event . character > 31 event . character ! = SWT . DEL event . character = = SWT . CR event . character = = SWT . LF event . character = = TAB ) { doContent ( event . character ) ; } } else { invokeAction ( action ) ; } }', '/ * * * Renders the invalidated area specified in the paint event . * < p > * * param event paint event * / void handlePaint ( Event event ) { int startLine = ( event . y - topMargin + verticalScrollOffset ) / lineHeight ; int paintYFromTopLine = ( startLine - topIndex ) * lineHeight ; int topLineOffset = topIndex * lineHeight - verticalScrollOffset ; int startY = paintYFromTopLine + topLineOffset ; / / adjust y position for pixel based scrolling int renderHeight = event . y + event . height - startY ; int paintY = 0 ; int lineCount = content . getLineCount ( ) ; Rectangle clientArea = getClientArea ( ) ; Color background = getBackground ( ) ; Color foreground = getForeground ( ) ; Image lineBuffer ; GC lineGC ; Font font ; FontData fontData ; / / Check if there is work to do . clientArea . width should never be 0 / / if we receive a paint event but we never want to try and create / / an Image with 0 width . if ( clientArea . width = = 0 event . height = = 0 ) { return ; } if ( isSingleLine ( ) ) { lineCount = 1 ; if ( startLine > 1 ) { startLine = 1 ; } } font = event . gc . getFont ( ) ; fontData = font . getFontData ( ) 0 ; if ( clientArea . width > ( leftMargin + rightMargin ) ) { lineBuffer = new Image ( getDisplay ( ) , clientArea . width - leftMargin - rightMargin , renderHeight ) ; lineGC = new GC ( lineBuffer ) ; lineGC . setFont ( font ) ; lineGC . setForeground ( foreground ) ; lineGC . setBackground ( background ) ; for ( int i = startLine ; paintY < renderHeight i < lineCount ; i + + , paintY + = lineHeight ) { String line = content . getLine ( i ) ; drawLine ( line , i , paintY , lineGC , background , foreground , fontData , true ) ; } if ( paintY < renderHeight ) { lineGC . setBackground ( background ) ; lineGC . setForeground ( background ) ; lineGC . fillRectangle ( 0 , paintY , clientArea . width , renderHeight - paintY ) ; } event . gc . drawImage ( lineBuffer , leftMargin , topMargin + startY ) ; lineGC . dispose ( ) ; lineBuffer . dispose ( ) ; } / / clear the margin background event . gc . setBackground ( background ) ; event . gc . fillRectangle ( 0 , 0 , clientArea . width , topMargin ) ; event . gc . fillRectangle ( 0 , 0 , leftMargin , renderHeight ) ; event . gc . fillRectangle ( 0 , clientArea . height - bottomMargin , clientArea . width , bottomMargin ) ; event . gc . fillRectangle ( clientArea . width - rightMargin , 0 , rightMargin , renderHeight ) ; }', '/ * * * Recalculates the scroll bars . Rewraps all lines when in word * wrap mode . * < p > * * param event resize event * / void handleResize ( Event event ) { int oldHeight = clientAreaHeight ; int oldWidth = clientAreaWidth ; clientAreaHeight = getClientArea ( ) . height ; clientAreaWidth = getClientArea ( ) . width ; if ( wordWrap ) { if ( oldWidth ! = clientAreaWidth ) { wordWrapResize ( oldWidth ) ; } } else if ( clientAreaHeight > oldHeight ) { int lineCount = content . getLineCount ( ) ; int oldBottomIndex = topIndex + oldHeight / lineHeight ; int newItemCount = Compatibility . ceil ( clientAreaHeight - oldHeight , lineHeight ) ; oldBottomIndex = Math . min ( oldBottomIndex , lineCount ) ; newItemCount = Math . min ( newItemCount , lineCount - oldBottomIndex ) ; lineCache . calculate ( oldBottomIndex , newItemCount ) ; } setScrollBars ( ) ; claimBottomFreeSpace ( ) ; claimRightFreeSpace ( ) ; }', '/ * * * Updates the caret position and selection and the scroll bars to reflect * the content change . * < p > * / void handleTextChanged ( TextChangedEvent event ) { lineCache . textChanged ( lastTextChangeStart , lastTextChangeNewLineCount , lastTextChangeReplaceLineCount , lastTextChangeNewCharCount , lastTextChangeReplaceCharCount ) ; setScrollBars ( ) ; / / update selection / caret location after styles have been changed . / / otherwise any text measuring could be incorrect / / / / also , this needs to be done after all scrolling . Otherwise , / / selection redraw would be flushed during scroll which is wrong . / / in some cases new text would be drawn in scroll source area even / / though the intent is to scroll it . / / fixes 1GB93QT updateSelection ( lastTextChangeStart , lastTextChangeReplaceCharCount , lastTextChangeNewCharCount ) ; if ( lastTextChangeReplaceLineCount > 0 ) { / / Only check for unused space when lines are deleted . / / Fixes 1GFL4LY / / Scroll up so that empty lines below last text line are used . / / Fixes 1GEYJM0 claimBottomFreeSpace ( ) ; } if ( lastTextChangeReplaceCharCount > 0 ) { / / fixes bug 8273 claimRightFreeSpace ( ) ; } }', '/ * * * Updates the screen to reflect a pending content change . * < p > * * param event . start the start offset of the change * param event . newText text that is going to be inserted or empty String * if no text will be inserted * param event . replaceCharCount length of text that is going to be replaced * param event . newCharCount length of text that is going to be inserted * param event . replaceLineCount number of lines that are going to be replaced * param event . newLineCount number of new lines that are going to be inserted * / void handleTextChanging ( TextChangingEvent event ) { int firstLine ; int textChangeY ; boolean isMultiLineChange = event . replaceLineCount > 0 event . newLineCount > 0 ; if ( event . replaceCharCount < 0 ) { event . start + = event . replaceCharCount ; event . replaceCharCount * = - 1 ; } lastTextChangeStart = event . start ; lastTextChangeNewLineCount = event . newLineCount ; lastTextChangeNewCharCount = event . newCharCount ; lastTextChangeReplaceLineCount = event . replaceLineCount ; lastTextChangeReplaceCharCount = event . replaceCharCount ; firstLine = content . getLineAtOffset ( event . start ) ; textChangeY = firstLine * lineHeight - verticalScrollOffset ; if ( isMultiLineChange ) { redrawMultiLineChange ( textChangeY , event . newLineCount , event . replaceLineCount ) ; } else { super . redraw ( leftMargin , textChangeY + topMargin , getClientArea ( ) . width - leftMargin - rightMargin , lineHeight , true ) ; } / / notify default line styler about text change if ( defaultLineStyler ! = null ) { defaultLineStyler . textChanging ( event ) ; } }', '/ * * * Called when the widget content is set programatically , overwriting * the old content . Resets the caret position , selection and scroll offsets . * Recalculates the content width and scroll bars . Redraws the widget . * < p > * * param event text change event . * / void handleTextSet ( TextChangedEvent event ) { reset ( ) ; }', '/ * * * Called when a traversal key is pressed . * Allow tab next traversal to occur when the widget is in single * line mode . * When in multi line mode we want to prevent the tab traversal * and receive the tab key event instead . * < p > * * param event the event * / void handleTraverse ( Event event ) { if ( isSingleLine ( ) event . detail = = SWT . TRAVERSE_TAB_NEXT ) { event . doit = true ; } }', '/ * * * Scrolls the widget vertically . * / void handleVerticalScroll ( Event event ) { setVerticalScrollOffset ( getVerticalBar ( ) . getSelection ( ) , false ) ; }', '/ * * * Initializes the fonts used to render font styles . * Presently only regular and bold fonts are supported . * / void initializeFonts ( ) { FontData fontData ; GC gc = new GC ( this ) ; lineEndSpaceWidth = gc . stringExtent ( " " ) . x ; regularFont = getFont ( ) ; fontData = regularFont . getFontData ( ) 0 ; fontData . setStyle ( fontData . getStyle ( ) SWT . BOLD ) ; boldFont = new Font ( getDisplay ( ) , fontData ) ; gc . dispose ( ) ; }', '/ * * * Executes the action . * < p > * * param action one of the actions defined in ST . java * / public void invokeAction ( int action ) { checkWidget ( ) ; switch ( action ) { / / Navigation case ST . LINE_UP : doLineUp ( ) ; clearSelection ( true ) ; break ; case ST . LINE_DOWN : doLineDown ( ) ; clearSelection ( true ) ; break ; case ST . LINE_START : doLineStart ( ) ; clearSelection ( true ) ; break ; case ST . LINE_END : doLineEnd ( ) ; clearSelection ( true ) ; break ; case ST . COLUMN_PREVIOUS : doCursorPrevious ( ) ; clearSelection ( true ) ; break ; case ST . COLUMN_NEXT : doCursorNext ( ) ; clearSelection ( true ) ; break ; case ST . PAGE_UP : doPageUp ( ) ; clearSelection ( true ) ; break ; case ST . PAGE_DOWN : doPageDown ( false ) ; clearSelection ( true ) ; break ; case ST . WORD_PREVIOUS : doWordPrevious ( ) ; clearSelection ( true ) ; break ; case ST . WORD_NEXT : doWordNext ( ) ; clearSelection ( true ) ; break ; case ST . TEXT_START : doContentStart ( ) ; clearSelection ( true ) ; break ; case ST . TEXT_END : doContentEnd ( ) ; clearSelection ( true ) ; break ; case ST . WINDOW_START : doPageStart ( ) ; clearSelection ( true ) ; break ; case ST . WINDOW_END : doPageEnd ( ) ; clearSelection ( true ) ; break ; / / Selection case ST . SELECT_LINE_UP : doLineUp ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_LINE_DOWN : doSelectionLineDown ( ) ; / / select first and then scroll to reduce flash when key / / repeat scrolls lots of lines doSelection ( SWT . RIGHT ) ; showCaret ( ) ; break ; case ST . SELECT_LINE_START : doLineStart ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_LINE_END : doLineEnd ( ) ; doSelection ( SWT . RIGHT ) ; break ; case ST . SELECT_COLUMN_PREVIOUS : doSelectionCursorPrevious ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_COLUMN_NEXT : doSelectionCursorNext ( ) ; doSelection ( SWT . RIGHT ) ; break ; case ST . SELECT_PAGE_UP : doPageUp ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_PAGE_DOWN : doPageDown ( true ) ; break ; case ST . SELECT_WORD_PREVIOUS : doSelectionWordPrevious ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_WORD_NEXT : doSelectionWordNext ( ) ; doSelection ( SWT . RIGHT ) ; break ; case ST . SELECT_TEXT_START : doContentStart ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_TEXT_END : doContentEnd ( ) ; doSelection ( SWT . RIGHT ) ; break ; case ST . SELECT_WINDOW_START : doPageStart ( ) ; doSelection ( SWT . LEFT ) ; break ; case ST . SELECT_WINDOW_END : doPageEnd ( ) ; doSelection ( SWT . RIGHT ) ; break ; / / Modification case ST . CUT : cut ( ) ; break ; case ST . COPY : copy ( ) ; break ; case ST . PASTE : paste ( ) ; break ; case ST . DELETE_PREVIOUS : doBackspace ( ) ; break ; case ST . DELETE_NEXT : doDelete ( ) ; break ; / / Miscellaneous case ST . TOGGLE_OVERWRITE : overwrite = ! overwrite ; / / toggle insert / overwrite mode break ; } }', '/ * * * Temporary until SWT provides this * / boolean isBidi ( ) { return isBidi ; }', '/ * * * Returns whether the given offset is inside a multi byte line delimiter . * Example : * "Line1 r n" isLineDelimiter ( 5 ) = = false but isLineDelimiter ( 6 ) = = true * * return true if the given offset is inside a multi byte line delimiter . * false if the given offset is before or after a line delimiter . * / boolean isLineDelimiter ( int offset ) { int line = content . getLineAtOffset ( offset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = offset - lineOffset ; / / offsetInLine will be greater than line length if the line / / delimiter is longer than one character and the offset is set / / in between parts of the line delimiter . return offsetInLine > content . getLine ( line ) . length ( ) ; }', '/ * * * Returns whether the widget can have only one line . * < p > * * return true if widget can have only one line , false if widget can have * multiple lines * / boolean isSingleLine ( ) { return ( getStyle ( ) SWT . SINGLE ) ! = 0 ; }', '/ * * * Returns whether the font style in the given style range is changing * from SWT . NORMAL to SWT . BOLD or vice versa . * < p > * * param range StyleRange to compare current font style with . * param start offset of the first font style to compare * param end offset behind the last font style to compare * return true if the font style is changing in the given style range , * false if the font style is not changing in the given style range . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / boolean isStyleChanging ( StyleRange range , int start , int end ) { checkWidget ( ) ; StyleRange styles = defaultLineStyler . getStyleRangesFor ( start , end - start ) ; if ( styles = = null ) { return ( range . fontStyle ! = SWT . NORMAL ) ; } for ( int i = 0 ; i < styles . length ; i + + ) { StyleRange newStyle = styles i ; if ( newStyle . fontStyle ! = range . fontStyle ) { return true ; } } return false ; }', '/ * * * Sends the specified verify event , replace / insert text as defined by * the event and send a modify event . * < p > * * param event the text change event . * < ul > * < li > event . start - the replace start offset < / li > * < li > event . end - the replace end offset < / li > * < li > event . text - the new text < / li > * < / ul > * param updateCaret whether or not he caret should be set behind * the new text * / void modifyContent ( Event event , boolean updateCaret ) { event . doit = true ; notifyListeners ( SWT . Verify , event ) ; if ( event . doit ) { StyledTextEvent styledTextEvent = null ; int replacedLength = event . end - event . start ; boolean isBackspace = event . start < caretOffset ; boolean isDirectionBoundary = false ; if ( updateCaret isBidi ( ) ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineStartOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = caretOffset - lineStartOffset ; String lineText = content . getLine ( line ) ; GC gc = new GC ( this ) ; StyledTextBidi bidi = new StyledTextBidi ( gc , lineText , getBidiSegments ( lineStartOffset , lineText ) ) ; isDirectionBoundary = ( offsetInLine > 0 bidi . isRightToLeft ( offsetInLine ) ! = bidi . isRightToLeft ( offsetInLine - 1 ) ) ; gc . dispose ( ) ; } if ( isListening ( ExtendedModify ) ) { styledTextEvent = new StyledTextEvent ( logicalContent ) ; styledTextEvent . start = event . start ; styledTextEvent . end = event . start + event . text . length ( ) ; styledTextEvent . text = content . getTextRange ( event . start , replacedLength ) ; } content . replaceTextRange ( event . start , replacedLength , event . text ) ; / / set the caret position prior to sending the modify event . / / fixes 1GBB8NJ if ( updateCaret ) { / / always update the caret location . fixes 1G8FODP internalSetSelection ( event . start + event . text . length ( ) , 0 , true ) ; if ( isBidi ( ) ) { / / Update the caret direction so that the caret moves to the / / typed / deleted character . Fixes 1GJLQ16 . if ( replacedLength = = 1 event . text . length ( ) = = 0 ) { updateBidiDirection ( isBackspace , isDirectionBoundary ) ; } else { lastCaretDirection = ST . COLUMN_NEXT ; } showBidiCaret ( ) ; } else { showCaret ( ) ; } } notifyListeners ( SWT . Modify , event ) ; if ( isListening ( ExtendedModify ) ) { notifyListeners ( ExtendedModify , styledTextEvent ) ; } } }', '/ * * * Replaces the selection with the clipboard text or insert the text at * the current caret offset if there is no selection . * If the widget has the SWT . SINGLE style and the clipboard text contains * more than one line , only the first line without line delimiters is * inserted in the widget . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void paste ( ) { checkWidget ( ) ; TextTransfer transfer = TextTransfer . getInstance ( ) ; String text ; text = ( String ) clipboard . getContents ( transfer ) ; if ( text ! = null text . length ( ) > 0 ) { Event event = new Event ( ) ; event . start = selection . x ; event . end = selection . y ; event . text = getModelDelimitedText ( text ) ; sendKeyEvent ( event ) ; } }', '/ * * * Prints the widget s text to the default printer . * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void print ( ) { checkWidget ( ) ; StyledTextPrinter . print ( this ) ; }', '/ * * * Returns a runnable that will print the widget s text * to the specified printer . * < p > * The runnable may be run in a non - UI thread . * < / p > * * param printer the printer to print to * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public Runnable print ( Printer printer ) { checkWidget ( ) ; if ( printer = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } return new StyledTextPrinter ( this , printer ) ; }', '/ * * * Causes the entire bounds of the receiver to be marked * as needing to be redrawn . The next time a paint request * is processed , the control will be completely painted . * < p > * Recalculates the content width for all lines in the bounds . * When a < code > LineStyleListener < / code > is used a redraw call * is the only notification to the widget that styles have changed * and that the content width may have changed . * < / p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * * see Control update * / public void redraw ( ) { int itemCount ; super . redraw ( ) ; itemCount = getPartialBottomIndex ( ) - topIndex + 1 ; lineCache . redrawReset ( topIndex , itemCount , true ) ; lineCache . calculate ( topIndex , itemCount ) ; setHorizontalScrollBar ( ) ; }', '/ * * * Causes the rectangular area of the receiver specified by * the arguments to be marked as needing to be redrawn . * The next time a paint request is processed , that area of * the receiver will be painted . If the < code > all < / code > flag * is < code > true < / code > , any children of the receiver which * intersect with the specified area will also paint their * intersecting areas . If the < code > all < / code > flag is * < code > false < / code > , the children will not be painted . * < p > * Marks the content width of all lines in the specified rectangle * as unknown . Recalculates the content width of all visible lines . * When a < code > LineStyleListener < / code > is used a redraw call * is the only notification to the widget that styles have changed * and that the content width may have changed . * < / p > * * param x the x coordinate of the area to draw * param y the y coordinate of the area to draw * param width the width of the area to draw * param height the height of the area to draw * param all < code > true < / code > if children should redraw , and < code > false < / code > otherwise * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * * see Control update * / public void redraw ( int x , int y , int width , int height , boolean all ) { x + = leftMargin ; y + = topMargin ; super . redraw ( x , y , width , height , all ) ; if ( height > 0 ) { int lineCount = content . getLineCount ( ) ; int startLine = ( getTopPixel ( ) + y ) / lineHeight ; int endLine = startLine + Compatibility . ceil ( height , lineHeight ) ; int itemCount ; / / reset all lines in the redraw rectangle startLine = Math . min ( startLine , lineCount ) ; itemCount = Math . min ( endLine , lineCount ) - startLine ; lineCache . reset ( startLine , itemCount , true ) ; / / only calculate the visible lines itemCount = getPartialBottomIndex ( ) - topIndex + 1 ; lineCache . calculate ( topIndex , itemCount ) ; setHorizontalScrollBar ( ) ; } }', '/ * * * Redraws a text range in the specified lines * < p > * * param firstLine first line to redraw at the specified offset * param offsetInFirstLine offset in firstLine to start redrawing * param lastLine last line to redraw * param endOffset offset in the last where redrawing should stop * param clearBackground true = clear the background by invalidating * the requested redraw area , false = draw the foreground directly * without invalidating the redraw area . * / void redrawBidiLines ( int firstLine , int offsetInFirstLine , int lastLine , int endOffset , boolean clearBackground ) { int lineCount = lastLine - firstLine + 1 ; int redrawY = firstLine * lineHeight - verticalScrollOffset ; int firstLineOffset = content . getOffsetAtLine ( firstLine ) ; String line = content . getLine ( firstLine ) ; GC gc = new GC ( this ) ; StyledTextBidi bidi = getStyledTextBidi ( line , firstLineOffset , gc ) ; bidi . redrawRange ( this , offsetInFirstLine , Math . min ( line . length ( ) , endOffset ) - offsetInFirstLine , - horizontalScrollOffset , redrawY , lineHeight ) ; / / redraw line break marker ( either space or full client area width ) / / if redraw range extends over more than one line and background should be redrawn if ( lastLine > firstLine clearBackground ) { int lineBreakWidth ; int lineBreakStartX = bidi . getTextWidth ( ) ; / / handle empty line case if ( lineBreakStartX = = 0 ) { lineBreakStartX = XINSET ; } lineBreakStartX = lineBreakStartX - horizontalScrollOffset ; if ( ( getStyle ( ) SWT . FULL_SELECTION ) ! = 0 ) { lineBreakWidth = getClientArea ( ) . width - lineBreakStartX ; } else { lineBreakWidth = lineEndSpaceWidth ; } draw ( lineBreakStartX , redrawY , lineBreakWidth , lineHeight , clearBackground ) ; } / / redraw last line if more than one line needs redrawing if ( lineCount > 1 ) { int lastLineOffset = content . getOffsetAtLine ( lastLine ) ; int offsetInLastLine = endOffset - lastLineOffset ; / / no redraw necessary if redraw offset is 0 if ( offsetInLastLine > 0 ) { line = content . getLine ( lastLine ) ; redrawY = lastLine * lineHeight - verticalScrollOffset ; bidi = getStyledTextBidi ( line , lastLineOffset , gc ) ; bidi . redrawRange ( this , 0 , offsetInLastLine , - horizontalScrollOffset , redrawY , lineHeight ) ; } } gc . dispose ( ) ; }', '/ * * * Redraws a text range in the specified lines * < p > * * param firstLine first line to redraw at the specified offset * param offsetInFirstLine offset in firstLine to start redrawing * param lastLine last line to redraw * param endOffset offset in the last where redrawing should stop * param clearBackground true = clear the background by invalidating * the requested redraw area , false = draw the foreground directly * without invalidating the redraw area . * / void redrawLines ( int firstLine , int offsetInFirstLine , int lastLine , int endOffset , boolean clearBackground ) { String line = content . getLine ( firstLine ) ; int lineCount = lastLine - firstLine + 1 ; int redrawX = getXAtOffset ( line , firstLine , offsetInFirstLine ) ; int redrawStopX ; int redrawY = firstLine * lineHeight - verticalScrollOffset ; int firstLineOffset = content . getOffsetAtLine ( firstLine ) ; / / calculate redraw stop location if ( ( getStyle ( ) SWT . FULL_SELECTION ) ! = 0 lastLine > firstLine ) { redrawStopX = getClientArea ( ) . width ; } else { redrawStopX = getXAtOffset ( line , firstLine , endOffset - firstLineOffset ) ; } draw ( redrawX , redrawY , redrawStopX - redrawX , lineHeight , clearBackground ) ; / / redraw last line if more than one line needs redrawing if ( lineCount > 1 ) { int offsetInLastLine = endOffset - content . getOffsetAtLine ( lastLine ) ; / / no redraw necessary if redraw offset is 0 if ( offsetInLastLine > 0 ) { line = content . getLine ( lastLine ) ; redrawStopX = getXAtOffset ( line , lastLine , offsetInLastLine ) ; redrawY = lastLine * lineHeight - verticalScrollOffset ; draw ( 0 , redrawY , redrawStopX , lineHeight , clearBackground ) ; } } }', '/ * * * Fixes the widget to display a text change . * Bit blitting and redrawing is done as necessary . * < p > * * param y y location of the text change * param newLineCount number of new lines . * param replacedLineCount number of replaced lines . * / void redrawMultiLineChange ( int y , int newLineCount , int replacedLineCount ) { Rectangle clientArea = getClientArea ( ) ; int lineCount = newLineCount - replacedLineCount ; int sourceY ; int destinationY ; if ( lineCount > 0 ) { sourceY = Math . max ( 0 , y + lineHeight ) ; destinationY = sourceY + lineCount * lineHeight ; } else { destinationY = Math . max ( 0 , y + lineHeight ) ; sourceY = destinationY - lineCount * lineHeight ; } scroll ( 0 , destinationY , / / destination x , y 0 , sourceY , / / source x , y clientArea . width , clientArea . height , true ) ; / / Always redrawing causes the bottom line to flash when a line is / / deleted . This is because SWT merges the paint area of the scroll / / with the paint area of the redraw call below . / / To prevent this we could call update after the scroll . However , / / adding update can cause even more flash if the client does other / / redraw / update calls ( ie . for syntax highlighting ) . / / We could also redraw only when a line has been added or when / / contents has been added to a line . This would require getting / / line index info from the content and is not worth the trouble / / ( the flash is only on the bottom line and minor ) . / / Specifying the NO_MERGE_PAINTS style bit prevents the merged / / redraw but could cause flash / slowness elsewhere . if ( y + lineHeight > 0 y < = clientArea . height ) { / / redraw first changed line in case a line was split / joined super . redraw ( 0 , y , clientArea . width , lineHeight , true ) ; } if ( newLineCount > 0 ) { int redrawStartY = y + lineHeight ; int redrawHeight = newLineCount * lineHeight ; if ( redrawStartY + redrawHeight > 0 redrawStartY < = clientArea . height ) { / / display new text super . redraw ( 0 , redrawStartY , clientArea . width , redrawHeight , true ) ; } } }', '/ * * * Redraws the specified text range . * < p > * * param start offset of the first character to redraw * param length number of characters to redraw * param clearBackground true if the background should be cleared as * part of the redraw operation . If true , the entire redraw area will * be cleared before anything is redrawn . The redraw operation will * be faster and smoother if clearBackground is set to false . Whether * or not the flag can be set to false depends on the type of change * that has taken place . If font styles or background colors for the * redraw area have changed , clearBackground should be set to true . If * only foreground colors have changed for the redraw area , * clearBackground can be set to false . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when start and / or end are outside the widget content < / li > * < / ul > * / public void redrawRange ( int start , int length , boolean clearBackground ) { checkWidget ( ) ; int end = start + length ; int contentLength = content . getCharCount ( ) ; int firstLine ; int lastLine ; if ( start > end start < 0 end > contentLength ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } firstLine = content . getLineAtOffset ( start ) ; lastLine = content . getLineAtOffset ( end ) ; / / reset all affected lines but let the redraw recalculate only / / those that are visible . lineCache . reset ( firstLine , lastLine - firstLine + 1 , true ) ; internalRedrawRange ( start , length , clearBackground ) ; }', '/ * * * Removes the specified bidirectional segment listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * since 2 . 0 * / public void removeBidiSegmentListener ( BidiSegmentListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( LineGetSegments , listener ) ; }', '/ * * * Removes the specified extended modify listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeExtendedModifyListener ( ExtendedModifyListener extendedModifyListener ) { checkWidget ( ) ; if ( extendedModifyListener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( ExtendedModify , extendedModifyListener ) ; }', '/ * * * Removes the specified line background listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeLineBackgroundListener ( LineBackgroundListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( LineGetBackground , listener ) ; / / use default line styler if last user line styler was removed . if ( isListening ( LineGetBackground ) = = false userLineBackground ) { StyledTextListener typedListener = new StyledTextListener ( defaultLineStyler ) ; addListener ( LineGetBackground , typedListener ) ; userLineBackground = false ; } }', '/ * * * Removes the specified line style listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeLineStyleListener ( LineStyleListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( LineGetStyle , listener ) ; / / use default line styler if last user line styler was removed . Fixes 1G7B1X2 if ( isListening ( LineGetStyle ) = = false userLineStyle ) { StyledTextListener typedListener = new StyledTextListener ( defaultLineStyler ) ; addListener ( LineGetStyle , typedListener ) ; userLineStyle = false ; } }', '/ * * * Removes the specified modify listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeModifyListener ( ModifyListener modifyListener ) { checkWidget ( ) ; if ( modifyListener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( SWT . Modify , modifyListener ) ; }', '/ * * * Removes the specified selection listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( SWT . Selection , listener ) ; }', '/ * * * Removes the specified verify listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeVerifyListener ( VerifyListener verifyListener ) { checkWidget ( ) ; if ( verifyListener = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( SWT . Verify , verifyListener ) ; }', '/ * * * Removes the specified key verify listener . * < p > * * param listener the listener * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeVerifyKeyListener ( VerifyKeyListener listener ) { if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( VerifyKey , listener ) ; }', '/ * * * Replaces the given text range with new text . * If the widget has the SWT . SINGLE style and "text" contains more than * one line , only the first line is rendered but the text is stored * unchanged . A subsequent call to getText will return the same text * that was set . Note that only a single line of text should be set when * the SWT . SINGLE style is used . * < p > * < b > NOTE : < / b > During the replace operation the current selection is * changed as follows : * < ul > * < li > selection before replaced text : selection unchanged * < li > selection after replaced text : adjust the selection so that same text * remains selected * < li > selection intersects replaced text : selection is cleared and caret * is placed after inserted text * < / ul > * < / p > * * param start offset of first character to replace * param length number of characters to replace . Use 0 to insert text * param text new text . May be empty to delete text . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when either start or end is outside the valid range ( 0 < = offset < = getCharCount ( ) ) < / li > * < li > ERROR_INVALID_ARGUMENT when either start or end is inside a multi byte line delimiter . * Splitting a line delimiter for example by inserting text in between the CR and LF and deleting part of a line delimiter is not supported < / li > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public void replaceTextRange ( int start , int length , String text ) { checkWidget ( ) ; int contentLength = getCharCount ( ) ; int end = start + length ; Event event = new Event ( ) ; if ( start > end start < 0 end > contentLength ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } if ( text = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } event . start = start ; event . end = end ; event . text = text ; modifyContent ( event , false ) ; }', '/ * * * Resets the caret position , selection and scroll offsets . Recalculate * the content width and scroll bars . Redraw the widget . * / void reset ( ) { ScrollBar verticalBar = getVerticalBar ( ) ; ScrollBar horizontalBar = getHorizontalBar ( ) ; caretOffset = 0 ; caretLine = 0 ; topIndex = 0 ; verticalScrollOffset = 0 ; horizontalScrollOffset = 0 ; resetSelection ( ) ; / / discard any styles that may have been set by creating a / / new default line styler if ( defaultLineStyler ! = null ) { removeLineBackgroundListener ( defaultLineStyler ) ; removeLineStyleListener ( defaultLineStyler ) ; installDefaultLineStyler ( ) ; } calculateContentWidth ( ) ; if ( verticalBar ! = null ) { verticalBar . setSelection ( 0 ) ; } if ( horizontalBar ! = null ) { horizontalBar . setSelection ( 0 ) ; } setScrollBars ( ) ; setCaretLocation ( ) ; super . redraw ( ) ; }', '/ * * * Resets the selection . * / void resetSelection ( ) { selection . x = selection . y = caretOffset ; selectionAnchor = - 1 ; }', '/ * * * Scrolls the widget horizontally . * < p > * * param pixels number of pixels to scroll , > 0 = scroll left , * < 0 scroll right * / void scrollHorizontal ( int pixels ) { Rectangle clientArea ; if ( pixels = = 0 ) { return ; } clientArea = getClientArea ( ) ; if ( pixels > 0 ) { int sourceX = leftMargin + pixels ; int scrollWidth = clientArea . width - sourceX - rightMargin ; int scrollHeight = clientArea . height - topMargin - bottomMargin ; scroll ( leftMargin , topMargin , / / destination x , y sourceX , topMargin , / / source x , y scrollWidth , scrollHeight , true ) ; if ( sourceX > scrollWidth ) { / / redraw from end of scrolled area to beginning of scroll / / invalidated area super . redraw ( leftMargin + scrollWidth , topMargin , pixels - scrollWidth , scrollHeight , true ) ; } } else { int destinationX = leftMargin - pixels ; int scrollWidth = clientArea . width - destinationX - rightMargin ; int scrollHeight = clientArea . height - topMargin - bottomMargin ; scroll ( destinationX , topMargin , / / destination x , y leftMargin , topMargin , / / source x , y scrollWidth , scrollHeight , true ) ; if ( destinationX > scrollWidth ) { / / redraw from end of scroll invalidated area to scroll / / destination super . redraw ( leftMargin + scrollWidth , topMargin , - pixels - scrollWidth , scrollHeight , true ) ; } } horizontalScrollOffset + = pixels ; setCaretLocation ( ) ; }', '/ * * * Scrolls the widget horizontally and adjust the horizontal scroll * bar to reflect the new horizontal offset . . * < p > * * param pixels number of pixels to scroll , > 0 = scroll left , * < 0 scroll right * / void scrollHorizontalBar ( int pixels ) { if ( pixels = = 0 ) { return ; } ScrollBar horizontalBar = getHorizontalBar ( ) ; if ( horizontalBar ! = null ) { horizontalBar . setSelection ( horizontalScrollOffset + pixels ) ; } scrollHorizontal ( pixels ) ; }', '/ * * * Selects all the text . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void selectAll ( ) { checkWidget ( ) ; setSelection ( new Point ( 0 , Math . max ( getCharCount ( ) , 0 ) ) ) ; }', '/ * * * Replaces / inserts text as defined by the event . * < p > * * param event the text change event . * < ul > * < li > event . start - the replace start offset < / li > * < li > event . end - the replace end offset < / li > * < li > event . text - the new text < / li > * < / ul > * / void sendKeyEvent ( Event event ) { if ( editable = = false ) { return ; } modifyContent ( event , true ) ; }', '/ * * * Sends the specified selection event . * / void sendSelectionEvent ( ) { Event event = new Event ( ) ; event . x = selection . x ; event . y = selection . y ; notifyListeners ( SWT . Selection , event ) ; }', '/ * * * Sets whether the widget wraps lines . * This overrides the creation style bit SWT . WRAP . * < p > * * param wrap true = widget wraps lines , false = widget does not wrap lines * since 2 . 0 * / public void setWordWrap ( boolean wrap ) { checkWidget ( ) ; if ( wrap ! = wordWrap ) { ScrollBar horizontalBar = getHorizontalBar ( ) ; wordWrap = wrap ; if ( wordWrap ) { logicalContent = content ; content = new WrappedContent ( this , logicalContent ) ; } else { content = logicalContent ; } calculateContentWidth ( ) ; caretLine = content . getLineAtOffset ( caretOffset ) ; horizontalScrollOffset = 0 ; if ( horizontalBar ! = null ) { horizontalBar . setVisible ( ! wordWrap ) ; } setScrollBars ( ) ; setCaretLocation ( ) ; super . redraw ( ) ; } }', '/ * * * Sets the caret location and scrolls the caret offset into view . * / void showBidiCaret ( ) { int line = content . getLineAtOffset ( caretOffset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = caretOffset - lineOffset ; String lineText = content . getLine ( line ) ; int xAtOffset = 0 ; boolean scrolled = false ; GC gc = new GC ( this ) ; StyledTextBidi bidi = getStyledTextBidi ( lineText , lineOffset , gc ) ; / / getXAtOffset , inlined for better performance xAtOffset = bidiTextWidth ( lineText , 0 , offsetInLine , 0 , bidi ) ; if ( offsetInLine > lineText . length ( ) ) { / / offset is not on the line . return an x location one character / / after the line to indicate the line delimiter . xAtOffset + = lineEndSpaceWidth ; } xAtOffset - = horizontalScrollOffset ; / / scrolled = showLocation ( xAtOffset , line ) ; if ( scrolled = = false ) { setBidiCaretLocation ( bidi ) ; } gc . dispose ( ) ; }', '/ * * * Sets the receiver s caret . Set the caret s height and location . * * < / p > * param caret the new caret for the receiver * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setCaret ( Caret caret ) { checkWidget ( ) ; super . setCaret ( caret ) ; if ( caret ! = null ) { if ( isBidi ( ) = = false ) { caret . setSize ( caret . getSize ( ) . x , lineHeight ) ; } setCaretLocation ( ) ; if ( isBidi ( ) ) { setBidiKeyboardLanguage ( ) ; } } }', '/ * * * see org . eclipse . swt . widgets . Control setBackground * / public void setBackground ( Color color ) { checkWidget ( ) ; background = color ; redraw ( ) ; }', '/ * * * Moves the Caret to the current caret offset . * < p > * * param bidi StyledTextBidi object to use for measuring . * May be left null in which case a new object will be created . * / void setBidiCaretLocation ( StyledTextBidi bidi ) { Caret caret = getCaret ( ) ; if ( caret ! = null ) { String lineText = content . getLine ( caretLine ) ; int lineStartOffset = content . getOffsetAtLine ( caretLine ) ; int offsetInLine = caretOffset - lineStartOffset ; int caretX ; GC gc = null ; if ( bidi = = null ) { gc = new GC ( this ) ; bidi = getStyledTextBidi ( lineText , lineStartOffset , gc ) ; } if ( lastCaretDirection = = SWT . NULL ) { caretX = bidi . getCaretPosition ( offsetInLine ) ; } else { caretX = bidi . getCaretPosition ( offsetInLine , lastCaretDirection ) ; } caretX = caretX - horizontalScrollOffset ; if ( StyledTextBidi . getKeyboardLanguageDirection ( ) = = SWT . RIGHT ) { caretX - = ( getCaretWidth ( ) - 1 ) ; } createBidiCaret ( ) ; caret . setLocation ( caretX + leftMargin , caretLine * lineHeight - verticalScrollOffset + topMargin ) ; if ( gc ! = null ) { gc . dispose ( ) ; } } }', '/ * * * Sets the BIDI coloring mode . When true the BIDI text display * algorithm is applied to segments of text that are the same * color . * * param mode the new coloring mode * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * < p > * deprecated use BidiSegmentListener instead . * < / p > * / public void setBidiColoring ( boolean mode ) { checkWidget ( ) ; bidiColoring = mode ; }', '/ * * * Switches the keyboard language according to the current editing * position and cursor direction . * / void setBidiKeyboardLanguage ( ) { int lineStartOffset = content . getOffsetAtLine ( caretLine ) ; int offsetInLine = caretOffset - lineStartOffset ; String lineText = content . getLine ( caretLine ) ; GC gc = new GC ( this ) ; StyledTextBidi bidi ; int lineLength = lineText . length ( ) ; / / Don t supply the bold styles / font since we don t want to measure anything bidi = new StyledTextBidi ( gc , lineText , getBidiSegments ( lineStartOffset , lineText ) ) ; if ( offsetInLine = = 0 ) { bidi . setKeyboardLanguage ( offsetInLine ) ; } else if ( offsetInLine > = lineLength ) { offsetInLine = Math . min ( offsetInLine , lineLength - 1 ) ; bidi . setKeyboardLanguage ( offsetInLine ) ; } else if ( lastCaretDirection = = ST . COLUMN_NEXT ) { / / continue with previous character type bidi . setKeyboardLanguage ( offsetInLine - 1 ) ; } else { bidi . setKeyboardLanguage ( offsetInLine ) ; } gc . dispose ( ) ; }', '/ * * * Moves the Caret to the current caret offset . * < p > * * param caretX the new x location of the caret . * passed in for better performance when it has already been * calculated outside this method . * param line index of the line the caret is on . Relative to * the first line in the document . * / void setCaretLocation ( int caretX , int line ) { if ( isBidi ( ) ) { setBidiCaretLocation ( null ) ; } else { Caret caret = getCaret ( ) ; if ( caret ! = null ) { caret . setLocation ( caretX + leftMargin , line * lineHeight - verticalScrollOffset + topMargin ) ; } } }', '/ * * * Moves the Caret to the current caret offset . * / void setCaretLocation ( ) { if ( isBidi ( ) ) { setBidiCaretLocation ( null ) ; } else { Caret caret = getCaret ( ) ; if ( caret ! = null ) { int lineStartOffset = content . getOffsetAtLine ( caretLine ) ; int caretX = getXAtOffset ( content . getLine ( caretLine ) , caretLine , caretOffset - lineStartOffset ) ; caret . setLocation ( caretX + leftMargin , caretLine * lineHeight - verticalScrollOffset + topMargin ) ; } } }', '/ * * * Sets the caret offset . * * param offset caret offset , relative to the first character in the text . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a * multi byte line delimiter ( and thus neither clearly in front of or after the line delimiter ) * < / ul > * / public void setCaretOffset ( int offset ) { checkWidget ( ) ; int length = getCharCount ( ) ; if ( length > 0 offset ! = caretOffset ) { if ( offset < 0 ) { caretOffset = 0 ; caretLine = 0 ; } else if ( offset > length ) { caretOffset = length ; caretLine = content . getLineCount ( ) - 1 ; } else { if ( isLineDelimiter ( offset ) ) { / / offset is inside a multi byte line delimiter . This is an / / illegal operation and an exception is thrown . Fixes 1GDKK3R SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } caretOffset = offset ; caretLine = content . getLineAtOffset ( caretOffset ) ; } / / clear the selection if the caret is moved . / / don t notify listeners about the selection change . clearSelection ( false ) ; } / / always update the caret location . fixes 1G8FODP setCaretLocation ( ) ; if ( isBidi ( ) ) { setBidiKeyboardLanguage ( ) ; } }', '/ * * * Sets the content implementation to use for text storage . * < p > * * param content StyledTextContent implementation to use for text storage . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void setContent ( StyledTextContent content ) { checkWidget ( ) ; if ( content = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( this . content ! = null ) { this . content . removeTextChangeListener ( textChangeListener ) ; } logicalContent = content ; if ( wordWrap ) { this . content = new WrappedContent ( this , logicalContent ) ; } else { this . content = logicalContent ; } this . content . addTextChangeListener ( textChangeListener ) ; reset ( ) ; }', '/ * * * Sets whether the widget implements double click mouse behavior . * < / p > * * param enable if true double clicking a word selects the word , if false * double clicks have the same effect as regular mouse clicks . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setDoubleClickEnabled ( boolean enable ) { checkWidget ( ) ; doubleClickEnabled = enable ; }', '/ * * * Sets whether the widget content can be edited . * < / p > * * param editable if true content can be edited , if false content can not be * edited * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setEditable ( boolean editable ) { checkWidget ( ) ; this . editable = editable ; }', '/ * * * Sets a new font to render text with . * < p > * < b > NOTE : < / b > Italic fonts are not supported unless they have no overhang * and the same baseline as regular fonts . * < / p > * * param font new font * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setFont ( Font font ) { checkWidget ( ) ; int oldLineHeight ; super . setFont ( font ) ; if ( boldFont ! = null ) { boldFont . dispose ( ) ; } initializeFonts ( ) ; oldLineHeight = lineHeight ; calculateLineHeight ( ) ; / / keep the same top line visible . fixes 5815 if ( lineHeight ! = oldLineHeight ) { setVerticalScrollOffset ( verticalScrollOffset * lineHeight / oldLineHeight , true ) ; claimBottomFreeSpace ( ) ; } calculateContentWidth ( ) ; calculateScrollBars ( ) ; calculateTabWidth ( ) ; if ( isBidi ( ) ) { caretDirection = SWT . NULL ; createCaretBitmaps ( ) ; createBidiCaret ( ) ; } else { Caret caret = getCaret ( ) ; if ( caret ! = null ) { caret . setSize ( caret . getSize ( ) . x , lineHeight ) ; } } / / always set the caret location . Fixes 6685 setCaretLocation ( ) ; super . redraw ( ) ; }', '/ * * * see org . eclipse . swt . widgets . Control setForeground * / public void setForeground ( Color color ) { checkWidget ( ) ; foreground = color ; redraw ( ) ; }', '/ * * * Sets the horizontal scroll offset relative to the start of the line . * Do nothing if there is no text set . * < p > * < b > NOTE : < / b > The horizontal index is reset to 0 when new text is set in the * widget . * < / p > * * param offset horizontal scroll offset relative to the start * of the line , measured in character increments starting at 0 , if * equal to 0 the content is not scrolled , if > 0 = the content is scrolled . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setHorizontalIndex ( int offset ) { checkWidget ( ) ; int clientAreaWidth = getClientArea ( ) . width ; if ( getCharCount ( ) = = 0 ) { return ; } if ( offset < 0 ) { offset = 0 ; } offset * = getHorizontalIncrement ( ) ; / / allow any value if client area width is unknown or 0 . / / offset will be checked in resize handler . / / don t use isVisible since width is known even if widget / / is temporarily invisible if ( clientAreaWidth > 0 ) { int width = lineCache . getWidth ( ) ; / / prevent scrolling if the content fits in the client area . / / align end of longest line with right border of client area / / if offset is out of range . if ( offset > width - clientAreaWidth ) { offset = Math . max ( 0 , width - clientAreaWidth ) ; } } scrollHorizontalBar ( offset - horizontalScrollOffset ) ; }', '/ * * * Sets the horizontal pixel offset relative to the start of the line . * Do nothing if there is no text set . * < p > * < b > NOTE : < / b > The horizontal pixel offset is reset to 0 when new text * is set in the widget . * < / p > * * param pixel horizontal pixel offset relative to the start * of the line . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * since 2 . 0 * / public void setHorizontalPixel ( int pixel ) { checkWidget ( ) ; int clientAreaWidth = getClientArea ( ) . width ; if ( getCharCount ( ) = = 0 ) { return ; } if ( pixel < 0 ) { pixel = 0 ; } / / allow any value if client area width is unknown or 0 . / / offset will be checked in resize handler . / / don t use isVisible since width is known even if widget / / is temporarily invisible if ( clientAreaWidth > 0 ) { int width = lineCache . getWidth ( ) ; / / prevent scrolling if the content fits in the client area . / / align end of longest line with right border of client area / / if offset is out of range . if ( pixel > width - clientAreaWidth ) { pixel = Math . max ( 0 , width - clientAreaWidth ) ; } } scrollHorizontalBar ( pixel - horizontalScrollOffset ) ; }', '/ * * * Adjusts the maximum and the page size of the horizontal scroll bar * to reflect content width changes . * / void setHorizontalScrollBar ( ) { ScrollBar horizontalBar = getHorizontalBar ( ) ; if ( horizontalBar ! = null horizontalBar . getVisible ( ) ) { final int INACTIVE = 1 ; Rectangle clientArea = getClientArea ( ) ; / / only set the real values if the scroll bar can be used / / ( ie . because the thumb size is less than the scroll maximum ) / / avoids flashing on Motif , fixes 1G7RE1J and 1G5SE92 if ( clientArea . width < lineCache . getWidth ( ) ) { horizontalBar . setValues ( horizontalBar . getSelection ( ) , horizontalBar . getMinimum ( ) , lineCache . getWidth ( ) , / / maximum clientArea . width - leftMargin - rightMargin , / / thumb size horizontalBar . getIncrement ( ) , clientArea . width - leftMargin - rightMargin ) ; / / page size } else if ( horizontalBar . getThumb ( ) ! = INACTIVE horizontalBar . getMaximum ( ) ! = INACTIVE ) { horizontalBar . setValues ( horizontalBar . getSelection ( ) , horizontalBar . getMinimum ( ) , INACTIVE , INACTIVE , horizontalBar . getIncrement ( ) , INACTIVE ) ; } } }', '/ * * * Sets the background color of the specified lines . * The background color is drawn for the width of the widget . All * line background colors are discarded when setText is called . * The text background color if defined in a StyleRange overlays the * line background color . Should not be called if a LineBackgroundListener * has been set since the listener maintains the line backgrounds . * < p > * During text changes , when entire lines are inserted or removed , the line * background colors that are associated with the lines after the change * will "move" with their respective text . For all other text changes , * line background colors will remain unchanged . * < / p > * * param startLine first line the color is applied to , 0 based * param lineCount number of lines the color applies to . * param background line background color * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_ARGUMENT when the specified line range is invalid < / li > * < / ul > * / public void setLineBackground ( int startLine , int lineCount , Color background ) { checkWidget ( ) ; int partialBottomIndex = getPartialBottomIndex ( ) ; / / this API can not be used if the client is providing the line background if ( userLineBackground ) { return ; } if ( startLine < 0 startLine + lineCount > logicalContent . getLineCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } defaultLineStyler . setLineBackground ( startLine , lineCount , background ) ; / / do nothing if redraw range is completely invisible if ( startLine > partialBottomIndex startLine + lineCount - 1 < topIndex ) { return ; } / / only redraw visible lines if ( startLine < topIndex ) { lineCount - = topIndex - startLine ; startLine = topIndex ; } if ( startLine + lineCount - 1 > partialBottomIndex ) { lineCount = partialBottomIndex - startLine + 1 ; } startLine - = topIndex ; super . redraw ( leftMargin , startLine * lineHeight + topMargin , getClientArea ( ) . width - leftMargin - rightMargin , lineCount * lineHeight , true ) ; }', '/ * * * Sets the background of the specified GC for a line rendering operation , * if it is not already set . * < / p > * * param gc GC to set the background color in * param currentBackground background color currently set in gc * param newBackground new background color of gc * / Color setLineBackground ( GC gc , Color currentBackground , Color newBackground ) { if ( currentBackground . equals ( newBackground ) = = false ) { gc . setBackground ( newBackground ) ; } return newBackground ; }', '/ * * * Sets the font of the specified GC if it is not already set . * < / p > * * param gc GC to set the font in * param currentFont font data of font currently set in gc * param style desired style of the font in gc . Can be one of * SWT . NORMAL , SWT . BOLD * / void setLineFont ( GC gc , FontData currentFont , int style ) { if ( currentFont . getStyle ( ) ! = style ) { if ( style = = SWT . BOLD ) { currentFont . setStyle ( style ) ; gc . setFont ( boldFont ) ; } else if ( style = = SWT . NORMAL ) { currentFont . setStyle ( style ) ; gc . setFont ( regularFont ) ; } } }', '/ * * * Sets the foreground of the specified GC for a line rendering operation , * if it is not already set . * < / p > * * param gc GC to set the foreground color in * param currentForeground foreground color currently set in gc * param newForeground new foreground color of gc * / Color setLineForeground ( GC gc , Color currentForeground , Color newForeground ) { if ( currentForeground . equals ( newForeground ) = = false ) { gc . setForeground ( newForeground ) ; } return newForeground ; }', '/ * * * Adjusts the maximum and the page size of the scroll bars to * reflect content width / length changes . * / void setScrollBars ( ) { ScrollBar verticalBar = getVerticalBar ( ) ; if ( verticalBar ! = null ) { Rectangle clientArea = getClientArea ( ) ; final int INACTIVE = 1 ; int maximum = content . getLineCount ( ) * getVerticalIncrement ( ) ; / / only set the real values if the scroll bar can be used / / ( ie . because the thumb size is less than the scroll maximum ) / / avoids flashing on Motif , fixes 1G7RE1J and 1G5SE92 if ( clientArea . height < maximum ) { verticalBar . setValues ( verticalBar . getSelection ( ) , verticalBar . getMinimum ( ) , maximum , clientArea . height , / / thumb size verticalBar . getIncrement ( ) , clientArea . height ) ; / / page size } else if ( verticalBar . getThumb ( ) ! = INACTIVE verticalBar . getMaximum ( ) ! = INACTIVE ) { verticalBar . setValues ( verticalBar . getSelection ( ) , verticalBar . getMinimum ( ) , INACTIVE , INACTIVE , verticalBar . getIncrement ( ) , INACTIVE ) ; } } setHorizontalScrollBar ( ) ; }', '/ * * * Sets the selection to the given position and scrolls it into view . Equivalent to setSelection ( start , start ) . * < p > * * param start new caret position * see setSelection ( int , int ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when start is outside the widget content * < li > ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a * multi byte line delimiter ( and thus neither clearly in front of or after the line delimiter ) * < / ul > * / public void setSelection ( int start ) { setSelection ( start , start ) ; }', '/ * * * Sets the selection and scrolls it into view . * < p > * Indexing is zero based . Text selections are specified in terms of * caret positions . In a text widget that contains N characters , there are * N + 1 caret positions , ranging from 0 . . N * < / p > * * param point x = selection start offset , y = selection end offset * see setSelection ( int , int ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when point is null < / li > * < li > ERROR_INVALID_RANGE when start and end is outside the widget content * < li > ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a * multi byte line delimiter ( and thus neither clearly in front of or after the line delimiter ) * < / ul > * / public void setSelection ( Point point ) { checkWidget ( ) ; if ( point = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; setSelection ( point . x , point . y ) ; }', '/ * * * Sets the selection and scrolls it into view . * < p > * Indexing is zero based . Text selections are specified in terms of * caret positions . In a text widget that contains N characters , there are * N + 1 caret positions , ranging from 0 . . N * < / p > * * param start selection start offset * param end selection end offset * see setSelectionRange ( int , int ) * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when start and end is outside the widget content * < li > ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a * multi byte line delimiter ( and thus neither clearly in front of or after the line delimiter ) * < / ul > * / public void setSelection ( int start , int end ) { checkWidget ( ) ; int contentLength = getCharCount ( ) ; if ( start > end start < 0 end > contentLength ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } if ( isLineDelimiter ( start ) isLineDelimiter ( end ) ) { / / the start offset or end offset of the selection range is inside a / / multi byte line delimiter . This is an illegal operation and an exception / / is thrown . Fixes 1GDKK3R SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } internalSetSelection ( start , end - start , false ) ; / / always update the caret location . fixes 1G8FODP setCaretLocation ( ) ; if ( isBidi ( ) ) { setBidiKeyboardLanguage ( ) ; } showSelection ( ) ; }', '/ * * * Sets the selection . The new selection may not be visible . Call showSelection to scroll * the selection into view . * < p > * * param start offset of the first selected character , start > = 0 must be true . * param length number of characters to select , start < = start + length < = getCharCount ( ) * must be true . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when the range specified by start and length is outside the widget content * < li > ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a * multi byte line delimiter ( and thus neither clearly in front of or after the line delimiter ) * < / ul > * / public void setSelectionRange ( int start , int length ) { checkWidget ( ) ; int contentLength = getCharCount ( ) ; int end = start + length ; if ( start > end start < 0 end > contentLength ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } if ( isLineDelimiter ( start ) isLineDelimiter ( end ) ) { / / the start offset or end offset of the selection range is inside a / / multi byte line delimiter . This is an illegal operation and an exception / / is thrown . Fixes 1GDKK3R SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } internalSetSelection ( start , length , false ) ; / / always update the caret location . fixes 1G8FODP setCaretLocation ( ) ; if ( isBidi ( ) ) { setBidiKeyboardLanguage ( ) ; } }', '/ * * * Sets the selection . * The new selection may not be visible . Call showSelection to scroll * the selection into view . * < p > * * param start offset of the first selected character , start > = 0 must be true . * param length number of characters to select , start < = start + length * < = getCharCount ( ) must be true . * param sendEvent a Selection event is sent when set to true and when * the selection is reset . * / void internalSetSelection ( int start , int length , boolean sendEvent ) { int end = start + length ; if ( selection . x ! = start selection . y ! = end ) { clearSelection ( sendEvent ) ; selectionAnchor = selection . x = start ; caretOffset = selection . y = end ; caretLine = content . getLineAtOffset ( caretOffset ) ; if ( length > 0 ) { internalRedrawRange ( selection . x , selection . y - selection . x , true ) ; } } }', '/ * * * Adds the specified style . The new style overwrites existing styles for the * specified range . Existing style ranges are adjusted if they partially * overlap with the new style , To clear an individual style , call setStyleRange * with a StyleRange that has null attributes . * < p > * Should not be called if a LineStyleListener has been set since the * listener maintains the styles . * < / p > * * param range StyleRange object containing the style information . * Overwrites the old style in the given range . May be null to delete * all styles . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_INVALID_RANGE when the style range is outside the valid range ( > getCharCount ( ) ) < / li > * < / ul > * / public void setStyleRange ( StyleRange range ) { checkWidget ( ) ; boolean redrawFirstLine = false ; boolean redrawLastLine = false ; / / this API can not be used if the client is providing the line styles if ( userLineStyle ) { return ; } / / check the range , make sure it falls within the range of the / / text if ( range ! = null range . start + range . length > content . getCharCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } if ( range ! = null ) { / / the first and last line needs to be redrawn completely if the / / font style is changing from SWT . NORMAL to something else or / / vice versa . fixes 1G7M5WE . int rangeEnd = range . start + range . length ; int firstLine = content . getLineAtOffset ( range . start ) ; int lastLine = content . getLineAtOffset ( rangeEnd ) ; int firstLineOffset = content . getOffsetAtLine ( firstLine ) ; if ( isStyleChanging ( range , range . start , Math . min ( rangeEnd , firstLineOffset + content . getLine ( firstLine ) . length ( ) ) ) ) { redrawFirstLine = true ; } if ( lastLine ! = firstLine ) { int lastLineOffset = content . getOffsetAtLine ( lastLine ) ; if ( isStyleChanging ( range , lastLineOffset , rangeEnd ) ) { redrawLastLine = true ; } } } if ( isBidi ( ) ) { redrawFirstLine = true ; redrawLastLine = true ; } defaultLineStyler . setStyleRange ( range ) ; if ( range ! = null ) { int firstLine = content . getLineAtOffset ( range . start ) ; int lastLine = content . getLineAtOffset ( range . start + range . length ) ; / / reset all lines affected by the style change but let the redraw / / recalculate only those that are visible . lineCache . reset ( firstLine , lastLine - firstLine + 1 , true ) ; internalRedrawRange ( range . start , range . length , true ) ; if ( redrawFirstLine ) { / / redraw starting at the style change start offset since / / single line text changes , followed by style changes will / / flash otherwise int firstLineOffset = content . getOffsetAtLine ( firstLine ) ; String firstLineText = content . getLine ( firstLine ) ; int redrawX = getXAtOffset ( firstLineText , firstLine , range . start - firstLineOffset ) ; int redrawY = firstLine * lineHeight - verticalScrollOffset ; super . redraw ( redrawX + leftMargin , redrawY + topMargin , getClientArea ( ) . width , lineHeight , true ) ; } if ( redrawLastLine ) { / / redraw the whole line if the font style changed on the last line int redrawY = lastLine * lineHeight - verticalScrollOffset ; super . redraw ( leftMargin , redrawY + topMargin , getClientArea ( ) . width , lineHeight , true ) ; } } else { / / reset all lines but let the redraw recalculate only those that / / are visible . lineCache . reset ( 0 , content . getLineCount ( ) , false ) ; redraw ( ) ; } / / make sure that the caret is positioned correctly . / / caret location may change if font style changes . / / fixes 1G8FODP setCaretLocation ( ) ; }', '/ * * * Sets styles to be used for rendering the widget content . All styles * will be replaced with the given set of styles . * < p > * Should not be called if a LineStyleListener has been set since the * listener maintains the styles . * < / p > * * param ranges StyleRange objects containing the style information . * The ranges should not overlap . The style rendering is undefined if * the ranges do overlap . Must not be null . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < li > ERROR_INVALID_RANGE when the last of the style ranges is outside the valid range ( > getCharCount ( ) ) < / li > * < / ul > * / public void setStyleRanges ( StyleRange ranges ) { checkWidget ( ) ; / / this API can not be used if the client is providing the line styles if ( userLineStyle ) { return ; } if ( ranges = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } / / check the last range , make sure it falls within the range of the / / current text if ( ranges . length ! = 0 ) { StyleRange last = ranges ranges . length - 1 ; int lastEnd = last . start + last . length ; int firstLine = content . getLineAtOffset ( ranges 0 . start ) ; int lastLine ; if ( lastEnd > content . getCharCount ( ) ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } lastLine = content . getLineAtOffset ( lastEnd ) ; / / reset all lines affected by the style change lineCache . reset ( firstLine , lastLine - firstLine + 1 , true ) ; } else { / / reset all lines lineCache . reset ( 0 , content . getLineCount ( ) , false ) ; } defaultLineStyler . setStyleRanges ( ranges ) ; redraw ( ) ; / / should only redraw affected area to avoid flashing / / make sure that the caret is positioned correctly . / / caret location may change if font style changes . / / fixes 1G8FODP setCaretLocation ( ) ; }', '/ * * * Ensures that the selection style ends at the selection end . * < code > selectionStyle < / code > is assumed to be created based on the style * range of < code > style < / code > . If < code > selectionStyle < / code > does extend * beyond the selection range a new style is returned to preserve the style * passed in with < code > style < / code > . * < p > * param selectionStyle the selection style based on the style range in * < code > style < / code > * param style the existing style that is to be merged with the selection * return a new style that preserves the style passed in with < code > style < / code > * if the selection does not fully extend over the existing style range . * null otherwise . * / StyleRange setSelectionStyleEnd ( StyleRange selectionStyle , StyleRange style ) { int selectionEnd = selection . y ; StyleRange newStyle = null ; / / does style extend beyond selection ? if ( selectionStyle . start + selectionStyle . length > selectionEnd ) { int styleEnd = style . start + style . length ; selectionStyle . length = selectionEnd - selectionStyle . start ; / / preserve rest ( unselected part ) of old style newStyle = ( StyleRange ) style . clone ( ) ; newStyle . start = selectionEnd ; newStyle . length = styleEnd - selectionEnd ; } return newStyle ; }', '/ * * * Sets the tab width . * < p > * * param tabs tab width measured in characters . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setTabs ( int tabs ) { checkWidget ( ) ; tabLength = tabs ; calculateTabWidth ( ) ; if ( caretOffset > 0 ) { caretOffset = 0 ; caretLine = 0 ; if ( isBidi ( ) ) { showBidiCaret ( ) ; } else { showCaret ( ) ; } clearSelection ( false ) ; } / / reset all line widths when the tab width changes lineCache . reset ( 0 , content . getLineCount ( ) , false ) ; redraw ( ) ; }', '/ * * * Sets the widget content . * If the widget has the SWT . SINGLE style and "text" contains more than * one line , only the first line is rendered but the text is stored * unchanged . A subsequent call to getText will return the same text * that was set . * < p > * < b > Note : < / b > Only a single line of text should be set when the SWT . SINGLE * style is used . * < / p > * * param text new widget content . Replaces existing content . Line styles * that were set using StyledText API are discarded . The * current selection is also discarded . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public void setText ( String text ) { checkWidget ( ) ; Event event = new Event ( ) ; if ( text = = null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } event . start = 0 ; event . end = getCharCount ( ) ; event . text = text ; event . doit = true ; notifyListeners ( SWT . Verify , event ) ; if ( event . doit ) { StyledTextEvent styledTextEvent = null ; if ( isListening ( ExtendedModify ) ) { styledTextEvent = new StyledTextEvent ( logicalContent ) ; styledTextEvent . start = event . start ; styledTextEvent . end = event . start + event . text . length ( ) ; styledTextEvent . text = content . getTextRange ( event . start , event . end - event . start ) ; } content . setText ( event . text ) ; notifyListeners ( SWT . Modify , event ) ; if ( styledTextEvent ! = null ) { notifyListeners ( ExtendedModify , styledTextEvent ) ; } } }', '/ * * * Sets the text limit . * < p > * The text limit specifies the amount of text that * the user can type into the widget . * < / p > * * param limit the new text limit . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * exception IllegalArgumentException < ul > * < li > ERROR_CANNOT_BE_ZERO when limit is 0 < / li > * < / ul > * / public void setTextLimit ( int limit ) { checkWidget ( ) ; if ( limit = = 0 ) { SWT . error ( SWT . ERROR_CANNOT_BE_ZERO ) ; } textLimit = limit ; }', '/ * * * Sets the top index . Do nothing if there is no text set . * < p > * The top index is the index of the line that is currently at the top * of the widget . The top index changes when the widget is scrolled . * Indexing starts from zero . * Note : The top index is reset to 0 when new text is set in the widget . * < / p > * * param index new top index . Must be between 0 and getLineCount ( ) - * visible lines per page . An out of range index will be adjusted accordingly . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setTopIndex ( int topIndex ) { checkWidget ( ) ; int lineCount = logicalContent . getLineCount ( ) ; int pageSize = Math . min ( lineCount , getLineCountWhole ( ) ) ; if ( getCharCount ( ) = = 0 ) { return ; } if ( topIndex < 0 ) { topIndex = 0 ; } else if ( topIndex > lineCount - pageSize ) { topIndex = lineCount - pageSize ; } if ( wordWrap ) { int logicalLineOffset = logicalContent . getOffsetAtLine ( topIndex ) ; topIndex = content . getLineAtOffset ( logicalLineOffset ) ; } setVerticalScrollOffset ( topIndex * getVerticalIncrement ( ) , true ) ; }', '/ * * * Sets the top pixel offset . Do nothing if there is no text set . * < p > * The top pixel offset is the vertical pixel offset of the widget . The * widget is scrolled so that the given pixel position is at the top . * The top index is adjusted to the corresponding top line . * Note : The top pixel is reset to 0 when new text is set in the widget . * < / p > * * param pixel new top pixel offset . Must be between 0 and * ( getLineCount ( ) - visible lines per page ) / getLineHeight ( ) ) . An out * of range offset will be adjusted accordingly . * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * since 2 . 0 * / public void setTopPixel ( int pixel ) { checkWidget ( ) ; int lineCount = logicalContent . getLineCount ( ) ; int height = getClientArea ( ) . height ; int maxTopPixel = Math . max ( 0 , lineCount * getVerticalIncrement ( ) - height ) ; if ( getCharCount ( ) = = 0 ) { return ; } if ( pixel < 0 ) { pixel = 0 ; } else if ( pixel > maxTopPixel ) { pixel = maxTopPixel ; } setVerticalScrollOffset ( pixel , true ) ; }', '/ * * * Scrolls the widget vertically . * < p > * * param pixelOffset the new vertical scroll offset * param adjustScrollBar * true = the scroll thumb will be moved to reflect the new scroll offset . * false = the scroll thumb will not be moved * / void setVerticalScrollOffset ( int pixelOffset , boolean adjustScrollBar ) { Rectangle clientArea ; ScrollBar verticalBar = getVerticalBar ( ) ; int verticalIncrement = getVerticalIncrement ( ) ; if ( pixelOffset = = verticalScrollOffset ) { return ; } if ( verticalBar ! = null adjustScrollBar ) { verticalBar . setSelection ( pixelOffset ) ; } clientArea = getClientArea ( ) ; scroll ( 0 , 0 , / / destination x , y 0 , pixelOffset - verticalScrollOffset , / / source x , y clientArea . width , clientArea . height , true ) ; if ( verticalIncrement ! = 0 ) { int oldTopIndex = topIndex ; topIndex = Compatibility . ceil ( pixelOffset , verticalIncrement ) ; if ( topIndex ! = oldTopIndex ) { lineCache . calculate ( topIndex , getPartialBottomIndex ( ) - topIndex + 1 ) ; setHorizontalScrollBar ( ) ; } } verticalScrollOffset = pixelOffset ; setCaretLocation ( ) ; }', '/ * * * Scrolls the specified location into view . * < p > * * param x the x coordinate that should be made visible . * param line the line that should be made visible . Relative to the * first line in the document . * return * true = the widget was scrolled to make the specified location visible . * false = the specified location is already visible , the widget was * not scrolled . * / boolean showLocation ( int x , int line ) { int clientAreaWidth = getClientArea ( ) . width - leftMargin - rightMargin ; int verticalIncrement = getVerticalIncrement ( ) ; int horizontalIncrement = clientAreaWidth / 4 ; boolean scrolled = false ; if ( x < 0 ) { / / always make 1 / 4 of a page visible x = Math . max ( horizontalScrollOffset * - 1 , x - horizontalIncrement ) ; scrollHorizontalBar ( x ) ; scrolled = true ; } else if ( x > clientAreaWidth ) { / / always make 1 / 4 of a page visible x = Math . min ( lineCache . getWidth ( ) - horizontalScrollOffset , x + horizontalIncrement ) ; scrollHorizontalBar ( x - clientAreaWidth ) ; scrolled = true ; } if ( line < topIndex ) { setVerticalScrollOffset ( line * verticalIncrement , true ) ; scrolled = true ; } else if ( line > getBottomIndex ( ) ) { setVerticalScrollOffset ( ( line - getBottomIndex ( ) ) * verticalIncrement + verticalScrollOffset , true ) ; scrolled = true ; } return scrolled ; }', '/ * * * Sets the caret location and scrolls the caret offset into view . * / void showCaret ( ) { int lineOffset = content . getOffsetAtLine ( caretLine ) ; String lineText = content . getLine ( caretLine ) ; int offsetInLine = caretOffset - lineOffset ; int xAtOffset = getXAtOffset ( lineText , caretLine , offsetInLine ) ; boolean scrolled = showLocation ( xAtOffset , caretLine ) ; if ( scrolled = = false ) { setCaretLocation ( xAtOffset , caretLine ) ; } if ( isBidi ( ) ) { setBidiKeyboardLanguage ( ) ; } }', '/ * * * Scrolls the specified offset into view . * < p > * * param offset offset that should be scolled into view * / void showOffset ( int offset ) { int line = content . getLineAtOffset ( offset ) ; int lineOffset = content . getOffsetAtLine ( line ) ; int offsetInLine = offset - lineOffset ; String lineText = content . getLine ( line ) ; int xAtOffset = getXAtOffset ( lineText , line , offsetInLine ) ; showLocation ( xAtOffset , line ) ; }', '/ * * * Scrolls the selection into view . * < p > * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void showSelection ( ) { checkWidget ( ) ; showOffset ( selection . x ) ; showOffset ( selection . y ) ; }', '/ * * * Returns the width of the specified text . Expand tabs to tab stops using * the widget tab width . * < p > * * param line line to be measured . * param lineIndex index of the line relative to the first kine of the * document * param length number of characters to measure . Tabs are counted * as one character in this parameter . * param gc GC to use for measuring text * return width of the text with tabs expanded to tab stops or 0 if the * length is beyond the text length . * / int textWidth ( String line , int lineIndex , int length , GC gc ) { int lineOffset = content . getOffsetAtLine ( lineIndex ) ; int lineLength = line . length ( ) ; int width ; if ( lineLength = = 0 length > lineLength ) { return 0 ; } if ( isBidi ( ) ) { StyledTextBidi bidi = getStyledTextBidi ( line , lineOffset , gc ) ; width = bidiTextWidth ( line , 0 , length , 0 , bidi ) ; } else { StyledTextEvent event = getLineStyleData ( lineOffset , line ) ; StyleRange styles = null ; if ( event ! = null ) { styles = filterLineStyles ( event . styles ) ; } width = textWidth ( line , lineOffset , 0 , length , styles , 0 , gc , gc . getFont ( ) . getFontData ( ) 0 ) ; } return width ; }', '/ * * * Returns the width of the specified text . Expand tabs to tab stops using * the widget tab width . * < p > * * param text text to be measured . * param lineOffset offset of the first character in the line . * param startOffset offset of the character to start measuring and * expand tabs . * param length number of characters to measure . Tabs are counted * as one character in this parameter . * param styles line styles * param startXOffset x position of "startOffset" in "text" . Used for * calculating tab stops * param gc GC to use for measuring text * param fontData the font currently set in gc . Cached for better performance . * return width of the text with tabs expanded to tab stops or 0 if the * startOffset or length is outside the specified text . * / int textWidth ( String text , int lineOffset , int startOffset , int length , StyleRange lineStyles , int startXOffset , GC gc , FontData fontData ) { int paintX = 0 ; int endOffset = startOffset + length ; int textLength = text . length ( ) ; if ( startOffset < 0 startOffset > = textLength endOffset > textLength ) { return paintX ; } for ( int i = startOffset ; i < endOffset ; i + + ) { int tabIndex = text . indexOf ( TAB , i ) ; / / is tab not present or past the rendering range ? if ( tabIndex = = - 1 tabIndex > endOffset ) { tabIndex = endOffset ; } if ( tabIndex ! = i ) { String tabSegment = text . substring ( i , tabIndex ) ; if ( lineStyles ! = null ) { paintX = styledTextWidth ( tabSegment , lineOffset + i , lineStyles , paintX , gc , fontData ) ; } else { setLineFont ( gc , fontData , SWT . NORMAL ) ; paintX + = gc . stringExtent ( tabSegment ) . x ; } if ( tabIndex ! = endOffset tabWidth > 0 ) { paintX = getTabStop ( startXOffset + paintX ) - startXOffset ; } i = tabIndex ; } else if ( tabWidth > 0 ) { paintX = getTabStop ( startXOffset + paintX ) - startXOffset ; } } return paintX ; }', '/ * * * Measures the text as rendered at the specified location . Expand tabs to tab stops using * the widget tab width . * < p > * * param text text to draw * param textStartOffset offset of the first character in text relative * to the first character in the document * param lineStyles styles of the line * param paintX x location to start drawing at * param gc GC to draw on * param fontData the font data of the font currently set in gc * return x location where drawing stopped or 0 if the startOffset or * length is outside the specified text . * / int styledTextWidth ( String text , int textStartOffset , StyleRange lineStyles , int paintX , GC gc , FontData fontData ) { String textSegment ; int textLength = text . length ( ) ; int textIndex = 0 ; for ( int styleIndex = 0 ; styleIndex < lineStyles . length ; styleIndex + + ) { StyleRange style = lineStyles styleIndex ; int textEnd ; int styleSegmentStart = style . start - textStartOffset ; if ( styleSegmentStart + style . length < 0 ) { continue ; } if ( styleSegmentStart > = textLength ) { break ; } / / is there a style for the current string position ? if ( textIndex < styleSegmentStart ) { setLineFont ( gc , fontData , SWT . NORMAL ) ; textSegment = text . substring ( textIndex , styleSegmentStart ) ; paintX + = gc . stringExtent ( textSegment ) . x ; textIndex = styleSegmentStart ; } textEnd = Math . min ( textLength , styleSegmentStart + style . length ) ; setLineFont ( gc , fontData , style . fontStyle ) ; textSegment = text . substring ( textIndex , textEnd ) ; paintX + = gc . stringExtent ( textSegment ) . x ; textIndex = textEnd ; } / / is there unmeasured and unstyled text ? if ( textIndex < textLength ) { setLineFont ( gc , fontData , SWT . NORMAL ) ; textSegment = text . substring ( textIndex , textLength ) ; paintX + = gc . stringExtent ( textSegment ) . x ; } return paintX ; }', '/ * * * Updates the caret direction when a delete operation occured based on * the type of the delete operation ( next / previous character ) and the * caret location ( at a direction boundary or inside a direction segment ) . * The intent is to place the caret at the visual location where a * character was deleted . * < p > * * param isBackspace true = the previous character was deleted , false = the * character next to the caret location was deleted * param isDirectionBoundary true = the caret is between a R2L and L2R segment , * false = the caret is within a direction segment * / void updateBidiDirection ( boolean isBackspace , boolean isDirectionBoundary ) { if ( isDirectionBoundary ) { int oldDirection = lastCaretDirection ; if ( isBackspace ) { / / Deleted previous character ( backspace ) at a direction boundary / / Go to direction segment of deleted character lastCaretDirection = ST . COLUMN_NEXT ; } else { / / Deleted next character . Go to direction segment of deleted character lastCaretDirection = ST . COLUMN_PREVIOUS ; } if ( lastCaretDirection ! = oldDirection ) { setBidiKeyboardLanguage ( ) ; } } else { if ( isBackspace ) { / / Delete previous character inside direction segment ( i . e . , not at a direction boundary ) lastCaretDirection = ST . COLUMN_PREVIOUS ; } else { / / Deleted next character . lastCaretDirection = ST . COLUMN_NEXT ; } } }', '/ * * * Updates the selection and caret position depending on the text change . * If the selection intersects with the replaced text , the selection is * reset and the caret moved to the end of the new text . * If the selection is behind the replaced text it is moved so that the * same text remains selected . If the selection is before the replaced text * it is left unchanged . * < p > * * param startOffset offset of the text change * param replacedLength length of text being replaced * param newLength length of new text * / void updateSelection ( int startOffset , int replacedLength , int newLength ) { if ( selection . y < = startOffset ) { / / selection ends before text change return ; } if ( selection . x < startOffset ) { / / clear selection fragment before text change internalRedrawRange ( selection . x , startOffset - selection . x , true ) ; } if ( selection . y > startOffset + replacedLength selection . x < startOffset + replacedLength ) { / / clear selection fragment after text change . / / do this only when the selection is actually affected by the / / change . Selection is only affected if it intersects the change ( 1GDY217 ) . int netNewLength = newLength - replacedLength ; int redrawStart = startOffset + newLength ; internalRedrawRange ( redrawStart , selection . y + netNewLength - redrawStart , true ) ; } if ( selection . y > startOffset selection . x < startOffset + replacedLength ) { / / selection intersects replaced text . set caret behind text change internalSetSelection ( startOffset + newLength , 0 , true ) ; / / always update the caret location . fixes 1G8FODP setCaretLocation ( ) ; } else { / / move selection to keep same text selected internalSetSelection ( selection . x + newLength - replacedLength , selection . y - selection . x , true ) ; / / always update the caret location . fixes 1G8FODP setCaretLocation ( ) ; } }', '/ * * * Rewraps all lines and adjusts the top index so that the top * line remains the same . * < p > * * param oldClientAreaWidth client area width before resize * occurred * / void wordWrapResize ( int oldClientAreaWidth ) { String oldCaretLine = content . getLine ( caretLine ) ; String topLine = content . getLine ( topIndex ) ; int topOffset = content . getOffsetAtLine ( topIndex ) + topLine . length ( ) ; int newTopIndex ; WrappedContent wrappedContent = ( WrappedContent ) content ; / / all lines are wrapped and no rewrap required if widget has already / / been visible , client area is now wider and visual ( wrapped ) line / / count equals logical line count . if ( oldClientAreaWidth ! = 0 clientAreaWidth > oldClientAreaWidth wrappedContent . getLineCount ( ) = = logicalContent . getLineCount ( ) ) { return ; } wrappedContent . wrapLines ( ) ; / / has word wrap changed on the caret line ? if ( caretLine > = content . getLineCount ( ) content . getLine ( caretLine ) . equals ( oldCaretLine ) = = false ) { / / caret may now be on a different line caretLine = content . getLineAtOffset ( caretOffset ) ; setCaretLocation ( ) ; } / / make sure top line remains the same / / topOffset is the end of the top line . otherwise top index would be / / set to the preceeding visual line if top line is wrapped ( because / / end of preceeding line = = start of next line ) . fixes 8503 . newTopIndex = content . getLineAtOffset ( topOffset ) ; if ( newTopIndex ! = topIndex ) { ScrollBar verticalBar = getVerticalBar ( ) ; / / adjust index and pixel offset manually instead of calling / / setVerticalScrollOffset because the widget does not actually need / / to be scrolled . causes flash otherwise . verticalScrollOffset + = ( newTopIndex - topIndex ) * getVerticalIncrement ( ) ; / / verticalScrollOffset may become negative if first line was / / partially visible and second line was top line . prevent this from / / happening to fix 8503 . if ( verticalScrollOffset < 0 ) { verticalScrollOffset = 0 ; } topIndex = newTopIndex ; if ( verticalBar ! = null ) { verticalBar . setSelection ( verticalScrollOffset ) ; } } / / word wrap may have changed on one of the visible lines super . redraw ( ) ; }'], 'label': 0}
{'guid': '1839d9b_e6090812a1a73997ed352ffa19b13b1e720433f9', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['DirectionRun ( int logicalStart , int logicalEnd ) { this . logicalStart = logicalStart ; this . logicalEnd = logicalEnd ; }', 'int getVisualStart ( ) { int visualStart = order logicalStart ; int visualEnd = order logicalEnd ; / / the visualStart of a R2L direction run is actually / / at the run s logicalEnd , answered as such since rendering / / always occurs from L2R regardless of the text run s / / direction if ( visualEnd < visualStart ) { visualStart = visualEnd ; } return visualStart ; }', 'int getVisualEnd ( ) { int visualStart = order logicalStart ; int visualEnd = order logicalEnd ; / / the visualEnd of a R2L direction run is actually / / at the run s logicalStart , answered as such since rendering / / always occurs from L2R regardless of the text run s / / direction if ( visualEnd < visualStart ) { visualEnd = visualStart ; } return visualEnd ; }', 'int getRenderStartX ( ) { return renderPositions getVisualStart ( ) ; }', 'int getRenderStopX ( ) { int visualEnd = getVisualEnd ( ) ; return renderPositions visualEnd + dx visualEnd ; }', 'public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "vStart , Stop : " + getVisualStart ( ) + " , " + getVisualEnd ( ) + " lStart , Stop : " + logicalStart + " , " + logicalEnd + " renderStart , Stop : " + getRenderStartX ( ) + " , " + getRenderStopX ( ) ) ; return buf . toString ( ) ; }', '/ * * * Constructs an instance of this class for a line of text . The text * is reordered to reflect how it will be displayed . * < p > * * param gc the GC to use for rendering and measuring of this line . * param tabWidth tab width in number of spaces , used to calculate * tab stops * param text line that bidi data should be calculated for * param boldRanges bold text segments in the line , specified as * i = bold start , i + 1 = bold length * param boldFont font that bold text will be rendered in , needed for * proper measuring of bold text segments . * param offset text segments that should be measured and reordered * separately , may be needed to preserve the order of separate R2L * segments to each other * / public StyledTextBidi ( GC gc , int tabWidth , String text , StyleRange ranges , Font boldFont , int offsets ) { int length = text . length ( ) ; this . gc = gc ; bidiSegments = offsets ; renderPositions = new int length ; order = new int length ; dx = new int length ; classBuffer = new byte length ; if ( length = = 0 ) { glyphBuffer = new char 0 ; } else { glyphBuffer = BidiUtil . getRenderInfo ( gc , text , order , classBuffer , dx , 0 , offsets ) ; if ( ranges ! = null ) { / / If the font supports characters shaping , break up the font style ranges based on / / the specified bidi segments . Each bidi segment will be treated separately / / for font style purposes . StyleRange segmentedRanges ; if ( isCharacterShaped ( gc ) ) segmentedRanges = segmentedRangesFor ( ranges ) ; else segmentedRanges = ranges ; Font normalFont = gc . getFont ( ) ; gc . setFont ( boldFont ) ; for ( int i = 0 ; i < segmentedRanges . length ; i + + ) { StyleRange segmentedRange = segmentedRanges i ; int rangeStart = segmentedRange . start ; int rangeLength = segmentedRange . length ; / / Font styled text needs to be processed so that the dx array reflects the styled / / font . prepareFontStyledText ( text , rangeStart , rangeLength ) ; } gc . setFont ( normalFont ) ; } calculateTabStops ( text , tabWidth ) ; calculateRenderPositions ( ) ; } }', '/ * * * Constructs an instance of this class for a line of text . This constructor * should be used when only ordering ( not rendering ) information is needed . * Only the class and order arrays will be filled during this call . * < p > * * param gc the GC to use for rendering and measuring of this line . * param text line that bidi data should be calculated for * param offset text segments that should be measured and reordered * separately , may be needed to preserve the order of separate R2L * segments to each other * / public StyledTextBidi ( GC gc , String text , int offsets ) { int length = text . length ( ) ; this . gc = gc ; bidiSegments = offsets ; order = new int length ; classBuffer = new byte length ; BidiUtil . getOrderInfo ( gc , text , order , classBuffer , 0 , offsets ) ; / / initialize the unused arrays dx = new int 0 ; renderPositions = new int 0 ; glyphBuffer = new char 0 ; }', '/ * * * Adds a listener that should be called when the user changes the * keyboard layout for the specified window . * < p > * * param control Control to add the keyboard language listener for . * Each window has its own keyboard language setting . * param runnable the listener that should be called when the user * changes the keyboard layout . * / static void addLanguageListener ( Control control , Runnable runnable ) { BidiUtil . addLanguageListener ( control . handle , runnable ) ; }', '/ * * * Answers the direction of the active keyboard language - either * L2R or R2L . The active keyboard language determines the direction * of the caret and can be changed by the user ( e . g . , via Alt - Shift on * Win32 platforms ) . * < p > * * return the direction of the active keyboard language . SWT . LEFT ( for L2R * language ) or SWT . RIGHT ( for R2L language ) . * / static int getKeyboardLanguageDirection ( ) { int language = BidiUtil . getKeyboardLanguage ( ) ; if ( language = = BidiUtil . KEYBOARD_HEBREW ) { return SWT . RIGHT ; } if ( language = = BidiUtil . KEYBOARD_ARABIC ) { return SWT . RIGHT ; } return SWT . LEFT ; }', '/ * * * Removes the keyboard language listener for the specified window . * < p > * * param control window to remove the keyboard language listener from . * / static void removeLanguageListener ( Control control ) { BidiUtil . removeLanguageListener ( control . handle ) ; }', '/ * * * Calculates render positions using the glyph distance values in the dx array . * / private void calculateRenderPositions ( ) { renderPositions = new int dx . length ; renderPositions 0 = StyledText . XINSET ; for ( int i = 0 ; i < dx . length - 1 ; i + + ) { renderPositions i + 1 = renderPositions i + dx i ; } }', '/ * * * Calculate the line s tab stops and adjust the dx array to * reflect the width of tab characters . * < p > * * param text the original line text ( not reordered ) containing * tab characters . * param tabWidth number of pixels that one tab character represents * / private void calculateTabStops ( String text , int tabWidth ) { int tabIndex = text . indexOf ( t , 0 ) ; int logicalIndex = 0 ; int x = StyledText . XINSET ; int spaceWidth = gc . stringExtent ( " " ) . x ; while ( tabIndex ! = - 1 ) { for ( ; logicalIndex < tabIndex ; logicalIndex + + ) { x + = dx order logicalIndex ; } int tabStop = x + tabWidth ; / / make sure tab stop is at least one space width apart / / from the last character . fixes 4844 . if ( tabWidth - tabStop tabWidth < spaceWidth ) { tabStop + = tabWidth ; } tabStop - = tabStop tabWidth ; dx order tabIndex = tabStop - x ; tabIndex = text . indexOf ( t , tabIndex + 1 ) ; } }', '/ * * * Renders the specified text segment . All text is rendered L2R * regardless of the direction of the text . The rendered text may * be visually discontiguous if the text segment is bidirectional . * < p > * * param logicalStart start offset in the logical text * param length number of logical characters to render * param xOffset x location of the line start * param yOffset y location of the line start * / void drawBidiText ( int logicalStart , int length , int xOffset , int yOffset ) { Enumeration directionRuns = getDirectionRuns ( logicalStart , length ) . elements ( ) ; int endOffset = logicalStart + length ; if ( endOffset > getTextLength ( ) ) { return ; } while ( directionRuns . hasMoreElements ( ) ) { DirectionRun run = ( DirectionRun ) directionRuns . nextElement ( ) ; int visualStart = run . getVisualStart ( ) ; int visualEnd = run . getVisualEnd ( ) ; int x = xOffset + run . getRenderStartX ( ) ; drawGlyphs ( visualStart , visualEnd - visualStart + 1 , x , yOffset ) ; } }', '/ * * * Renders a segment of glyphs . Glyphs are visual objects so the * start and length are visual as well . Glyphs are always rendered L2R . * < p > * * param visualStart start offset of the glyphs to render relative to the * line start . * param length number of glyphs to render * param x x location to render at * param y y location to render at * / private void drawGlyphs ( int visualStart , int length , int x , int y ) { char renderBuffer = new char length ; int renderDx = new int length ; if ( length = = 0 ) { return ; } System . arraycopy ( glyphBuffer , visualStart , renderBuffer , 0 , length ) ; / / copy the distance values for the desired rendering range System . arraycopy ( dx , visualStart , renderDx , 0 , length ) ; BidiUtil . drawGlyphs ( gc , renderBuffer , renderDx , x , y ) ; }', '/ * * * Fills a rectangle spanning the given logical range . * The rectangle may be visually discontiguous if the text segment * is bidirectional . * < p > * * param logicalStart logcial start offset of the rectangle * param length number of logical characters the rectangle should span * param xOffset x location of the line start * param yOffset y location of the line start * param height height of the rectangle * / void fillBackground ( int logicalStart , int length , int xOffset , int yOffset , int height ) { Enumeration directionRuns = getDirectionRuns ( logicalStart , length ) . elements ( ) ; if ( logicalStart + length > getTextLength ( ) ) { return ; } while ( directionRuns . hasMoreElements ( ) ) { DirectionRun run = ( DirectionRun ) directionRuns . nextElement ( ) ; int startX = run . getRenderStartX ( ) ; gc . fillRectangle ( xOffset + startX , yOffset , run . getRenderStopX ( ) - startX , height ) ; } }', '/ * * * Returns the offset and direction that will be used to position the caret for * the given x location . The caret will be placed in front of or behind the * character at location x depending on what type of character ( i . e . , R2L or L2R ) * is at location x . This method is used for positioning the caret when a mouse * click occurs within the widget . * < p > * * param x the x location of the character in the line . * return array containing the caret offset and direction for the x location . * index 0 : offset relative to the start of the line * index 1 : direction , either ST . COLUMN_NEXT or ST . COLUMN_PREVIOUS . * The direction is used to control the caret position at direction * boundaries . The semantics follow the behavior for keyboard cursor * navigation . * Example : RRRLLL * Pressing cursor left ( COLUMN_PREVIOUS ) in the L2R segment places the cursor * in front of the first character of the L2R segment . Pressing cursor right * ( COLUMN_NEXT ) in a R2L segment places the cursor behind the last character * of the R2L segment . However , both are the same logical offset . * / int getCaretOffsetAndDirectionAtX ( int x ) { int lineLength = getTextLength ( ) ; int offset ; int direction ; if ( lineLength = = 0 ) { return new int { 0 , 0 } ; } int eol = renderPositions renderPositions . length - 1 + dx dx . length - 1 ; if ( x > = eol ) { return new int { lineLength , ST . COLUMN_NEXT } ; } / / get the visual offset of the clicked character int visualOffset = getVisualOffsetAtX ( x ) ; / / figure out if the character was clicked on the right or left int halfway = renderPositions visualOffset + dx visualOffset / 2 ; boolean visualLeft = ( x < = halfway ) ; offset = getLogicalOffset ( visualOffset ) ; if ( isRightToLeft ( offset ) ) { if ( visualLeft ) { if ( isLigated ( gc ) ) { / / the caret should be positioned after the last / / character of the ligature offset = getLigatureEndOffset ( offset ) ; } offset + + ; / / position the caret as if the caret is to the right / / of the character at location x and the NEXT key is / / pressed direction = ST . COLUMN_NEXT ; } else { / / position the caret as if the caret is to the left / / of the character at location x and the PREVIOUS key is / / pressed direction = ST . COLUMN_PREVIOUS ; } } else { if ( visualLeft ) { / / position the caret as if the caret is to the right / / of the character at location x and the PREVIOUS key is / / pressed direction = ST . COLUMN_PREVIOUS ; } else { / / position the caret as if the caret is to the left / / of the character at location x and the NEXT key is / / pressed offset + + ; direction = ST . COLUMN_NEXT ; } } return new int { offset , direction } ; }', '/ * * * Returns the caret position at the specified offset in the line . * < p > * param logicalOffset offset of the character in the line * return the caret position at the specified offset in the line . * / int getCaretPosition ( int logicalOffset ) { return getCaretPosition ( logicalOffset , ST . COLUMN_NEXT ) ; }', '/ * * * Returns the caret position at the specified offset in the line . * The direction parameter is used to determine the caret position * at direction boundaries . If the logical offset is between a R2L * and a L2R segment , pressing cursor left in the L2R segment places * the cursor in front of the first character of the L2R segment ; whereas * pressing cursor right in the R2L segment places the cursor behind * the last character of the R2L segment . However , both caret positions * are at the same logical offset . * < p > * * param logicalOffset offset of the character in the line * param direction direction the caret moved to the specified location . * either ST . COLUMN_NEXT ( right cursor key ) or ST . COLUMN_PREVIOUS ( left cursor key ) . * return the caret position at the specified offset in the line , * taking the direction into account as described above . * / int getCaretPosition ( int logicalOffset , int direction ) { int caretX ; if ( getTextLength ( ) = = 0 ) { return StyledText . XINSET ; } / / at or past end of line ? if ( logicalOffset > = order . length ) { logicalOffset = Math . min ( logicalOffset , order . length - 1 ) ; int visualOffset = order logicalOffset ; if ( isRightToLeft ( logicalOffset ) ) { caretX = renderPositions visualOffset ; } else { caretX = renderPositions visualOffset + dx visualOffset ; } } else / / at beginning of line ? if ( logicalOffset = = 0 ) { int visualOffset = order logicalOffset ; if ( isRightToLeft ( logicalOffset ) ) { caretX = renderPositions visualOffset + dx visualOffset ; } else { caretX = renderPositions visualOffset ; } } else / / consider local numbers as R2L in determining direction boundaries . / / fixes 1GK9API . / / treat user specified direction segments like real direction changes . if ( direction = = ST . COLUMN_NEXT ( isRightToLeftInput ( logicalOffset ) ! = isRightToLeftInput ( logicalOffset - 1 ) isStartOfBidiSegment ( logicalOffset ) ) ) { int visualOffset = order logicalOffset - 1 ; / / moving between segments . / / do not consider local numbers as R2L here , to determine position , / / because local numbers are navigated L2R and we want the caret to / / be to the right of the number . see 1GK9API if ( isRightToLeft ( logicalOffset - 1 ) ) { / / moving from RtoL to LtoR caretX = renderPositions visualOffset ; } else { / / moving from LtoR to RtoL caretX = renderPositions visualOffset + dx visualOffset ; } } else / / consider local numbers as R2L in determining direction boundaries . / / fixes 1GK9API . if ( direction = = ST . COLUMN_PREVIOUS isRightToLeftInput ( logicalOffset ) ! = isRightToLeftInput ( logicalOffset - 1 ) ) { int visualOffset = order logicalOffset ; / / moving between segments . / / consider local numbers as R2L here , to determine position , because / / we want to stay in L2R segment and place the cursor to the left of / / first L2R character . see 1GK9API if ( isRightToLeftInput ( logicalOffset - 1 ) ) { / / moving from LtoR to RtoL caretX = renderPositions visualOffset ; } else { / / moving from RtoL to LtoR caretX = renderPositions visualOffset + dx visualOffset ; } } else if ( isRightToLeft ( logicalOffset ) ) { int visualOffset = order logicalOffset ; caretX = renderPositions visualOffset + dx visualOffset ; } else { caretX = renderPositions order logicalOffset ; } return caretX ; }', '/ * * * Returns the direction segments that are in the specified text * range . The text range may be visually discontiguous if the * text is bidirectional . Each returned direction run has a single * direction and the runs all go from left to right , regardless of * the direction of the text in the segment . User specified segments * ( via BidiSegmentListener ) are taken into account and result in * separate direction runs . * < p > * * param logicalStart offset of the logcial start of the first * direction segment * param length length of the text included in the direction * segments * return the direction segments that are in the specified * text range , each segment has a single direction . * / private Vector getDirectionRuns ( int logicalStart , int length ) { Vector directionRuns = new Vector ( ) ; int logicalEnd = logicalStart + length - 1 ; int segmentLogicalStart = logicalStart ; int segmentLogicalEnd = segmentLogicalStart ; if ( logicalEnd < getTextLength ( ) ) { int bidiSegmentIndex = 0 ; int bidiSegmentEnd = bidiSegments bidiSegmentIndex + 1 ; / / Find the bidi segment that the direction runs start in . / / There will always be at least on bidi segment ( for the entire line ) . while ( bidiSegmentIndex < bidiSegments . length - 2 bidiSegmentEnd < = logicalStart ) { bidiSegmentIndex + + ; bidiSegmentEnd = bidiSegments bidiSegmentIndex + 1 ; } while ( segmentLogicalEnd < = logicalEnd ) { int segType = classBuffer segmentLogicalStart ; / / Search for the end of the direction segment . Each segment needs to / / be rendered separately . / / E . g . , 11211 ( 1 = R2L , 2 = L2R ) , rendering from logical index 0 to 5 / / would be visual 1 to 4 and would thus miss visual 0 . Rendering the / / segments separately would render from visual 1 to 0 , then 2 , then / / 4 to 3 . while ( segmentLogicalEnd < logicalEnd segType = = classBuffer segmentLogicalEnd + 1 segmentLogicalEnd + 1 < bidiSegmentEnd ) { segmentLogicalEnd + + ; } directionRuns . addElement ( new DirectionRun ( segmentLogicalStart , segmentLogicalEnd ) ) ; segmentLogicalStart = + + segmentLogicalEnd ; / / The current direction run ends at a bidi segment end . Get the next bidi segment . if ( segmentLogicalEnd = = bidiSegmentEnd bidiSegmentIndex < bidiSegments . length - 2 ) { bidiSegmentIndex + + ; bidiSegmentEnd = bidiSegments bidiSegmentIndex + 1 ; } } } return directionRuns ; }', '/ * * * Returns the offset of the last character comprising a ligature . * < p > * * return the offset of the last character comprising a ligature . * / int getLigatureEndOffset ( int offset ) { / / assume only bidi languages support ligatures if ( ! isRightToLeft ( offset ) ) return offset ; int newOffset = offset ; int i = offset + 1 ; / / a ligature is a visual character that is comprised of / / multiple logical characters , thus each logical part of / / a ligature will have the same order value while ( i < order . length ( order i = = order offset ) ) { newOffset = i ; i + + ; } return newOffset ; }', '/ * * * Returns the offset of the first character comprising a ligature . * < p > * * return the offset of the first character comprising a ligature . * / int getLigatureStartOffset ( int offset ) { / / assume only bidi languages support ligatures if ( ! isRightToLeft ( offset ) ) return offset ; int newOffset = offset ; int i = offset - 1 ; / / a ligature is a visual character that is comprised of / / multiple logical characters , thus each logical part of / / a ligature will have the same order value while ( i > = 0 ( order i = = order offset ) ) { newOffset = i ; i - - ; } return newOffset ; }', '/ * * * Returns the logical offset of the character at the specified * visual offset . * < p > * * param visualOffset the visual offset * return the logical offset of the character at < code > visualOffset < / code > . * / private int getLogicalOffset ( int visualOffset ) { int logicalOffset = 0 ; while ( logicalOffset < order . length order logicalOffset ! = visualOffset ) { logicalOffset + + ; } return logicalOffset ; }', '/ * * * Returns the offset of the character at the specified x location . * < p > * * param x the location of the character * return the logical offset of the character at the specified x * location . * / int getOffsetAtX ( int x ) { int visualOffset ; if ( getTextLength ( ) = = 0 ) { return 0 ; } if ( x > = renderPositions renderPositions . length - 1 + dx dx . length - 1 ) { / / Return when x is past the end of the line . Fixes 1GLADBK . return - 1 ; } visualOffset = getVisualOffsetAtX ( x ) ; return getLogicalOffset ( visualOffset ) ; }', '/ * * * Returns the visual offset of the character at the specified x * location . * < p > * * param x the location of the character * return the visual offset of the character at the specified x * location . * / private int getVisualOffsetAtX ( int x ) { int lineLength = getTextLength ( ) ; int low = - 1 ; int high = lineLength ; while ( high - low > 1 ) { int offset = ( high + low ) / 2 ; int visualX = renderPositions offset ; / / visualX + dx is the start of the next character . Restrict right / high / / search boundary only if x is before next character . Fixes 1GL4ZVE . if ( x < visualX + dx offset ) { high = offset ; } else if ( high = = lineLength high - offset = = 1 ) { / / requested x location is past end of line high = - 1 ; } else { low = offset ; } } return high ; }', '/ * * * Returns the reordering indices that map between logical and * visual index of characters in the specified range . * < p > * * param start start offset of the reordering indices * param length number of reordering indices to return * return the reordering indices that map between logical and * visual index of characters in the specified range . Relative * to the start of the range . * / private int getRenderIndexesFor ( int start , int length ) { int positions = new int length ; int end = start + length ; for ( int i = start ; i < end ; i + + ) { positions i - start = order i ; } return positions ; }', '/ * * * Break up the given ranges such that each range is fully contained within a bidi * segment . * / private StyleRange segmentedRangesFor ( StyleRange ranges ) { if ( ( bidiSegments = = null ) ( bidiSegments . length = = 0 ) ) return ranges ; Vector newRanges = new Vector ( ) ; int j = 0 ; int startSegment ; int endSegment ; for ( int i = 0 ; i < ranges . length ; i + + ) { int start = ranges i . start ; int end = start + ranges i . length ; startSegment = - 1 ; endSegment = - 1 ; boolean done = false ; while ( j < bidiSegments . length ! done ) { if ( bidiSegments j < = start ) { startSegment = j ; } if ( bidiSegments j > = end ) { endSegment = j - 1 ; j - - ; } done = ( startSegment ! = - 1 ) ( endSegment ! = - 1 ) ; if ( ! done ) j + + ; } if ( startSegment = = endSegment ) { / / range is within one segment StyleRange newStyle = new StyleRange ( start , end - start , null , null ) ; newRanges . addElement ( newStyle ) ; } else if ( startSegment > endSegment ) { / / range is within no segment ( i . e . , it s empty ) } else { / / range spans multiple segments StyleRange newStyle = new StyleRange ( start , bidiSegments startSegment + 1 - start , null , null ) ; newRanges . addElement ( newStyle ) ; startSegment + + ; for ( int k = startSegment ; k < endSegment ; k + + ) { newStyle = new StyleRange ( bidiSegments k , bidiSegments k + 1 - bidiSegments k , null , null ) ; newRanges . addElement ( newStyle ) ; } newStyle = new StyleRange ( bidiSegments endSegment , end - bidiSegments endSegment , null , null ) ; newRanges . addElement ( newStyle ) ; } } StyleRange rangeArray = new StyleRange newRanges . size ( ) ; for ( int i = 0 ; i < newRanges . size ( ) ; i + + ) { rangeArray i = ( StyleRange ) newRanges . elementAt ( i ) ; } return rangeArray ; }', '/ * * * Returns the number of characters in the line . * < p > * * return the number of characters in the line . * / private int getTextLength ( ) { return dx . length ; }', '/ * * * Returns the width in pixels of the line . * < p > * * return the width in pixels of the line . * / int getTextWidth ( ) { int width = 0 ; if ( getTextLength ( ) > 0 ) { width = renderPositions renderPositions . length - 1 + dx dx . length - 1 ; } return width ; }', '/ * * * Returns whether the current platform supports a bidi language . * < p > * * return true = bidi is supported , false otherwise . * / static boolean isBidiPlatform ( ) { return BidiUtil . isBidiPlatform ( ) ; }', '/ * * * Returns whether the font set in the specified gc supports * character shaping . * < p > * * param gc the GC that should be tested for character shaping . * return * true = the font set in the specified gc supports character shaped glyphs * false = the font set in the specified gc doesn t support character shaped glyphs * / static boolean isCharacterShaped ( GC gc ) { return ( BidiUtil . getFontBidiAttributes ( gc ) BidiUtil . GLYPHSHAPE ) ! = 0 ; }', '/ * * * Returns whether the font set in the specified gc contains * ligatured glyphs . * < p > * * param gc the GC that should be tested for ligatures . * return * true = the font set in the specified gc contains ligatured glyphs . * false = the font set in the specified gc doesn t contain ligatured * glyphs . * / static boolean isLigated ( GC gc ) { return ( BidiUtil . getFontBidiAttributes ( gc ) BidiUtil . LIGATE ) ! = 0 ; }', '/ * * * Returns the direction of the character at the specified index . * Used for rendering and caret positioning where local numbers ( e . g . , * national Arabic , or Hindi , numbers ) are considered left - to - right . * < p > * * param logicalIndex the index of the character * return * true = the character at the specified index is in a right - to - left * codepage ( e . g . , Hebrew , Arabic ) . * false = the character at the specified index is in a left - to - right / latin * codepage . * / boolean isRightToLeft ( int logicalIndex ) { boolean isRightToLeft = false ; if ( logicalIndex < classBuffer . length ) { isRightToLeft = ( classBuffer logicalIndex = = BidiUtil . CLASS_ARABIC ) ( classBuffer logicalIndex = = BidiUtil . CLASS_HEBREW ) ; } return isRightToLeft ; }', '/ * * * Returns the direction of the character at the specified index . * Used for setting the keyboard language where local numbers ( e . g . , * national Arabic , or Hindi , numbers ) are considered right - to - left . * < p > * * param logicalIndex the index of the character * return * true = the character at the specified index is in a right - to - left * codepage ( e . g . , Hebrew , Arabic ) . * false = the character at the specified index is in a left - to - right / latin * codepage . * / boolean isRightToLeftInput ( int logicalIndex ) { boolean isRightToLeft = false ; if ( logicalIndex < classBuffer . length ) { isRightToLeft = ( classBuffer logicalIndex = = BidiUtil . CLASS_ARABIC ) ( classBuffer logicalIndex = = BidiUtil . CLASS_HEBREW ) ( classBuffer logicalIndex = = BidiUtil . CLASS_LOCALNUMBER ) ; } return isRightToLeft ; }', '/ * * * Returns whether the specified index is the start of a user * specified direction segment . * < p > * * param logicalIndex the index to test * return true = the specified index is the start of a user specified * direction segment , false otherwise * / private boolean isStartOfBidiSegment ( int logicalIndex ) { for ( int i = 0 ; i < bidiSegments . length ; i + + ) { if ( bidiSegments i = = logicalIndex ) return true ; } return false ; }', '/ * * * Reorders and calculates render positions for the specified sub - line * of text . The results will be merged with the data for the rest of * the line . * < p > * * param textline the entire line of text that this object represents . * param logicalStart the start offset of the first character to * reorder . * param length the number of characters to reorder * / private void prepareFontStyledText ( String textline , int logicalStart , int length ) { int byteCount = length ; int flags = 0 ; String text = textline . substring ( logicalStart , logicalStart + length ) ; / / Figure out what is before and after the substring so that the proper character / / shaping will occur . Character shaping will not occur across bidi segments , so / / if the styled text starts or ends on a bidi segment , do not process the text / / for character shaping . if ( logicalStart ! = 0 isCharacterShaped ( gc ) ! isStartOfBidiSegment ( logicalStart ) ! Compatibility . isWhitespace ( textline . charAt ( logicalStart - 1 ) ) isRightToLeft ( logicalStart - 1 ) ) { / / if the start of the substring is not the beginning of the / / text line , check to see what is before the string flags = BidiUtil . LINKBEFORE ; } if ( ( logicalStart + byteCount ) ! = dx . length isCharacterShaped ( gc ) ! isStartOfBidiSegment ( logicalStart + length ) ! Compatibility . isWhitespace ( textline . charAt ( logicalStart + byteCount ) ) isRightToLeft ( logicalStart + byteCount ) ) { / / if the end of the substring is not the end of the text line , / / check to see what is after the substring flags = BidiUtil . LINKAFTER ; } / / set classification values for the substring flags = BidiUtil . CLASSIN ; byte classArray = new byte byteCount ; int renderIndexes = getRenderIndexesFor ( logicalStart , byteCount ) ; for ( int i = 0 ; i < byteCount ; i + + ) { classArray i = classBuffer renderIndexes i ; } int dxArray = new int byteCount ; int orderArray = new int byteCount ; BidiUtil . getRenderInfo ( gc , text , orderArray , classArray , dxArray , flags , new int { 0 , text . length ( ) } ) ; / / update the existing dx array with the new dx values based on the bold font for ( int i = 0 ; i < dxArray . length ; i + + ) { int dxValue = dxArray orderArray i ; int visualIndex = renderIndexes i ; dx visualIndex = dxValue ; } }', '/ * * * Redraws a rectangle spanning the given logical range . * The rectangle may be visually discontiguous if the text segment * is bidirectional . * < p > * * param parent window that should be invalidated * param logicalStart logcial start offset of the rectangle * param length number of logical characters the rectangle should span * param xOffset x location of the line start * param yOffset y location of the line start * param height height of the invalidated rectangle * / void redrawRange ( Control parent , int logicalStart , int length , int xOffset , int yOffset , int height ) { Enumeration directionRuns = getDirectionRuns ( logicalStart , length ) . elements ( ) ; if ( logicalStart + length > getTextLength ( ) ) { return ; } while ( directionRuns . hasMoreElements ( ) ) { DirectionRun run = ( DirectionRun ) directionRuns . nextElement ( ) ; int startX = run . getRenderStartX ( ) ; parent . redraw ( xOffset + startX , yOffset , run . getRenderStopX ( ) - startX , height , true ) ; } }', '/ * * * Sets the keyboard language to match the codepage of the character * at the specified offset . * Only distinguishes between left - to - right and right - to - left * characters and sets the keyboard language to one of Latin , Hebrew * and Arabic . * < p > * * param logicalIndex logical offset of the character to use for * determining the new keyboard language . * / void setKeyboardLanguage ( int logicalIndex ) { int language = BidiUtil . KEYBOARD_LATIN ; if ( logicalIndex > = classBuffer . length ) { return ; } if ( isRightToLeftInput ( logicalIndex ) ) { String codePage = System . getProperty ( "file . encoding" ) . toUpperCase ( ) ; if ( "CP1255" . equals ( codePage ) ) { language = BidiUtil . KEYBOARD_HEBREW ; } else if ( "CP1256" . equals ( codePage ) ) { language = BidiUtil . KEYBOARD_ARABIC ; } } BidiUtil . setKeyboardLanguage ( language ) ; }', '/ * * * Returns a string representation of the receiver . * < p > * * return a string representation of the receiver for * debugging purposes . The output order of the StyledTextbidi values * is as follows : order , render position , dx , character class , glyphs . * / public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "StyledTextBidi { { " ) ; / / order for ( int i = 0 ; i < order . length ; i + + ) { if ( i ! = 0 ) { buf . append ( " , " ) ; } buf . append ( order i ) ; } buf . append ( " } , { " ) ; / / render positions for ( int i = 0 ; i < renderPositions . length ; i + + ) { if ( i ! = 0 ) { buf . append ( " , " ) ; } buf . append ( renderPositions i ) ; } buf . append ( " } , { " ) ; / / dx for ( int i = 0 ; i < dx . length ; i + + ) { if ( i ! = 0 ) { buf . append ( " , " ) ; } buf . append ( dx i ) ; } buf . append ( " } , { " ) ; / / character class for ( int i = 0 ; i < classBuffer . length ; i + + ) { if ( i ! = 0 ) { buf . append ( " , " ) ; } buf . append ( classBuffer i ) ; } buf . append ( " } , { " ) ; / / glyphs buf . append ( glyphBuffer ) ; buf . append ( " } } " ) ; return buf . toString ( ) ; }'], 'label': 0}
{'guid': '1839d9b_ac8733b45c2de912e3396cb3ead3f7158aa856a6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Called by StyledText to add itself as an Observer to content changes . * Implementors should send a TextChangingEvent when changes to the content * are about to occur and a TextChangedEvent when the changes did occur . * The widget only updates the screen properly when it receives both events . * < p > * * param listener the listener * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void addTextChangeListener ( TextChangeListener listener ) ;', '/ * * * Return the number of characters in the content . * < p > * * return the number of characters in the content . * / public int getCharCount ( ) ;', '/ * * * Return the line at the given line index without delimiters . * < p > * * param lineIndex index of the line to return . Does not include delimiters * of preceeding lines . Index 0 is the first line of the content . * return the line text without delimiters * / public String getLine ( int lineIndex ) ;', '/ * * * Return the line index at the given character offset . * < p > * * param offset offset of the line to return . The first character of the document * is at offset 0 . An offset of getLength ( ) is valid and should answer * the number of lines . * return the line index . The first line is at index 0 . If the character at offset * is a delimiter character , answer the line index of the line that is delimited . * For example , if text = " r n r n" , and delimiter = " r n" , then : * < ul > * < li > getLineAtOffset ( 0 ) = = 0 * < li > getLineAtOffset ( 1 ) = = 0 * < li > getLineAtOffset ( 2 ) = = 1 * < li > getLineAtOffset ( 3 ) = = 1 * < li > getLineAtOffset ( 4 ) = = 2 * < / ul > * / public int getLineAtOffset ( int offset ) ;', '/ * * * Return the number of lines . Should answer 1 when no text is specified . * The StyledText widget relies on this behavior for drawing the cursor . * < p > * * return the number of lines . For example : * < ul > * < li > text value = = > getLineCount * < li > null = = > 1 * < li > "" = = > 1 * < li > "a n" = = > 2 * < li > " n n" = = > 3 * < / ul > * / public int getLineCount ( ) ;', '/ * * * Return the line delimiter that should be used by the StyledText * widget when inserting new lines . New lines entered using key strokes * and paste operations use this line delimiter . * Implementors may use System . getProperty ( "line . separator" ) to return * the platform line delimiter . * < p > * * return the line delimiter that should be used by the StyledText widget * when inserting new lines . * / public String getLineDelimiter ( ) ;', '/ * * * Return the character offset of the first character of the given line . * < p > * < b > NOTE : < / b > When there is no text ( i . e . , no lines ) , getOffsetAtLine ( 0 ) * is a valid call that should return 0 . * < / p > * * param lineIndex index of the line . The first line is at index 0 . * return offset offset of the first character of the line . The first character * of the document is at offset 0 . The return value should include * line delimiters . For example , if text = " r ntest r n" and delimiter = " r n" , * then : * < ul > * < li > getOffsetAtLine ( 0 ) = = 0 * < li > getOffsetAtLine ( 1 ) = = 2 * < li > getOffsetAtLine ( 2 ) = = 8 * < / ul > * / public int getOffsetAtLine ( int lineIndex ) ;', '/ * * * Returns a string representing the content at the given range . * < p > * * param start the start offset of the text to return . Offset 0 is the first * character of the document . * param length the length of the text to return * return the text at the given range * / public String getTextRange ( int start , int length ) ;', '/ * * * Remove the specified text changed listener . * < p > * * param listener the listener * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > * < / ul > * / public void removeTextChangeListener ( TextChangeListener listener ) ;', '/ * * * Replace the text with "newText" starting at position "start" * for a length of "replaceLength" . * < p > * Implementors have to notify the TextChangeListeners that were added * using < code > addTextChangeListener < / code > before and after the content * is changed . A < code > TextChangingEvent < / code > has to be sent before the * content is changed and a < code > TextChangedEvent < / code > has to be sent * after the content has changed . * The text change that occurs after the < code > TextChangingEvent < / code > * has been sent has to be consistent with the data provided in the * < code > TextChangingEvent < / code > . * This data will be cached by the widget and will be used when the * < code > TextChangedEvent < / code > is received . * < p > * The < code > TextChangingEvent < / code > should be set as follows : * < ul > * < li > event . start = start of the replaced text * < li > event . newText = text that is going to be inserted or empty String * if no text will be inserted * < li > event . replaceCharCount = length of text that is going to be replaced * < li > event . newCharCount = length of text that is going to be inserted * < li > event . replaceLineCount = number of lines that are going to be replaced * < li > event . newLineCount = number of new lines that are going to be inserted * < / ul > * < b > NOTE : < / b > newLineCount is the number of inserted lines and replaceLineCount is * the number of deleted lines based on the change that occurs visually . For * example : * < ul > * < li > ( replaceText , newText ) = = > ( replaceLineCount , newLineCount ) * < li > ( "" , " n" ) = = > ( 0 , 1 ) * < li > ( " n n" , "a" ) = = > ( 2 , 0 ) * < li > ( "a" , " n n" ) = = > ( 0 , 2 ) * < li > ( " n" , "" ) = = > ( 1 , 0 ) * < / ul > * < / p > * * param start start offset of text to replace , none of the offsets include * delimiters of preceeding lines , offset 0 is the first character of the document * param replaceLength start offset of text to replace * param newText start offset of text to replace * / public void replaceTextRange ( int start , int replaceLength , String text ) ;', '/ * * * Set text to "text" . * Implementors have to send a < code > TextChangedEvent < / code > to the * TextChangeListeners that were added using < code > addTextChangeListener < / code > . * < p > * * param text the new text * / public void setText ( String text ) ;'], 'label': 0}
{'guid': '1839d9b_5fd9e16754941218919702837004c2f42a12e3d4', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['StyledTextEvent ( StyledTextContent content ) { super ( ) ; data = content ; }'], 'label': 0}
{'guid': '1839d9b_a708fa0334921a945ea468b0f438aeaefbd82263', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * / StyledTextListener ( SWTEventListener listener ) { super ( listener ) ; }', '/ * * * Process StyledText events by invoking the event s handler . * / public void handleEvent ( Event e ) { TextChangedEvent textChangedEvent ; switch ( e . type ) { case StyledText . ExtendedModify : ExtendedModifyEvent extendedModifyEvent = new ExtendedModifyEvent ( ( StyledTextEvent ) e ) ; ( ( ExtendedModifyListener ) eventListener ) . modifyText ( extendedModifyEvent ) ; break ; case StyledText . LineGetBackground : LineBackgroundEvent lineBgEvent = new LineBackgroundEvent ( ( StyledTextEvent ) e ) ; ( ( LineBackgroundListener ) eventListener ) . lineGetBackground ( lineBgEvent ) ; ( ( StyledTextEvent ) e ) . lineBackground = lineBgEvent . lineBackground ; break ; case StyledText . LineGetSegments : BidiSegmentEvent segmentEvent = new BidiSegmentEvent ( ( StyledTextEvent ) e ) ; ( ( BidiSegmentListener ) eventListener ) . lineGetSegments ( segmentEvent ) ; ( ( StyledTextEvent ) e ) . segments = segmentEvent . segments ; break ; case StyledText . LineGetStyle : LineStyleEvent lineStyleEvent = new LineStyleEvent ( ( StyledTextEvent ) e ) ; ( ( LineStyleListener ) eventListener ) . lineGetStyle ( lineStyleEvent ) ; ( ( StyledTextEvent ) e ) . styles = lineStyleEvent . styles ; break ; case StyledText . VerifyKey : VerifyEvent verifyEvent = new VerifyEvent ( e ) ; ( ( VerifyKeyListener ) eventListener ) . verifyKey ( verifyEvent ) ; e . doit = verifyEvent . doit ; break ; case StyledText . TextChanged : textChangedEvent = new TextChangedEvent ( ( StyledTextContent ) e . data ) ; ( ( TextChangeListener ) eventListener ) . textChanged ( textChangedEvent ) ; break ; case StyledText . TextChanging : TextChangingEvent textChangingEvent = new TextChangingEvent ( ( StyledTextContent ) e . data , ( StyledTextEvent ) e ) ; ( ( TextChangeListener ) eventListener ) . textChanging ( textChangingEvent ) ; break ; case StyledText . TextSet : textChangedEvent = new TextChangedEvent ( ( StyledTextContent ) e . data ) ; ( ( TextChangeListener ) eventListener ) . textSet ( textChangedEvent ) ; break ; } }'], 'label': 0}
{'guid': '1839d9b_b333851d67d02a6726649421617b79b4d82d2bdb', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['static void print ( StyledText styledText ) { Printer printer = new Printer ( ) ; new StyledTextPrinter ( styledText , printer ) . run ( ) ; printer . dispose ( ) ; }', 'StyledTextPrinter ( StyledText styledText , Printer printer ) { this . printer = printer ; PrinterData data = printer . getPrinterData ( ) ; startPage = 1 ; endPage = Integer . MAX_VALUE ; if ( data . scope = = PrinterData . PAGE_RANGE ) { startPage = data . startPage ; endPage = data . endPage ; } / * Create a buffer for computing tab width . * / int tabSize = styledText . getTabs ( ) ; StringBuffer tabBuffer = new StringBuffer ( tabSize ) ; for ( int i = 0 ; i < tabSize ; i + + ) tabBuffer . append ( ) ; tabs = tabBuffer . toString ( ) ; / * Get RTF from the StyledText . * / rtf = styledText . getRtf ( ) ; }', 'public void run ( ) { if ( printer . startJob ( "Printing" ) ) { Rectangle clientArea = printer . getClientArea ( ) ; Rectangle trim = printer . computeTrim ( 0 , 0 , 0 , 0 ) ; Point dpi = printer . getDPI ( ) ; leftMargin = dpi . x + trim . x ; / / one inch from left side of paper rightMargin = clientArea . width - dpi . x + trim . x + trim . width ; / / one inch from right side of paper topMargin = dpi . y + trim . y ; / / one inch from top edge of paper bottomMargin = clientArea . height - dpi . y + trim . y + trim . height ; / / one inch from bottom edge of paper / * Create a printer GC and print the RTF to it . * / gc = new GC ( printer ) ; x = leftMargin ; y = topMargin ; currentPage = 1 ; if ( startPage = = 1 ) { printer . startPage ( ) ; } end = rtf . length ( ) ; index = 0 ; wordBuffer = new StringBuffer ( ) ; while ( index < end ) { char c = rtf . charAt ( index ) ; index + + ; switch ( c ) { case : printWordBuffer ( ) ; parseControlWord ( ) ; break ; case { : printWordBuffer ( ) ; saveState ( ) ; break ; case } : printWordBuffer ( ) ; restoreState ( ) ; break ; case 0x0a : case 0x0d : printWordBuffer ( ) ; break ; default : parseChar ( c ) ; } } if ( y + lineHeight < = bottomMargin ) { printer . endPage ( ) ; } printer . endJob ( ) ; / * Cleanup * / gc . dispose ( ) ; for ( int i = 0 ; i < 4 ; i + + ) { fontTable currentFont i . dispose ( ) ; } for ( int i = 0 ; i < colorTable . size ( ) ; i + + ) { ( ( Color ) colorTable . elementAt ( i ) ) . dispose ( ) ; } } }', 'void parseControlWord ( ) { if ( index > = end ) return ; char c = rtf . charAt ( index ) ; index + + ; if ( ! Compatibility . isLetter ( c ) ) { handleControlSymbol ( c ) ; return ; } StringBuffer controlWord = new StringBuffer ( ) ; controlWord . append ( c ) ; while ( index < end ) { c = rtf . charAt ( index ) ; index + + ; if ( ! Compatibility . isLetter ( c ) ) break ; controlWord . append ( c ) ; } boolean isNegative = false ; if ( c = = - ) { isNegative = true ; c = rtf . charAt ( index ) ; index + + ; } boolean hasParameter = false ; StringBuffer paramBuffer = new StringBuffer ( ) ; int parameter = 0 ; if ( Character . isDigit ( c ) ) { hasParameter = true ; paramBuffer . append ( c ) ; while ( index < end ) { c = rtf . charAt ( index ) ; index + + ; if ( ! Character . isDigit ( c ) ) break ; paramBuffer . append ( c ) ; } try { parameter = Integer . valueOf ( paramBuffer . toString ( ) ) . intValue ( ) ; } catch ( NumberFormatException e ) { } if ( isNegative ) parameter = - parameter ; } if ( c ! = ) index - - ; if ( hasParameter ) { handleControlWord ( controlWord . toString ( ) , parameter ) ; } else { handleControlWord ( controlWord . toString ( ) ) ; } }', 'void parseChar ( char c ) { if ( c = = 0 ) return ; if ( c = = ; ) { if ( creatingFontTable ) { fontName = wordBuffer . toString ( ) ; wordBuffer = new StringBuffer ( ) ; creatingFontTable = false ; return ; } if ( creatingColorTable ) { colorTable . addElement ( new Color ( printer , red , green , blue ) ) ; red = green = blue = 0 ; return ; } } if ( c ! = t ) { wordBuffer . append ( c ) ; } if ( ! Compatibility . isLetterOrDigit ( c ) ! creatingFontTable ) { printWordBuffer ( ) ; if ( c = = t ) { x + = tabWidth ; } } }', 'void printWordBuffer ( ) { if ( wordBuffer . length ( ) > 0 ) { String word = wordBuffer . toString ( ) ; int wordWidth = gc . stringExtent ( word ) . x ; if ( x + wordWidth > rightMargin ) { / * word doesn t fit on current line , so wrap * / newline ( ) ; } if ( currentPage > = startPage currentPage < = endPage ) { gc . drawString ( word , x , y , true ) ; } x + = wordWidth ; wordBuffer = new StringBuffer ( ) ; } }', 'void handleControlSymbol ( char c ) { switch ( c ) { case : case { : case } : parseChar ( c ) ; } }', 'void handleControlWord ( String controlWord ) { if ( controlWord . equals ( "par" ) ) newline ( ) ; else if ( controlWord . equals ( "b" ) ) setFontStyle ( currentFontStyle SWT . BOLD ) ; else if ( controlWord . equals ( "i" ) ) setFontStyle ( currentFontStyle SWT . ITALIC ) ; else if ( controlWord . equals ( "fnil" ) ) setFont ( defaultFont ) ; else if ( controlWord . equals ( "fonttbl" ) ) createFontTable ( ) ; else if ( controlWord . equals ( "colortbl" ) ) createColorTable ( ) ; }', 'void handleControlWord ( String controlWord , int parameter ) { if ( controlWord . equals ( "highlight" ) ) setBackground ( parameter ) ; else if ( controlWord . equals ( "cf" ) ) setForeground ( parameter ) ; else if ( controlWord . equals ( "b" ) ) setFontStyle ( currentFontStyle SWT . BOLD ) ; else if ( controlWord . equals ( "i" ) ) setFontStyle ( currentFontStyle SWT . ITALIC ) ; else if ( controlWord . equals ( "f" ) ) setFont ( parameter ) ; else if ( controlWord . equals ( "fs" ) ) setFontSize ( parameter ) ; else if ( controlWord . equals ( "red" ) ) red = parameter ; else if ( controlWord . equals ( "green" ) ) green = parameter ; else if ( controlWord . equals ( "blue" ) ) blue = parameter ; else if ( controlWord . equals ( "deff" ) ) setDefaultFont ( parameter ) ; }', 'void setDefaultFont ( int number ) { defaultFont = number ; }', 'void setFont ( int number ) { currentFont = number ; }', 'void createFontTable ( ) { creatingFontTable = true ; currentFont = 0 ; }', 'void setFontSize ( int size ) { fontSize = size / 2 ; createFonts ( ) ; }', 'void createFonts ( ) { if ( fontName ! = null fontSize ! = - 1 ) { / / currentFont must already be set fontTable currentFont 0 = new Font ( printer , fontName , fontSize , SWT . NORMAL ) ; fontTable currentFont 1 = new Font ( printer , fontName , fontSize , SWT . BOLD ) ; fontTable currentFont 2 = new Font ( printer , fontName , fontSize , SWT . ITALIC ) ; fontTable currentFont 3 = new Font ( printer , fontName , fontSize , SWT . BOLD SWT . ITALIC ) ; setFontStyle ( SWT . NORMAL ) ; } }', 'void setFontStyle ( int style ) { / / currentFont must already be set Font font ; if ( ( style SWT . BOLD ) ! = 0 ) { if ( ( style SWT . ITALIC ) ! = 0 ) { font = fontTable currentFont 3 ; } else { font = fontTable currentFont 1 ; } } else if ( ( style SWT . ITALIC ) ! = 0 ) { font = fontTable currentFont 2 ; } else { font = fontTable currentFont 0 ; } gc . setFont ( font ) ; tabWidth = gc . stringExtent ( tabs ) . x ; lineHeight = gc . getFontMetrics ( ) . getHeight ( ) ; currentFontStyle = style ; }', 'void createColorTable ( ) { creatingColorTable = true ; red = green = blue = 0 ; }', 'void setForeground ( int color ) { if ( color ! = currentForeground ) { / / colors must already be in table gc . setForeground ( ( Color ) colorTable . elementAt ( color ) ) ; currentForeground = color ; } }', 'void setBackground ( int color ) { if ( color ! = currentBackground ) { / / colors must already be in table gc . setBackground ( ( Color ) colorTable . elementAt ( color ) ) ; currentBackground = color ; } }', 'void newline ( ) { x = leftMargin ; y + = lineHeight ; if ( y + lineHeight > bottomMargin ) { printer . endPage ( ) ; if ( index + 1 < end ) { y = topMargin ; currentPage + + ; if ( currentPage > = startPage currentPage < = endPage ) { printer . startPage ( ) ; } } } }', 'void saveState ( ) { RTFState state = new RTFState ( ) ; state . fontStyle = currentFontStyle ; state . foreground = currentForeground ; state . background = currentBackground ; savedState . addElement ( state ) ; }', 'void restoreState ( ) { if ( savedState . isEmpty ( ) ) return ; if ( creatingColorTable ) { setForeground ( 0 ) ; setBackground ( 1 ) ; creatingColorTable = false ; } int index = savedState . size ( ) - 1 ; RTFState state = ( RTFState ) savedState . elementAt ( index ) ; savedState . removeElementAt ( index ) ; setFontStyle ( state . fontStyle ) ; if ( state . foreground ! = - 1 ) setForeground ( state . foreground ) ; if ( state . background ! = - 1 ) setBackground ( state . background ) ; }'], 'label': 0}
{'guid': '1839d9b_cd3cdd3349e0196ff11f219b63c5df8f84b5cc79', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * table and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a Table control which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < li > ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass < / li > * < / ul > * * see SWT * see Widget checkSubclass * see Widget getStyle * / public TableCursor ( Table parent , int style ) { super ( parent , style ) ; table = parent ; Listener listener = new Listener ( ) { public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . Dispose : dispose ( event ) ; break ; case SWT . KeyDown : keyDown ( event ) ; break ; case SWT . Paint : paint ( event ) ; break ; case SWT . Traverse : traverse ( event ) ; break ; } } } ; addListener ( SWT . Dispose , listener ) ; addListener ( SWT . KeyDown , listener ) ; addListener ( SWT . Paint , listener ) ; addListener ( SWT . Traverse , listener ) ; tableListener = new Listener ( ) { public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . MouseDown : tableMouseDown ( event ) ; break ; case SWT . FocusIn : tableFocusIn ( event ) ; break ; } } } ; table . addListener ( SWT . FocusIn , tableListener ) ; table . addListener ( SWT . MouseDown , tableListener ) ; resizeListener = new Listener ( ) { public void handleEvent ( Event event ) { resize ( ) ; } } ; int columns = table . getColumnCount ( ) ; for ( int i = 0 ; i < columns ; i + + ) { TableColumn column = table . getColumn ( i ) ; column . addListener ( SWT . Resize , resizeListener ) ; } ScrollBar hBar = table . getHorizontalBar ( ) ; if ( hBar ! = null ) { hBar . addListener ( SWT . Selection , resizeListener ) ; } ScrollBar vBar = table . getVerticalBar ( ) ; if ( vBar ! = null ) { vBar . addListener ( SWT . Selection , resizeListener ) ; } }', 'public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . Dispose : dispose ( event ) ; break ; case SWT . KeyDown : keyDown ( event ) ; break ; case SWT . Paint : paint ( event ) ; break ; case SWT . Traverse : traverse ( event ) ; break ; } }', 'public void handleEvent ( Event event ) { switch ( event . type ) { case SWT . MouseDown : tableMouseDown ( event ) ; break ; case SWT . FocusIn : tableFocusIn ( event ) ; break ; } }', 'public void handleEvent ( Event event ) { resize ( ) ; }', '/ * * * Adds the listener to the collection of listeners who will * be notified when the receiver s selection changes , by sending * it one of the messages defined in the < code > SelectionListener < / code > * interface . * < p > * When < code > widgetSelected < / code > is called , the item field of the event object is valid . * If the reciever has < code > SWT . CHECK < / code > style set and the check selection changes , * the event object detail field contains the value < code > SWT . CHECK < / code > . * < code > widgetDefaultSelected < / code > is typically called when an item is double - clicked . * < / p > * * param listener the listener which should be notified * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the listener is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * * see SelectionListener * see removeSelectionListener * see SelectionEvent * / public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Selection , typedListener ) ; addListener ( SWT . DefaultSelection , typedListener ) ; }', 'void dispose ( Event event ) { Display display = getDisplay ( ) ; display . asyncExec ( new Runnable ( ) { public void run ( ) { if ( table . isDisposed ( ) ) return ; table . removeListener ( SWT . FocusIn , tableListener ) ; table . removeListener ( SWT . MouseDown , tableListener ) ; int columns = table . getColumnCount ( ) ; for ( int i = 0 ; i < columns ; i + + ) { TableColumn column = table . getColumn ( i ) ; column . removeListener ( SWT . Resize , resizeListener ) ; } ScrollBar hBar = table . getHorizontalBar ( ) ; if ( hBar ! = null ) { hBar . removeListener ( SWT . Selection , resizeListener ) ; } ScrollBar vBar = table . getVerticalBar ( ) ; if ( vBar ! = null ) { vBar . removeListener ( SWT . Selection , resizeListener ) ; } } } ) ; }', 'public void run ( ) { if ( table . isDisposed ( ) ) return ; table . removeListener ( SWT . FocusIn , tableListener ) ; table . removeListener ( SWT . MouseDown , tableListener ) ; int columns = table . getColumnCount ( ) ; for ( int i = 0 ; i < columns ; i + + ) { TableColumn column = table . getColumn ( i ) ; column . removeListener ( SWT . Resize , resizeListener ) ; } ScrollBar hBar = table . getHorizontalBar ( ) ; if ( hBar ! = null ) { hBar . removeListener ( SWT . Selection , resizeListener ) ; } ScrollBar vBar = table . getVerticalBar ( ) ; if ( vBar ! = null ) { vBar . removeListener ( SWT . Selection , resizeListener ) ; } }', 'void keyDown ( Event event ) { switch ( event . character ) { case SWT . CR : notifyListeners ( SWT . DefaultSelection , new Event ( ) ) ; return ; } switch ( event . keyCode ) { case SWT . ARROW_UP : setRowColumn ( row - 1 , column , true ) ; break ; case SWT . ARROW_DOWN : setRowColumn ( row + 1 , column , true ) ; break ; case SWT . ARROW_LEFT : setRowColumn ( row , column - 1 , true ) ; break ; case SWT . ARROW_RIGHT : setRowColumn ( row , column + 1 , true ) ; break ; case SWT . HOME : setRowColumn ( 0 , column , true ) ; break ; case SWT . END : { int row = table . getItemCount ( ) - 1 ; setRowColumn ( row , column , true ) ; break ; } case SWT . PAGE_UP : { int index = table . getTopIndex ( ) ; if ( index = = row ) { Rectangle rect = table . getClientArea ( ) ; TableItem item = table . getItem ( index ) ; Rectangle itemRect = item . getBounds ( 0 ) ; rect . height - = itemRect . y ; int height = table . getItemHeight ( ) ; int page = Math . max ( 1 , rect . height / height ) ; index = Math . max ( 0 , index - page + 1 ) ; } setRowColumn ( index , column , true ) ; break ; } case SWT . PAGE_DOWN : { int index = table . getTopIndex ( ) ; Rectangle rect = table . getClientArea ( ) ; TableItem item = table . getItem ( index ) ; Rectangle itemRect = item . getBounds ( 0 ) ; rect . height - = itemRect . y ; int height = table . getItemHeight ( ) ; int page = Math . max ( 1 , rect . height / height ) ; int end = table . getItemCount ( ) - 1 ; index = Math . min ( end , index + page - 1 ) ; if ( index = = row ) { index = Math . min ( end , index + page - 1 ) ; } setRowColumn ( index , column , true ) ; break ; } } }', 'void paint ( Event event ) { GC gc = event . gc ; Display display = getDisplay ( ) ; gc . setBackground ( display . getSystemColor ( SWT . COLOR_LIST_SELECTION_TEXT ) ) ; gc . setForeground ( display . getSystemColor ( SWT . COLOR_LIST_SELECTION ) ) ; gc . fillRectangle ( event . x , event . y , event . width , event . height ) ; TableItem item = table . getItem ( row ) ; int x = 0 , y = 0 ; Point size = getSize ( ) ; Image image = item . getImage ( column ) ; if ( image ! = null ) { Rectangle imageSize = image . getBounds ( ) ; int imageY = y + ( int ) ( ( ( float ) size . y - ( float ) imageSize . height ) / 2 . 0 ) ; gc . drawImage ( image , x , imageY ) ; x + = imageSize . width ; } x + = ( column = = 0 ) ? 2 : 6 ; int textY = y + ( int ) ( ( ( float ) size . y - ( float ) gc . getFontMetrics ( ) . getHeight ( ) ) / 2 . 0 ) ; gc . drawString ( item . getText ( column ) , x , textY ) ; if ( isFocusControl ( ) ) { gc . setBackground ( display . getSystemColor ( SWT . COLOR_BLACK ) ) ; gc . setForeground ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; gc . drawFocus ( 0 , 0 , size . x , size . y ) ; } }', 'void tableFocusIn ( Event event ) { if ( isDisposed ( ) ) return ; if ( isVisible ( ) ) setFocus ( ) ; }', 'void tableMouseDown ( Event event ) { if ( isDisposed ( ) ! isVisible ( ) ) return ; Point pt = new Point ( event . x , event . y ) ; Rectangle clientRect = table . getClientArea ( ) ; int columns = table . getColumnCount ( ) ; int start = table . getTopIndex ( ) ; int end = table . getItemCount ( ) ; for ( int row = start ; row < end ; row + + ) { TableItem item = table . getItem ( row ) ; for ( int column = 0 ; column < columns ; column + + ) { Rectangle rect = item . getBounds ( column ) ; if ( rect . y > clientRect . y + clientRect . height ) return ; if ( rect . contains ( pt ) ) { setRowColumn ( row , column , true ) ; setFocus ( ) ; return ; } } } }', 'void traverse ( Event event ) { switch ( event . detail ) { case SWT . TRAVERSE_ARROW_NEXT : case SWT . TRAVERSE_ARROW_PREVIOUS : case SWT . TRAVERSE_RETURN : event . doit = false ; return ; } event . doit = true ; }', 'void setRowColumn ( int row , int column , boolean notify ) { if ( 0 < = row row < table . getItemCount ( ) ) { if ( 0 < = column column < table . getColumnCount ( ) ) { this . row = row ; this . column = column ; TableItem item = table . getItem ( row ) ; table . showItem ( item ) ; setBounds ( item . getBounds ( column ) ) ; redraw ( ) ; if ( notify ) { notifyListeners ( SWT . Selection , new Event ( ) ) ; } } } }', 'public void setVisible ( boolean visible ) { checkWidget ( ) ; if ( visible ) resize ( ) ; super . setVisible ( visible ) ; }', 'void resize ( ) { TableItem item = table . getItem ( row ) ; setBounds ( item . getBounds ( column ) ) ; }', '/ * * * Returns the column over which the TableCursor is positioned . * * return the column for the current position * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public int getColumn ( ) { checkWidget ( ) ; return column ; }', '/ * * * Returns the row over which the TableCursor is positioned . * * return the item for the current position * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public TableItem getRow ( ) { checkWidget ( ) ; return table . getItem ( row ) ; }', '/ * * * Positions the TableCursor over the cell at the given row and column in the parent table . * * param row the index of the row for the cell to select * param column the index of column for the cell to select * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * * / public void setSelection ( int row , int column ) { checkWidget ( ) ; if ( row < 0 row > = table . getItemCount ( ) column < 0 column > = table . getColumnCount ( ) ) SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; setRowColumn ( row , column , false ) ; }', '/ * * * Positions the TableCursor over the cell at the given row and column in the parent table . * * param row the TableItem of the row for the cell to select * param column the index of column for the cell to select * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * * / public void setSelection ( TableItem row , int column ) { checkWidget ( ) ; if ( row = = null row . isDisposed ( ) column < 0 column > = table . getColumnCount ( ) ) SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; setRowColumn ( table . indexOf ( row ) , column , false ) ; }'], 'label': 0}
{'guid': '1839d9b_1fdca24770b798dd028d566e946ad2c9031a40cf', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a TableEditor for the specified Table . * * param table the Table Control above which this editor will be displayed * * / public TableEditor ( Table table ) { super ( table ) ; this . table = table ; columnListener = new Listener ( ) { public void handleEvent ( Event e ) { resize ( ) ; } } ; }', 'public void handleEvent ( Event e ) { resize ( ) ; }', 'Rectangle computeBounds ( ) { if ( item = = null column = = - 1 item . isDisposed ( ) ) return new Rectangle ( 0 , 0 , 0 , 0 ) ; Rectangle cell = item . getBounds ( column ) ; Rectangle editorRect = new Rectangle ( cell . x , cell . y , minimumWidth , cell . height ) ; Rectangle area = table . getClientArea ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . width - cell . x ; } } if ( grabHorizontal ) { editorRect . width = Math . max ( cell . width , minimumWidth ) ; } if ( horizontalAlignment = = SWT . RIGHT ) { editorRect . x + = cell . width - editorRect . width ; } else if ( horizontalAlignment = = SWT . LEFT ) { / / do nothing - cell . x is the right answer } else { / / default is CENTER editorRect . x + = ( cell . width - editorRect . width ) / 2 ; } return editorRect ; }', '/ * * * Removes all associations between the TableEditor and the cell in the table . The * Table and the editor Control are < b > not < / b > disposed . * / public void dispose ( ) { if ( this . column > - 1 this . column < table . getColumnCount ( ) ) { TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . removeListener ( SWT . Resize , columnListener ) ; tableColumn . removeListener ( SWT . Move , columnListener ) ; } table = null ; item = null ; column = - 1 ; super . dispose ( ) ; }', '/ * * * Returns the zero based index of the column of the cell being tracked by this editor . * * return the zero based index of the column of the cell being tracked by this editor * / public int getColumn ( ) { return column ; }', 'public void setColumn ( int column ) { if ( this . column > - 1 this . column < table . getColumnCount ( ) ) { TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . removeListener ( SWT . Resize , columnListener ) ; tableColumn . removeListener ( SWT . Move , columnListener ) ; this . column = - 1 ; } if ( column < 0 column > = table . getColumnCount ( ) ) return ; this . column = column ; TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . addListener ( SWT . Resize , columnListener ) ; tableColumn . addListener ( SWT . Move , columnListener ) ; }', '/ * * * Returns the TableItem for the row of the cell being tracked by this editor . * * return the TableItem for the row of the cell being tracked by this editor * / public TableItem getItem ( ) { return item ; }', 'public void setItem ( TableItem item ) { this . item = item ; }', 'public void setEditor ( Control editor ) { TableItem item = null ; if ( table . getItemCount ( ) > 0 ) { item = table . getItem ( 0 ) ; } this . setEditor ( editor , item , 0 ) ; }', '/ * * * Specify the Control that is to be displayed and the cell in the table that it is to be positioned above . * * < p > Note : The Control provided as the editor < b > must < / b > be created with its parent being the Table control * specified in the TableEditor constructor . * * param editor the Control that is displayed above the cell being edited * param item the TableItem for the row of the cell being tracked by this editor * param column the zero based index of the column of the cell being tracked by this editor * / public void setEditor ( Control editor , TableItem item , int column ) { setItem ( item ) ; setColumn ( column ) ; super . setEditor ( editor ) ; }'], 'label': 0}
{'guid': '1839d9b_f0c005234885db0d6152a136c4337343cef9e8b3', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public TableTree ( Composite parent , int style ) { super ( parent , SWT . NONE ) ; table = new Table ( this , style ) ; Listener tableListener = new Listener ( ) { public void handleEvent ( Event e ) { switch ( e . type ) { case SWT . MouseDown : onMouseDown ( e ) ; break ; case SWT . Selection : onSelection ( e ) ; break ; case SWT . DefaultSelection : onSelection ( e ) ; break ; case SWT . KeyDown : onKeyDown ( e ) ; break ; } } } ; int tableEvents = new int { SWT . MouseDown , SWT . Selection , SWT . DefaultSelection , SWT . KeyDown } ; for ( int i = 0 ; i < tableEvents . length ; i + + ) { table . addListener ( tableEvents i , tableListener ) ; } Listener listener = new Listener ( ) { public void handleEvent ( Event e ) { switch ( e . type ) { case SWT . Dispose : onDispose ( e ) ; break ; case SWT . Resize : onResize ( e ) ; break ; case SWT . FocusIn : onFocusIn ( e ) ; break ; } } } ; int events = new int { SWT . Dispose , SWT . Resize , SWT . FocusIn } ; for ( int i = 0 ; i < events . length ; i + + ) { addListener ( events i , listener ) ; } }', 'public void handleEvent ( Event e ) { switch ( e . type ) { case SWT . MouseDown : onMouseDown ( e ) ; break ; case SWT . Selection : onSelection ( e ) ; break ; case SWT . DefaultSelection : onSelection ( e ) ; break ; case SWT . KeyDown : onKeyDown ( e ) ; break ; } }', 'public void handleEvent ( Event e ) { switch ( e . type ) { case SWT . Dispose : onDispose ( e ) ; break ; case SWT . Resize : onResize ( e ) ; break ; case SWT . FocusIn : onFocusIn ( e ) ; break ; } }', 'int addItem ( TableTreeItem item , int index ) { if ( index < 0 index > items . length ) throw new SWTError ( SWT . ERROR_INVALID_ARGUMENT ) ; TableTreeItem newItems = new TableTreeItem items . length + 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; newItems index = item ; System . arraycopy ( items , index , newItems , index + 1 , items . length - index ) ; items = newItems ; / * Return the index in the table where this table should be inserted * / if ( index = = items . length - 1 ) return table . getItemCount ( ) ; else return table . indexOf ( items index + 1 . tableItem ) ; }', '/ * * * Adds the listener to receive selection events . * < p > * * param listener the selection listener * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when listener is null * < / ul > * / public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Selection , typedListener ) ; addListener ( SWT . DefaultSelection , typedListener ) ; }', '/ * * * Adds the listener to receive tree events . * < p > * * param listener the tree listener * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when listener is null * < / ul > * / public void addTreeListener ( TreeListener listener ) { checkWidget ( ) ; if ( listener = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Expand , typedListener ) ; addListener ( SWT . Collapse , typedListener ) ; }', 'public Point computeSize ( int wHint , int hHint ) { checkWidget ( ) ; return table . computeSize ( wHint , hHint , true ) ; }', 'public Rectangle computeTrim ( int x , int y , int width , int height ) { checkWidget ( ) ; return table . computeTrim ( x , y , width , height ) ; }', '/ * * * Deselects all items . * < p > * If an item is selected , it is deselected . * If an item is not selected , it remains unselected . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < / ul > * / public void deselectAll ( ) { checkWidget ( ) ; table . deselectAll ( ) ; }', 'void expandItem ( TableTreeItem item ) { if ( item = = null item . getExpanded ( ) ) return ; expandItem ( item . parentItem ) ; item . setExpanded ( true ) ; Event event = new Event ( ) ; event . item = item ; notifyListeners ( SWT . Expand , event ) ; }', '/ * * * Gets the number of items . * < p > * return the number of items in the widget * / public int getItemCount ( ) { / / checkWidget ( ) ; return items . length ; }', '/ * * * Gets the height of one item . * < p > * This operation will fail if the height of * one item could not be queried from the OS . * * return the height of one item in the widget * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_CANNOT_GET_ITEM_HEIGHT when the operation fails * < / ul > * / public int getItemHeight ( ) { checkWidget ( ) ; return table . getItemHeight ( ) ; }', '/ * * * Gets the items . * < p > * return the items in the widget * / public TableTreeItem getItems ( ) { / / checkWidget ( ) ; TableTreeItem newItems = new TableTreeItem items . length ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; return newItems ; }', '/ * * * Gets the selected items . * < p > * This operation will fail if the selected * items cannot be queried from the OS . * * return the selected items in the widget * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_CANNOT_GET_SELECTION when the operation fails < / li > * < / ul > * / public TableTreeItem getSelection ( ) { checkWidget ( ) ; TableItem selection = table . getSelection ( ) ; TableTreeItem result = new TableTreeItem selection . length ; for ( int i = 0 ; i < selection . length ; i + + ) { result i = ( TableTreeItem ) selection i . getData ( ) ; } return result ; }', '/ * * * Gets the number of selected items . * < p > * This operation will fail if the number of selected * items cannot be queried from the OS . * * return the number of selected items in the widget * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_CANNOT_GET_COUNT when the operation fails < / li > * < / ul > * / public int getSelectionCount ( ) { checkWidget ( ) ; return table . getSelectionCount ( ) ; }', '/ * * * Returns the underlying Table control . * * return the underlying Table control * / public Table getTable ( ) { / / checkWidget ( ) ; return table ; }', 'void createImages ( ) { int itemHeight = sizeImage . getBounds ( ) . height ; / / Calculate border around image . / / At least 9 pixels are needed to draw the image / / Leave at least a 6 pixel border . int indent = Math . min ( 6 , ( itemHeight - 9 ) / 2 ) ; indent = Math . max ( 0 , indent ) ; int size = Math . max ( 10 , itemHeight - 2 * indent ) ; size = ( ( size + 1 ) / 2 ) * 2 ; / / size must be an even number int midpoint = indent + size / 2 ; Color foreground = getForeground ( ) ; Color plusMinus = getDisplay ( ) . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; Color background = getBackground ( ) ; / * Plus image * / PaletteData palette = new PaletteData ( new RGB { foreground . getRGB ( ) , background . getRGB ( ) , plusMinus . getRGB ( ) } ) ; ImageData imageData = new ImageData ( itemHeight , itemHeight , 4 , palette ) ; imageData . transparentPixel = 1 ; plusImage = new Image ( getDisplay ( ) , imageData ) ; GC gc = new GC ( plusImage ) ; gc . setBackground ( background ) ; gc . fillRectangle ( 0 , 0 , itemHeight , itemHeight ) ; gc . setForeground ( plusMinus ) ; gc . drawRectangle ( indent , indent , size , size ) ; gc . setForeground ( foreground ) ; gc . drawLine ( midpoint , indent + 2 , midpoint , indent + size - 2 ) ; gc . drawLine ( indent + 2 , midpoint , indent + size - 2 , midpoint ) ; gc . dispose ( ) ; / * Minus image * / palette = new PaletteData ( new RGB { foreground . getRGB ( ) , background . getRGB ( ) , plusMinus . getRGB ( ) } ) ; imageData = new ImageData ( itemHeight , itemHeight , 4 , palette ) ; imageData . transparentPixel = 1 ; minusImage = new Image ( getDisplay ( ) , imageData ) ; gc = new GC ( minusImage ) ; gc . setBackground ( background ) ; gc . fillRectangle ( 0 , 0 , itemHeight , itemHeight ) ; gc . setForeground ( plusMinus ) ; gc . drawRectangle ( indent , indent , size , size ) ; gc . setForeground ( foreground ) ; gc . drawLine ( indent + 2 , midpoint , indent + size - 2 , midpoint ) ; gc . dispose ( ) ; }', 'Image getPlusImage ( ) { if ( plusImage = = null ) createImages ( ) ; return plusImage ; }', 'Image getMinusImage ( ) { if ( minusImage = = null ) createImages ( ) ; return minusImage ; }', '/ * * * Gets the index of an item . * * < p > The widget is searched starting at 0 until an * item is found that is equal to the search item . * If no item is found , - 1 is returned . Indexing * is zero based . This index is relative to the parent only . * * param item the search item * return the index of the item or - 1 * / public int indexOf ( TableTreeItem item ) { / / checkWidget ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { if ( item = = items i ) return i ; } return - 1 ; }', 'void onDispose ( Event e ) { inDispose = true ; for ( int i = 0 ; i < items . length ; i + + ) { items i . dispose ( ) ; } inDispose = false ; if ( plusImage ! = null ) plusImage . dispose ( ) ; if ( minusImage ! = null ) minusImage . dispose ( ) ; if ( sizeImage ! = null ) sizeImage . dispose ( ) ; plusImage = minusImage = sizeImage = null ; }', 'void onResize ( Event e ) { Rectangle area = getClientArea ( ) ; table . setBounds ( 0 , 0 , area . width , area . height ) ; }', 'void onSelection ( Event e ) { Event event = new Event ( ) ; TableItem tableItem = ( TableItem ) e . item ; TableTreeItem item = getItem ( tableItem ) ; event . item = item ; if ( e . type = = SWT . Selection e . detail = = SWT . CHECK item ! = null ) { event . detail = SWT . CHECK ; item . checked = tableItem . getChecked ( ) ; } notifyListeners ( e . type , event ) ; }', '/ * * * Returns the item at the given point in the receiver * or null if no such item exists . The point is in the * coordinate system of the receiver . * * param point the point used to locate the item * return the item at the given point * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the listener is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public TableTreeItem getItem ( Point point ) { checkWidget ( ) ; TableItem item = table . getItem ( point ) ; if ( item = = null ) return null ; return getItem ( item ) ; }', 'TableTreeItem getItem ( TableItem tableItem ) { if ( tableItem = = null ) return null ; for ( int i = 0 ; i < items . length ; i + + ) { TableTreeItem item = items i . getItem ( tableItem ) ; if ( item ! = null ) return item ; } return null ; }', 'void onFocusIn ( Event e ) { table . setFocus ( ) ; }', 'void onKeyDown ( Event e ) { TableTreeItem selection = getSelection ( ) ; if ( selection . length = = 0 ) return ; TableTreeItem item = selection 0 ; int type = 0 ; if ( e . keyCode = = SWT . ARROW_RIGHT e . keyCode = = SWT . ARROW_LEFT ) { if ( e . keyCode = = SWT . ARROW_RIGHT ) { if ( item . getItemCount ( ) = = 0 ) return ; if ( item . getExpanded ( ) ) { TableTreeItem newSelection = item . getItems ( ) 0 ; table . setSelection ( new TableItem { newSelection . tableItem } ) ; showItem ( newSelection ) ; type = SWT . Selection ; } else { item . setExpanded ( true ) ; type = SWT . Expand ; } } else { if ( item . getExpanded ( ) ) { item . setExpanded ( false ) ; type = SWT . Collapse ; } else { TableTreeItem parent = item . getParentItem ( ) ; if ( parent ! = null ) { int index = parent . indexOf ( item ) ; if ( index ! = 0 ) return ; table . setSelection ( new TableItem { parent . tableItem } ) ; type = SWT . Selection ; } } } } if ( e . character = = * ) { item . expandAll ( true ) ; } if ( e . character = = - ) { if ( item . getExpanded ( ) ) { item . setExpanded ( false ) ; type = SWT . Collapse ; } } if ( e . character = = + ) { if ( item . getItemCount ( ) > 0 ! item . getExpanded ( ) ) { item . setExpanded ( true ) ; type = SWT . Expand ; } } if ( type = = 0 ) return ; Event event = new Event ( ) ; notifyListeners ( type , event ) ; }', 'void onMouseDown ( Event event ) { / * If user clicked on the + or - , expand or collapse the tree . * / TableItem items = table . getItems ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { Rectangle rect = items i . getImageBounds ( 0 ) ; if ( rect . contains ( event . x , event . y ) ) { TableTreeItem item = ( TableTreeItem ) items i . getData ( ) ; event = new Event ( ) ; event . item = item ; item . setExpanded ( ! item . getExpanded ( ) ) ; if ( item . getExpanded ( ) ) { notifyListeners ( SWT . Expand , event ) ; } else { notifyListeners ( SWT . Collapse , event ) ; } return ; } } }', '/ * * * Removes all items . * < p > * This operation will fail when an item * could not be removed in the OS . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_ITEM_NOT_REMOVED when the operation fails * < / ul > * / public void removeAll ( ) { checkWidget ( ) ; setRedraw ( false ) ; for ( int i = items . length - 1 ; i > = 0 ; i - - ) { items i . dispose ( ) ; } items = EMPTY_ITEMS ; setRedraw ( true ) ; }', 'void removeItem ( TableTreeItem item ) { int index = 0 ; while ( index < items . length items index ! = item ) index + + ; if ( index = = items . length ) return ; TableTreeItem newItems = new TableTreeItem items . length - 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; System . arraycopy ( items , index + 1 , newItems , index , items . length - index - 1 ) ; items = newItems ; }', '/ * * * Removes the listener . * < p > * * param listener the listener * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when listener is null * < / ul > * / public void removeSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( SWT . Selection , listener ) ; removeListener ( SWT . DefaultSelection , listener ) ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when listener is null * < / ul > * / public void removeTreeListener ( TreeListener listener ) { checkWidget ( ) ; if ( listener = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( SWT . Expand , listener ) ; removeListener ( SWT . Collapse , listener ) ; }', '/ * * * Selects all items . * < p > * If an item is not selected , it is selected . * If an item is selected , it remains selected . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < / ul > * / public void selectAll ( ) { checkWidget ( ) ; table . selectAll ( ) ; }', 'public void setBackground ( Color color ) { super . setBackground ( color ) ; table . setBackground ( color ) ; if ( sizeImage ! = null ) { GC gc = new GC ( sizeImage ) ; gc . setBackground ( getBackground ( ) ) ; Rectangle size = sizeImage . getBounds ( ) ; gc . fillRectangle ( size ) ; gc . dispose ( ) ; } }', 'public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; table . setEnabled ( enabled ) ; }', 'public void setFont ( Font font ) { super . setFont ( font ) ; table . setFont ( font ) ; }', 'public void setForeground ( Color color ) { super . setForeground ( color ) ; table . setForeground ( color ) ; }', 'public void setMenu ( Menu menu ) { super . setMenu ( menu ) ; table . setMenu ( menu ) ; }', '/ * * * Sets the selection . * < p > * param items new selection * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when items is null * < / ul > * / public void setSelection ( TableTreeItem items ) { checkWidget ( ) ; TableItem tableItems = new TableItem items . length ; for ( int i = 0 ; i < items . length ; i + + ) { if ( items i = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; if ( ! items i . getVisible ( ) ) expandItem ( items i ) ; tableItems i = items i . tableItem ; } table . setSelection ( tableItems ) ; }', 'public void setToolTipText ( String string ) { super . setToolTipText ( string ) ; table . setToolTipText ( string ) ; }', '/ * * * Shows the item . * < p > * param item the item to be shown * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < li > ERROR_NULL_ARGUMENT when item is null * < / ul > * / public void showItem ( TableTreeItem item ) { checkWidget ( ) ; if ( item = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; if ( ! item . getVisible ( ) ) expandItem ( item ) ; TableItem tableItem = item . tableItem ; table . showItem ( tableItem ) ; }', '/ * * * Shows the selection . * < p > * If there is no selection or the selection * is already visible , this method does nothing . * If the selection is scrolled out of view , * the top index of the widget is changed such * that selection becomes visible . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed * < / ul > * / public void showSelection ( ) { checkWidget ( ) ; table . showSelection ( ) ; }'], 'label': 0}
{'guid': '1839d9b_0819ce05157ef7a3980e73ebbba30397b5093f2d', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a TableEditor for the specified Table . * * param table the Table Control above which this editor will be displayed * * / public TableTreeEditor ( TableTree tableTree ) { super ( tableTree . getTable ( ) ) ; this . tableTree = tableTree ; treeListener = new TreeListener ( ) { final Runnable runnable = new Runnable ( ) { public void run ( ) { if ( TableTreeEditor . this . tableTree . isDisposed ( ) editor = = null ) return ; resize ( ) ; editor . setVisible ( true ) ; } } ; public void treeCollapsed ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TableTreeEditor . this . tableTree . getDisplay ( ) ; display . asyncExec ( runnable ) ; } public void treeExpanded ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TableTreeEditor . this . tableTree . getDisplay ( ) ; display . asyncExec ( runnable ) ; } } ; tableTree . addTreeListener ( treeListener ) ; columnListener = new ControlListener ( ) { public void controlMoved ( ControlEvent e ) { resize ( ) ; } public void controlResized ( ControlEvent e ) { resize ( ) ; } } ; }', 'public void run ( ) { if ( TableTreeEditor . this . tableTree . isDisposed ( ) editor = = null ) return ; resize ( ) ; editor . setVisible ( true ) ; }', 'public void treeCollapsed ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TableTreeEditor . this . tableTree . getDisplay ( ) ; display . asyncExec ( runnable ) ; }', 'public void treeExpanded ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TableTreeEditor . this . tableTree . getDisplay ( ) ; display . asyncExec ( runnable ) ; }', 'public void controlMoved ( ControlEvent e ) { resize ( ) ; }', 'public void controlResized ( ControlEvent e ) { resize ( ) ; }', 'Rectangle computeBounds ( ) { if ( item = = null column = = - 1 item . isDisposed ( ) item . tableItem = = null ) return new Rectangle ( 0 , 0 , 0 , 0 ) ; Rectangle cell = item . getBounds ( column ) ; Rectangle editorRect = new Rectangle ( cell . x , cell . y , minimumWidth , cell . height ) ; Rectangle area = tableTree . getClientArea ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . width - cell . x ; } } if ( grabHorizontal ) { editorRect . width = Math . max ( cell . width , minimumWidth ) ; } if ( horizontalAlignment = = SWT . RIGHT ) { editorRect . x + = cell . width - editorRect . width ; } else if ( horizontalAlignment = = SWT . LEFT ) { / / do nothing - cell . x is the right answer } else { / / default is CENTER editorRect . x + = ( cell . width - editorRect . width ) / 2 ; } return editorRect ; }', '/ * * * Removes all associations between the TableEditor and the cell in the table . The * Table and the editor Control are < b > not < / b > disposed . * / public void dispose ( ) { if ( treeListener ! = null ) tableTree . removeTreeListener ( treeListener ) ; treeListener = null ; Table table = tableTree . getTable ( ) ; if ( this . column > - 1 this . column < table . getColumnCount ( ) ) { TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . removeControlListener ( columnListener ) ; } tableTree = null ; item = null ; column = - 1 ; super . dispose ( ) ; }', '/ * * * Returns the zero based index of the column of the cell being tracked by this editor . * * return the zero based index of the column of the cell being tracked by this editor * / public int getColumn ( ) { return column ; }', 'public void setColumn ( int column ) { Table table = tableTree . getTable ( ) ; if ( this . column > - 1 this . column < table . getColumnCount ( ) ) { TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . removeControlListener ( columnListener ) ; this . column = - 1 ; } if ( column < 0 column > = table . getColumnCount ( ) ) return ; this . column = column ; TableColumn tableColumn = table . getColumn ( this . column ) ; tableColumn . addControlListener ( columnListener ) ; }', '/ * * * Returns the TableItem for the row of the cell being tracked by this editor . * * return the TableItem for the row of the cell being tracked by this editor * / public TableTreeItem getItem ( ) { return item ; }', 'public void setItem ( TableTreeItem item ) { this . item = item ; }', 'public void setEditor ( Control editor ) { TableTreeItem item = null ; if ( tableTree . getItemCount ( ) > 0 ) { item = tableTree . getItems ( ) 0 ; } this . setEditor ( editor , item , 0 ) ; }', '/ * * * Specify the Control that is to be displayed and the cell in the table that it is to be positioned above . * * < p > Note : The Control provided as the editor < b > must < / b > be created with its parent being the Table control * specified in the TableEditor constructor . * * param editor the Control that is displayed above the cell being edited * param item the TableItem for the row of the cell being tracked by this editor * param column the zero based index of the column of the cell being tracked by this editor * / public void setEditor ( Control editor , TableTreeItem item , int column ) { setItem ( item ) ; setColumn ( column ) ; super . setEditor ( editor ) ; }'], 'label': 0}
{'guid': '1839d9b_559a3dd4afeace7eda53cc0ab51866e22eacde5b', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > TableTree < / code > ) * and a style value describing its behavior and appearance . * The item is added to the end of the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a composite control which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public TableTreeItem ( TableTree parent , int style ) { this ( parent , style , parent . getItemCount ( ) ) ; }', '/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > TableTree < / code > , * a style value describing its behavior and appearance , and the index * at which to place it in the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a composite control which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * param index the index to store the receiver in its parent * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public TableTreeItem ( TableTree parent , int style , int index ) { this ( parent , null , style , index ) ; }', '/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > TableTreeItem < / code > ) * and a style value describing its behavior and appearance . * The item is added to the end of the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parentItem a composite control which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public TableTreeItem ( TableTreeItem parent , int style ) { this ( parent , style , parent . getItemCount ( ) ) ; }', '/ * * * Constructs a new instance of this class given its parent * ( which must be a < code > TableTreeItem < / code > ) , * a style value describing its behavior and appearance , and the index * at which to place it in the items maintained by its parent . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parentItem a composite control which will be the parent of the new instance ( cannot be null ) * param style the style of control to construct * param index the index to store the receiver in its parent * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see Widget getStyle * / public TableTreeItem ( TableTreeItem parent , int style , int index ) { this ( parent . getParent ( ) , parent , style , index ) ; }', 'TableTreeItem ( TableTree parent , TableTreeItem parentItem , int style , int index ) { super ( parent , style ) ; this . parent = parent ; this . parentItem = parentItem ; if ( parentItem = = null ) { / * Root items are visible immediately * / int tableIndex = parent . addItem ( this , index ) ; tableItem = new TableItem ( parent . getTable ( ) , style , tableIndex ) ; tableItem . setData ( this ) ; addCheck ( ) ; / * * Feature in the Table . The table uses the first image that * is inserted into the table to size the table rows . If the * user is allowed to insert the first image , this will cause * the + / - images to be scaled . The fix is to insert a dummy * image to force the size . * / if ( parent . sizeImage = = null ) { int itemHeight = parent . getItemHeight ( ) ; parent . sizeImage = new Image ( null , itemHeight , itemHeight ) ; GC gc = new GC ( parent . sizeImage ) ; gc . setBackground ( parent . getBackground ( ) ) ; gc . fillRectangle ( 0 , 0 , itemHeight , itemHeight ) ; gc . dispose ( ) ; tableItem . setImage ( 0 , parent . sizeImage ) ; } } else { parentItem . addItem ( this , index ) ; } }', 'void addCheck ( ) { Table table = parent . getTable ( ) ; if ( ( table . getStyle ( ) SWT . CHECK ) = = 0 ) return ; tableItem . setChecked ( checked ) ; }', 'void addItem ( TableTreeItem item , int index ) { if ( item = = null ) throw new SWTError ( SWT . ERROR_NULL_ARGUMENT ) ; if ( index < 0 index > items . length ) throw new SWTError ( SWT . ERROR_INVALID_ARGUMENT ) ; / * Now that item has a sub - node it must indicate that it can be expanded * / if ( items . length = = 0 index = = 0 ) { if ( tableItem ! = null ) { Image image = expanded ? parent . getMinusImage ( ) : parent . getPlusImage ( ) ; tableItem . setImage ( 0 , image ) ; } } / * Put the item in the items list * / TableTreeItem newItems = new TableTreeItem items . length + 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; newItems index = item ; System . arraycopy ( items , index , newItems , index + 1 , items . length - index ) ; items = newItems ; if ( expanded ) item . setVisible ( true ) ; }', '/ * * * Returns a rectangle describing the receiver s size and location * relative to its parent . * * return the receiver s bounding rectangle * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Rectangle getBounds ( int index ) { checkWidget ( ) ; if ( tableItem ! = null ) { return tableItem . getBounds ( index ) ; } else { return new Rectangle ( 0 , 0 , 0 , 0 ) ; } }', '/ * * * Returns < code > true < / code > if the receiver is checked , * and false otherwise . When the parent does not have * the < code > CHECK style , return false . * < p > * * return the checked state * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public boolean getChecked ( ) { checkWidget ( ) ; if ( tableItem = = null ) { return checked ; } return tableItem . getChecked ( ) ; }', 'public Display getDisplay ( ) { TableTree parent = this . parent ; if ( parent = = null ) throw new SWTError ( SWT . ERROR_WIDGET_DISPOSED ) ; return parent . getDisplay ( ) ; }', '/ * * * Returns < code > true < / code > if the receiver is expanded , * and false otherwise . * < p > * * return the expanded state * / public boolean getExpanded ( ) { / / checkWidget ( ) ; return expanded ; }', '/ * * * Gets the first image . * < p > * The image in column 0 is reserved for the + and - * images of the tree , therefore getImage ( 0 ) will return null . * * return the image at index 0 * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public Image getImage ( ) { checkWidget ( ) ; return getImage ( 0 ) ; }', '/ * * * Gets the image at the specified index . * < p > * Indexing is zero based . The image can be null . * The image in column 0 is reserved for the + and - * images of the tree , therefore getImage ( 0 ) will return null . * Return null if the index is out of range . * * param index the index of the image * return the image at the specified index or null * / public Image getImage ( int index ) { / / checkWidget ( ) ; if ( 0 < index index < images . length ) return images index ; return null ; }', 'int getIndent ( ) { if ( parentItem = = null ) return 0 ; return parentItem . getIndent ( ) + 1 ; }', '/ * * * Returns the number of items contained in the receiver * that are direct item children of the receiver . * * return the number of items * / public int getItemCount ( ) { / / checkWidget ( ) ; return items . length ; }', '/ * * * Returns an array of < code > TableTreeItem < / code > s which are the * direct item children of the receiver . * < p > * Note : This is not the actual structure used by the receiver * to maintain its list of items , so modifying the array will * not affect the receiver . * < / p > * * return the receiver s items * / public TableTreeItem getItems ( ) { / / checkWidget ( ) ; TableTreeItem newItems = new TableTreeItem items . length ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; return newItems ; }', 'TableTreeItem getItem ( TableItem tableItem ) { if ( tableItem = = null ) return null ; if ( this . tableItem = = tableItem ) return this ; for ( int i = 0 ; i < items . length ; i + + ) { TableTreeItem item = items i . getItem ( tableItem ) ; if ( item ! = null ) return item ; } return null ; }', '/ * * * Returns the receiver s parent , which must be a < code > TableTree < / code > . * * return the receiver s parent * / public TableTree getParent ( ) { / / checkWidget ( ) ; return parent ; }', '/ * * * Returns the receiver s parent item , which must be a * < code > TableTreeItem < / code > or null when the receiver is a * root . * * return the receiver s parent item * / public TableTreeItem getParentItem ( ) { / / checkWidget ( ) ; return parentItem ; }', 'public String getText ( ) { checkWidget ( ) ; return getText ( 0 ) ; }', '/ * * * Gets the item text at the specified index . * < p > * Indexing is zero based . * * This operation will fail when the index is out * of range or an item could not be queried from * the OS . * * param index the index of the item * return the item text at the specified index , which can be null * / public String getText ( int index ) { / / checkWidget ( ) ; if ( 0 < = index index < texts . length ) return texts index ; return null ; }', 'boolean getVisible ( ) { return tableItem ! = null ; }', '/ * * * Gets the index of the specified item . * * < p > The widget is searched starting at 0 until an * item is found that is equal to the search item . * If no item is found , - 1 is returned . Indexing * is zero based . This index is relative to the parent only . * * param item the search item * return the index of the item or - 1 if the item is not found * * / public int indexOf ( TableTreeItem item ) { / / checkWidget ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { if ( items i = = item ) return i ; } return - 1 ; }', 'void expandAll ( boolean notify ) { if ( items . length = = 0 ) return ; if ( ! expanded ) { setExpanded ( true ) ; if ( notify ) notifyListeners ( SWT . Expand , new Event ( ) ) ; for ( int i = 0 ; i < items . length ; i + + ) { items i . expandAll ( notify ) ; } } }', 'int expandedIndexOf ( TableTreeItem item ) { int index = 0 ; for ( int i = 0 ; i < items . length ; i + + ) { if ( items i = = item ) return index ; if ( items i . expanded ) index + = items i . visibleChildrenCount ( ) ; index + + ; } return - 1 ; }', 'int visibleChildrenCount ( ) { int count = 0 ; for ( int i = 0 ; i < items . length ; i + + ) { if ( items i . getVisible ( ) ) { count + = 1 + items i . visibleChildrenCount ( ) ; } } return count ; }', 'public void dispose ( ) { if ( isDisposed ( ) ) return ; for ( int i = items . length - 1 ; i > = 0 ; i - - ) { items i . dispose ( ) ; } super . dispose ( ) ; if ( ! parent . inDispose ) { if ( parentItem ! = null ) { parentItem . removeItem ( this ) ; } else { parent . removeItem ( this ) ; } if ( tableItem ! = null ) tableItem . dispose ( ) ; } items = null ; parentItem = null ; parent = null ; images = null ; texts = null ; tableItem = null ; }', 'void removeItem ( TableTreeItem item ) { int index = 0 ; while ( index < items . length items index ! = item ) index + + ; if ( index = = items . length ) return ; TableTreeItem newItems = new TableTreeItem items . length - 1 ; System . arraycopy ( items , 0 , newItems , 0 , index ) ; System . arraycopy ( items , index + 1 , newItems , index , items . length - index - 1 ) ; items = newItems ; if ( items . length = = 0 ) { if ( tableItem ! = null ) tableItem . setImage ( 0 , null ) ; } }', '/ * * * Sets the checked state . * < p > * param checked the new checked state . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void setChecked ( boolean checked ) { checkWidget ( ) ; if ( tableItem ! = null ) { tableItem . setChecked ( checked ) ; } this . checked = checked ; }', '/ * * * Sets the expanded state . * < p > * param expanded the new expanded state . * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void setExpanded ( boolean expanded ) { checkWidget ( ) ; if ( items . length = = 0 ) return ; this . expanded = expanded ; if ( tableItem = = null ) return ; parent . setRedraw ( false ) ; for ( int i = 0 ; i < items . length ; i + + ) { items i . setVisible ( expanded ) ; } Image image = expanded ? parent . getMinusImage ( ) : parent . getPlusImage ( ) ; tableItem . setImage ( 0 , image ) ; parent . setRedraw ( true ) ; }', '/ * * * Sets the image at an index . * < p > * The image can be null . * The image in column 0 is reserved for the + and - * images of the tree , therefore do nothing if index is 0 . * * param image the new image or null * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < / ul > * / public void setImage ( int index , Image image ) { checkWidget ( ) ; int columnCount = Math . max ( parent . getTable ( ) . getColumnCount ( ) , 1 ) ; if ( index < = 0 index > = columnCount ) return ; if ( images . length < columnCount ) { Image newImages = new Image columnCount ; System . arraycopy ( images , 0 , newImages , 0 , images . length ) ; images = newImages ; } images index = image ; if ( tableItem ! = null ) tableItem . setImage ( index , image ) ; }', '/ * * * Sets the first image . * < p > * The image can be null . * The image in column 0 is reserved for the + and - * images of the tree , therefore do nothing . * * param image the new image or null * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public void setImage ( Image image ) { setImage ( 0 , image ) ; }', '/ * * * Sets the widget text . * < p > * * The widget text for an item is the label of the * item or the label of the text specified by a column * number . * * param index the column number * param text the new text * * exception SWTError < ul > * < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when string is null < / li > * < / ul > * / public void setText ( int index , String text ) { checkWidget ( ) ; int columnCount = Math . max ( parent . getTable ( ) . getColumnCount ( ) , 1 ) ; if ( index < 0 index > = columnCount ) return ; if ( texts . length < columnCount ) { String newTexts = new String columnCount ; System . arraycopy ( texts , 0 , newTexts , 0 , texts . length ) ; texts = newTexts ; } texts index = text ; if ( tableItem ! = null ) tableItem . setText ( index , text ) ; }', 'public void setText ( String string ) { setText ( 0 , string ) ; }', 'void setVisible ( boolean show ) { if ( parentItem = = null ) return ; / / this is a root and can not be toggled between visible and hidden if ( getVisible ( ) = = show ) return ; if ( show ) { if ( ! parentItem . getVisible ( ) ) return ; / / parentItem must already be visible / / create underlying table item and set data in table item to stored data Table table = parent . getTable ( ) ; int parentIndex = table . indexOf ( parentItem . tableItem ) ; int index = parentItem . expandedIndexOf ( this ) + parentIndex + 1 ; if ( index < 0 ) return ; tableItem = new TableItem ( table , getStyle ( ) , index ) ; tableItem . setData ( this ) ; tableItem . setImageIndent ( getIndent ( ) ) ; addCheck ( ) ; / / restore fields to item / / ignore any images in the first column int columnCount = Math . max ( table . getColumnCount ( ) , 1 ) ; for ( int i = 0 ; i < columnCount ; i + + ) { if ( i < texts . length texts i ! = null ) setText ( i , texts i ) ; if ( i < images . length images i ! = null ) setImage ( i , images i ) ; } / / display the children and the appropriate + / - symbol as required if ( items . length ! = 0 ) { if ( expanded ) { tableItem . setImage ( 0 , parent . getMinusImage ( ) ) ; for ( int i = 0 , length = items . length ; i < length ; i + + ) { items i . setVisible ( true ) ; } } else { tableItem . setImage ( 0 , parent . getPlusImage ( ) ) ; } } } else { for ( int i = 0 , length = items . length ; i < length ; i + + ) { items i . setVisible ( false ) ; } / / remove row from table tableItem . dispose ( ) ; tableItem = null ; } }'], 'label': 0}
{'guid': '1839d9b_29bbf0450552df51302b59d8c93f5dff339acb48', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * param event . start replace start offset ( input ) * param event . newText text that is going to be inserted or empty String * if no text will be inserted ( input ) * param event . replaceCharCount length of text that is going to be * replaced ( input ) * param event . newCharCount length of text that is going to be inserted * ( input ) * param event . replaceLineCount number of lines that are going to be * replaced ( input ) * param event . newLineCount number of new lines that are going to be * inserted ( input ) * / public void textChanging ( TextChangingEvent event ) ;', '/ * * * / public void textChanged ( TextChangedEvent event ) ;', '/ * * * / public void textSet ( TextChangedEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_5a7648cd8b5cef935b937953553172c626100569', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Create the TextChangedEvent to be used by the StyledTextContent implementor . * < p > * * param source the object that will be sending the TextChangedEvent , cannot be null * / public TextChangedEvent ( StyledTextContent source ) { super ( source ) ; }'], 'label': 0}
{'guid': '1839d9b_b334ead55047032616b21111c7f552acc331e517', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Create the TextChangedEvent to be used by the StyledTextContent implementor . * < p > * * param source the object that will be sending the TextChangedEvent , cannot be null * / public TextChangingEvent ( StyledTextContent source ) { super ( source ) ; }', 'TextChangingEvent ( StyledTextContent source , StyledTextEvent e ) { super ( source ) ; start = e . start ; replaceCharCount = e . replaceCharCount ; newCharCount = e . newCharCount ; replaceLineCount = e . replaceLineCount ; newLineCount = e . newLineCount ; newText = e . text ; }'], 'label': 0}
{'guid': '1839d9b_a828282da88a005aed160ea13cd92584d7cca6ec', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a TreeEditor for the specified Tree . * * param tree the Tree Control above which this editor will be displayed * * / public TreeEditor ( Tree tree ) { super ( tree ) ; this . tree = tree ; treeListener = new TreeAdapter ( ) { final Runnable runnable = new Runnable ( ) { public void run ( ) { if ( TreeEditor . this . tree . isDisposed ( ) editor = = null ) return ; resize ( ) ; editor . setVisible ( true ) ; } } ; public void treeCollapsed ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TreeEditor . this . tree . getDisplay ( ) ; display . asyncExec ( runnable ) ; } public void treeExpanded ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TreeEditor . this . tree . getDisplay ( ) ; display . asyncExec ( runnable ) ; } } ; tree . addTreeListener ( treeListener ) ; }', 'public void run ( ) { if ( TreeEditor . this . tree . isDisposed ( ) editor = = null ) return ; resize ( ) ; editor . setVisible ( true ) ; }', 'public void treeCollapsed ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TreeEditor . this . tree . getDisplay ( ) ; display . asyncExec ( runnable ) ; }', 'public void treeExpanded ( TreeEvent e ) { if ( editor = = null ) return ; editor . setVisible ( false ) ; Display display = TreeEditor . this . tree . getDisplay ( ) ; display . asyncExec ( runnable ) ; }', 'Rectangle computeBounds ( ) { if ( item = = null item . isDisposed ( ) ) return new Rectangle ( 0 , 0 , 0 , 0 ) ; Rectangle cell = item . getBounds ( ) ; Rectangle area = tree . getClientArea ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . x + area . width - cell . x ; } } Rectangle editorRect = new Rectangle ( cell . x , cell . y , minimumWidth , cell . height ) ; if ( grabHorizontal ) { editorRect . width = Math . max ( area . x + area . width - cell . x , minimumWidth ) ; } if ( horizontalAlignment = = SWT . RIGHT ) { editorRect . x = Math . max ( cell . x , cell . x + cell . width - editorRect . width ) ; } else if ( horizontalAlignment = = SWT . LEFT ) { / / do nothing - cell . x is the right answer } else { / / default is CENTER editorRect . x = Math . max ( cell . x , cell . x + ( cell . width - editorRect . width ) / 2 ) ; } return editorRect ; }', '/ * * * Removes all associations between the TreeEditor and the cell in the tree . The * tree and the editor Control are < b > not < / b > disposed . * / public void dispose ( ) { if ( treeListener ! = null ) tree . removeTreeListener ( treeListener ) ; treeListener = null ; tree = null ; item = null ; super . dispose ( ) ; }', '/ * * * Returns the TreeItem for the row of the cell being tracked by this editor . * * return the TreeItem for the row of the cell being tracked by this editor * / public TreeItem getItem ( ) { return item ; }', 'public void setItem ( TreeItem item ) { this . item = item ; }', '/ * * * Specify the Control that is to be displayed and the cell in the tree that it is to be positioned above . * * < p > Note : The Control provided as the editor < b > must < / b > be created with its parent being the Tree control * specified in the TreeEditor constructor . * * param editor the Control that is displayed above the cell being edited * param item the TreeItem for the row of the cell being tracked by this editor * param column the zero based index of the column of the cell being tracked by this editor * / public void setEditor ( Control editor , TreeItem item ) { setItem ( item ) ; super . setEditor ( editor ) ; }', 'public void setEditor ( Control editor ) { TreeItem item = null ; if ( tree . getItemCount ( ) ! = 0 ) { item = tree . getItems ( ) 0 ; } this . setEditor ( editor , item ) ; }'], 'label': 0}
{'guid': '1839d9b_3d44eb51a4c35d144a2c55840972c11a0bf43f7a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * param event . character the character that was typed ( input ) * param event . keyCode the key code that was typed ( input ) * param event . stateMask the state of the keyboard ( input ) * param event . doit processed or not ( output ) * / public void verifyKey ( VerifyEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_e6f713cf569ac4ac18fcc2fd25db786f238cd4bc', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Constructs a new instance of this class given its parent * and a style value describing its behavior and appearance . * < p > * The style value is either one of the style constants defined in * class < code > SWT < / code > which is applicable to instances of this * class , or must be built by < em > bitwise OR < / em > ing together * ( that is , using the < code > int < / code > " " operator ) two or more * of those < code > SWT < / code > style constants . The class description * for all SWT widget classes should include a comment which * describes the style constants which are applicable to the class . * < / p > * * param parent a widget which will be the parent of the new instance ( cannot be null ) * param style the style of widget to construct * * exception IllegalArgumentException < ul > * < li > ERROR_NULL_ARGUMENT - if the parent is null < / li > * < / ul > * exception SWTException < ul > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent < / li > * < / ul > * * see SWT * see getStyle * / public ViewForm ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; borderColor1 = new Color ( getDisplay ( ) , borderInsideRGB ) ; borderColor2 = new Color ( getDisplay ( ) , borderMiddleRGB ) ; borderColor3 = new Color ( getDisplay ( ) , borderOutsideRGB ) ; setBorderVisible ( ( style SWT . BORDER ) ! = 0 ) ; addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent event ) { onPaint ( event . gc ) ; } } ) ; addControlListener ( new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { onResize ( ) ; } } ) ; addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event e ) { onDispose ( ) ; } } ) ; }', 'public void paintControl ( PaintEvent event ) { onPaint ( event . gc ) ; }', 'public void controlResized ( ControlEvent e ) { onResize ( ) ; }', 'public void handleEvent ( Event e ) { onDispose ( ) ; }', '/ * * * Check the style bits to ensure that no invalid styles are applied . * private * / private static int checkStyle ( int style ) { int mask = SWT . FLAT ; return style mask SWT . NO_REDRAW_RESIZE ; }', 'public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; / / size of title bar area Point leftSize = new Point ( 0 , 0 ) ; if ( topLeft ! = null ) { leftSize = topLeft . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } Point centerSize = new Point ( 0 , 0 ) ; if ( topCenter ! = null ) { centerSize = topCenter . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } Point rightSize = new Point ( 0 , 0 ) ; if ( topRight ! = null ) { rightSize = topRight . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } Point size = new Point ( 0 , 0 ) ; / / calculate width of title bar if ( separateTopCenter ) { size . x = leftSize . x + rightSize . x ; size . x = Math . max ( centerSize . x , size . x ) ; size . y = Math . max ( leftSize . y , rightSize . y ) ; if ( topCenter ! = null ) { size . y + = centerSize . y ; } } else { size . x = leftSize . x + centerSize . x + rightSize . x ; size . y = Math . max ( leftSize . y , Math . max ( centerSize . y , rightSize . y ) ) ; } if ( content ! = null ) { Point contentSize = new Point ( 0 , 0 ) ; contentSize = content . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; size . x = Math . max ( size . x , contentSize . x ) ; size . y + = contentSize . y ; } size . x + = 2 * marginWidth + BORDER_LEFT + BORDER_RIGHT ; size . y + = 2 * marginHeight + BORDER_TOP + BORDER_BOTTOM ; return size ; }', 'public Rectangle getClientArea ( ) { checkWidget ( ) ; Rectangle clientArea = super . getClientArea ( ) ; clientArea . x + = BORDER_LEFT ; clientArea . y + = BORDER_TOP ; clientArea . width - = BORDER_LEFT + BORDER_RIGHT ; clientArea . height - = BORDER_TOP + BORDER_BOTTOM ; return clientArea ; }', '/ * * * Returns the content area . * * return the control in the content area of the pane or null * / public Control getContent ( ) { / / checkWidget ( ) ; return content ; }', '/ * * * Returns Control that appears in the top center of the pane . * Typically this is a toolbar . * * return the control in the top center of the pane or null * / public Control getTopCenter ( ) { / / checkWidget ( ) ; return topCenter ; }', '/ * * * Returns the Control that appears in the top left corner of the pane . * Typically this is a label such as CLabel . * * return the control in the top left corner of the pane or null * / public Control getTopLeft ( ) { / / checkWidget ( ) ; return topLeft ; }', '/ * * * Returns the control in the top right corner of the pane . * Typically this is a Close button or a composite with a Menu and Close button . * * return the control in the top right corner of the pane or null * / public Control getTopRight ( ) { / / checkWidget ( ) ; return topRight ; }', 'public void layout ( boolean changed ) { checkWidget ( ) ; Rectangle rect = getClientArea ( ) ; drawLine1 = - 1 ; drawLine2 = - 1 ; Point leftSize = new Point ( 0 , 0 ) ; if ( topLeft ! = null ! topLeft . isDisposed ( ) ) { leftSize = topLeft . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } Point centerSize = new Point ( 0 , 0 ) ; if ( topCenter ! = null ! topCenter . isDisposed ( ) ) { centerSize = topCenter . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } Point rightSize = new Point ( 0 , 0 ) ; if ( topRight ! = null ! topRight . isDisposed ( ) ) { rightSize = topRight . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; } int minTopWidth = leftSize . x + centerSize . x + rightSize . x + 2 * marginWidth + 1 ; / / + 1 for highlight line int height = rect . y + marginHeight ; boolean top = false ; if ( separateTopCenter minTopWidth > rect . width ) { ; int topHeight = Math . max ( rightSize . y , leftSize . y ) ; if ( topRight ! = null ! topRight . isDisposed ( ) ) { top = true ; topRight . setBounds ( rect . x + rect . width - marginWidth - rightSize . x , rect . y + 1 + marginHeight , rightSize . x , topHeight ) ; height + = 1 + topHeight ; / / + 1 for highlight line } if ( topLeft ! = null ! topLeft . isDisposed ( ) ) { top = true ; leftSize = topLeft . computeSize ( rect . width - 2 * marginWidth - rightSize . x - 1 , SWT . DEFAULT ) ; topLeft . setBounds ( rect . x + 1 + marginWidth , rect . y + 1 + marginHeight , leftSize . x , topHeight ) ; height = Math . max ( height , rect . y + marginHeight + 1 + topHeight ) ; / / + 1 for highlight line } if ( topCenter ! = null ! topCenter . isDisposed ( ) ) { top = true ; if ( height > rect . y + marginHeight ) { drawLine1 = height ; height + = 1 ; / / + 1 for divider line } centerSize = topCenter . computeSize ( rect . width - 2 * marginWidth , SWT . DEFAULT ) ; topCenter . setBounds ( rect . x + rect . width - marginWidth - centerSize . x , height , centerSize . x , centerSize . y ) ; height + = centerSize . y ; } } else { int topHeight = Math . max ( rightSize . y , Math . max ( centerSize . y , leftSize . y ) ) ; if ( topRight ! = null ! topRight . isDisposed ( ) ) { top = true ; topRight . setBounds ( rect . x + rect . width - marginWidth - rightSize . x , rect . y + marginHeight + 1 , / / + 1 for highlight line rightSize . x , topHeight ) ; height + = 1 + topHeight ; / / + 1 for highlight line } if ( topCenter ! = null ! topCenter . isDisposed ( ) ) { top = true ; topCenter . setBounds ( rect . x + rect . width - marginWidth - rightSize . x - centerSize . x , rect . y + marginHeight + 1 , / / + 1 for highlight line centerSize . x , topHeight ) ; height = Math . max ( height , rect . y + marginHeight + 1 + topHeight ) ; / / + 1 for highlight line } if ( topLeft ! = null ! topLeft . isDisposed ( ) ) { top = true ; leftSize = topLeft . computeSize ( rect . width - 2 * marginWidth - rightSize . x - centerSize . x - 1 , topHeight ) ; topLeft . setBounds ( rect . x + marginWidth + 1 , / / + 1 for highlight line rect . y + marginHeight + 1 , / / + 1 for highlight line leftSize . x , topHeight ) ; height = Math . max ( height , rect . y + marginHeight + 1 + topHeight ) ; / / + 1 for highlight line } } if ( content ! = null ! content . isDisposed ( ) ) { if ( top ) { drawLine2 = height ; height + = 1 ; / / + 1 for divider line } content . setBounds ( rect . x + marginWidth , height , rect . width - 2 * marginWidth , rect . y + rect . height - height - marginHeight ) ; } }', 'private void onDispose ( ) { if ( borderColor1 ! = null ) { borderColor1 . dispose ( ) ; } borderColor1 = null ; if ( borderColor2 ! = null ) { borderColor2 . dispose ( ) ; } borderColor2 = null ; if ( borderColor3 ! = null ) { borderColor3 . dispose ( ) ; } borderColor3 = null ; }', '/ * * * Draws the focus border . * / private void onPaint ( GC gc ) { Rectangle d = super . getClientArea ( ) ; if ( showBorder ) { if ( ( getStyle ( ) SWT . FLAT ) ! = 0 ) { gc . setForeground ( borderColor1 ) ; gc . drawRectangle ( d . x , d . y , d . x + d . width - 1 , d . y + d . height - 1 ) ; } else { gc . setForeground ( borderColor1 ) ; gc . drawRectangle ( d . x , d . y , d . x + d . width - 3 , d . y + d . height - 3 ) ; gc . setForeground ( borderColor2 ) ; gc . drawLine ( d . x + 1 , d . y + d . height - 2 , d . x + d . width - 1 , d . y + d . height - 2 ) ; gc . drawLine ( d . x + d . width - 2 , d . y + 1 , d . x + d . width - 2 , d . y + d . height - 1 ) ; gc . setForeground ( borderColor3 ) ; gc . drawLine ( d . x + 2 , d . y + d . height - 1 , d . x + d . width - 2 , d . y + d . height - 1 ) ; gc . drawLine ( d . x + d . width - 1 , d . y + 2 , d . x + d . width - 1 , d . y + d . height - 2 ) ; } } if ( drawLine1 ! = - 1 ) { / / top seperator line gc . setForeground ( borderColor1 ) ; gc . drawLine ( d . x + BORDER_LEFT , drawLine1 , d . x + d . width - BORDER_RIGHT , drawLine1 ) ; } if ( drawLine2 ! = - 1 ) { / / content separator line gc . setForeground ( borderColor1 ) ; gc . drawLine ( d . x + BORDER_LEFT , drawLine2 , d . x + d . width - BORDER_RIGHT , drawLine2 ) ; } / / highlight on top int y = drawLine1 ; if ( y = = - 1 ) { y = drawLine2 ; } if ( y ! = - 1 ) { gc . setForeground ( getDisplay ( ) . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ) ; gc . drawLine ( d . x + BORDER_LEFT + marginWidth , d . y + BORDER_TOP + marginHeight , d . x + BORDER_LEFT + marginWidth , y - 1 ) ; gc . drawLine ( d . x + BORDER_LEFT + marginWidth , d . y + BORDER_TOP + marginHeight , d . x + d . width - BORDER_RIGHT - marginWidth - 1 , d . y + BORDER_TOP + marginHeight ) ; } gc . setForeground ( getForeground ( ) ) ; }', 'private void onResize ( ) { layout ( ) ; Rectangle area = super . getClientArea ( ) ; if ( oldArea = = null oldArea . width = = 0 oldArea . height = = 0 ) { redraw ( ) ; } else { int width = 0 ; if ( oldArea . width < area . width ) { width = area . width - oldArea . width + BORDER_RIGHT ; } else if ( oldArea . width > area . width ) { width = BORDER_RIGHT ; } redraw ( area . x + area . width - width , area . y , width , area . height , false ) ; int height = 0 ; if ( oldArea . height < area . height ) { height = area . height - oldArea . height + BORDER_BOTTOM ; } if ( oldArea . height > area . height ) { height = BORDER_BOTTOM ; } redraw ( area . x , area . y + area . height - height , area . width , height , false ) ; } oldArea = area ; }', '/ * * * Sets the content . * Setting the content to null will remove it from * the pane - however , the creator of the content must dispose of the content . * * param c the control to be displayed in the content area or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setContent ( Control content ) { checkWidget ( ) ; if ( content ! = null content . getParent ( ) ! = this ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . content ! = null ! this . content . isDisposed ( ) ) { this . content . setBounds ( OFFSCREEN , OFFSCREEN , 0 , 0 ) ; } this . content = content ; layout ( ) ; }', '/ * * * Set the widget font . * This will apply the font to the topLeft , topRight and topCenter widgets . * / public void setFont ( Font f ) { super . setFont ( f ) ; if ( topLeft ! = null ! topLeft . isDisposed ( ) ) topLeft . setFont ( f ) ; if ( topCenter ! = null ! topCenter . isDisposed ( ) ) topCenter . setFont ( f ) ; if ( topRight ! = null ! topRight . isDisposed ( ) ) topRight . setFont ( f ) ; layout ( ) ; }', '/ * * * Sets the layout which is associated with the receiver to be * the argument which may be null . * < p > * Note : ViewForm does not use a layout class to size and position its children . * < / p > * * param the receiver s new layout or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setLayout ( Layout layout ) { checkWidget ( ) ; return ; }', '/ * * * Set the control that appears in the top center of the pane . * Typically this is a toolbar . * The topCenter is optional . Setting the topCenter to null will remove it from * the pane - however , the creator of the topCenter must dispose of the topCenter . * * param c the control to be displayed in the top center or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setTopCenter ( Control topCenter ) { checkWidget ( ) ; if ( topCenter ! = null topCenter . getParent ( ) ! = this ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . topCenter ! = null ! this . topCenter . isDisposed ( ) ) { this . topCenter . setBounds ( OFFSCREEN , OFFSCREEN , 0 , 0 ) ; } this . topCenter = topCenter ; layout ( ) ; }', '/ * * * Set the control that appears in the top left corner of the pane . * Typically this is a label such as CLabel . * The topLeft is optional . Setting the top left control to null will remove it from * the pane - however , the creator of the control must dispose of the control . * * param c the control to be displayed in the top left corner or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setTopLeft ( Control c ) { checkWidget ( ) ; if ( c ! = null c . getParent ( ) ! = this ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . topLeft ! = null ! this . topLeft . isDisposed ( ) ) { this . topLeft . setBounds ( OFFSCREEN , OFFSCREEN , 0 , 0 ) ; } this . topLeft = c ; layout ( ) ; }', '/ * * * Set the control that appears in the top right corner of the pane . * Typically this is a Close button or a composite with a Menu and Close button . * The topRight is optional . Setting the top right control to null will remove it from * the pane - however , the creator of the control must dispose of the control . * * param c the control to be displayed in the top right corner or null * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < li > ERROR_INVALID_ARGUMENT - if the control is not a child of this ViewForm < / li > * < / ul > * / public void setTopRight ( Control c ) { checkWidget ( ) ; if ( c ! = null c . getParent ( ) ! = this ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . topRight ! = null ! this . topRight . isDisposed ( ) ) { this . topRight . setBounds ( OFFSCREEN , OFFSCREEN , 0 , 0 ) ; } this . topRight = c ; layout ( ) ; }', '/ * * * Specify whether the border should be displayed or not . * * param show true if the border should be displayed * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setBorderVisible ( boolean show ) { checkWidget ( ) ; if ( showBorder = = show ) return ; showBorder = show ; if ( showBorder ) { if ( ( getStyle ( ) SWT . FLAT ) ! = 0 ) { BORDER_LEFT = BORDER_TOP = BORDER_RIGHT = BORDER_BOTTOM = 1 ; } else { BORDER_LEFT = BORDER_TOP = 1 ; BORDER_RIGHT = BORDER_BOTTOM = 3 ; } } else { BORDER_BOTTOM = BORDER_TOP = BORDER_LEFT = BORDER_RIGHT = 0 ; } layout ( ) ; redraw ( ) ; }', '/ * * * If true , the topCenter will always appear on a separate line by itself , otherwise the * topCenter will appear in the top row if there is room and will be moved to the second row if * required . * * param show true if the topCenter will always appear on a separate line by itself * * exception SWTException < ul > * < li > ERROR_WIDGET_DISPOSED - if the receiver has been disposed < / li > * < li > ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver < / li > * < / ul > * / public void setTopCenterSeparate ( boolean show ) { checkWidget ( ) ; separateTopCenter = show ; layout ( ) ; }'], 'label': 0}
{'guid': '1839d9b_bf05aadb173de020d6c4eceeacf5f62870d74c41', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Create a new instance . * * param styledText StyledText widget that displays the lines * wrapped by the new instance . * param logicalContent StyledTextContent that provides the line * data . * / WrappedContent ( StyledText styledText , StyledTextContent logicalContent ) { parent = styledText ; this . logicalContent = logicalContent ; }', '/ * * * see StyledTextContent addTextChangeListener ( TextChangeListener ) * / public void addTextChangeListener ( TextChangeListener listener ) { logicalContent . addTextChangeListener ( listener ) ; }', '/ * * * Grow the lines array to at least the specified size . * < p > * * param numLines number of elements that the array should have * at a minimum * / private void ensureSize ( int numLines ) { int size = visualLines . length ; if ( size > = numLines ) { return ; } int newLines = new int Math . max ( size * 2 , numLines ) 2 ; System . arraycopy ( visualLines , 0 , newLines , 0 , size ) ; visualLines = newLines ; resetVisualLines ( size , visualLines . length - size ) ; }', '/ * * * see StyledTextContent getCharCount ( ) * / public int getCharCount ( ) { return logicalContent . getCharCount ( ) ; }', '/ * * * return the visual ( wrapped ) line at the specified index * see StyledTextContent getLine ( int ) * / public String getLine ( int lineIndex ) { String line ; / / redirect call to logical content if there are no wrapped lines if ( visualLineCount = = 0 ) { line = logicalContent . getLine ( lineIndex ) ; } else { line = logicalContent . getTextRange ( visualLines lineIndex LINE_OFFSET , visualLines lineIndex LINE_LENGTH ) ; } return line ; }', '/ * * * Returns the visual ( wrapped ) line at given offset . * < p > * The offset is ambiguous if it identifies the end of a visual line and * there is another visual line below . In this case the end of the visual * line has the same offset as the beginning of the next visual line * since the visual line break is not represented by any character in the * logical line . * In this ambiguous case the offset is assumed to represent the end of a * visual line and the index of the first visual line is returned . * < / p > * * param offset offset of the desired line . * return the index of the visual ( wrapped ) line at the specified offset * see StyledTextContent getLineAtOffset ( int ) * / public int getLineAtOffset ( int offset ) { int lastLine = visualLineCount - 1 ; int lastChar ; / / redirect call to logical content if there are no wrapped lines if ( visualLineCount = = 0 ) { return logicalContent . getLineAtOffset ( offset ) ; } / / can t use getCharCount to get the number of characters since this / / method is called in textChanged , when the logicalContent used by / / getCharCount has already changed . at that point the visual lines / / have not been updated yet and we thus need to use the old character / / count which is only available in the visual content . lastChar = visualLines lastLine LINE_OFFSET + visualLines lastLine LINE_LENGTH ; if ( offset < 0 ( offset > 0 offset > lastChar ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } / / if last line and the line is not empty you can ask for / / a position that doesn t exist ( the one to the right of the / / last character ) - for inserting if ( offset = = lastChar ) { return lastLine ; } int high = visualLineCount ; int low = - 1 ; int index = visualLineCount ; while ( high - low > 1 ) { index = ( high + low ) / 2 ; int lineStart = visualLines index LINE_OFFSET ; if ( offset > = lineStart ) { int lineEnd = lineStart + visualLines index LINE_LENGTH ; low = index ; if ( offset < = lineEnd ) { break ; } } else { high = index ; } } if ( low > 0 offset = = visualLines low - 1 LINE_OFFSET + visualLines low - 1 LINE_LENGTH ) { / / end of a visual line / beginning of next visual line is ambiguous / / ( they have the same offset ) . always return the first visual line low - - ; } return low ; }', '/ * * * return the number of visual ( wrapped ) lines * see StyledTextContent getLineCount ( ) * / public int getLineCount ( ) { int lineCount = visualLineCount ; / / redirect call to logical content if there are no wrapped lines if ( visualLineCount = = 0 ) { lineCount = logicalContent . getLineCount ( ) ; } return lineCount ; }', '/ * * * see StyledTextContent getLineDelimiter ( ) * / public String getLineDelimiter ( ) { return logicalContent . getLineDelimiter ( ) ; }', '/ * * * return the start offset of the visual ( wrapped ) line at the given * index * see StyledTextContent getOffsetAtLine ( int ) * / public int getOffsetAtLine ( int lineIndex ) { int offset ; / / redirect call to logical content if there are no wrapped lines if ( visualLineCount = = 0 ) { offset = logicalContent . getOffsetAtLine ( lineIndex ) ; } else { offset = visualLines lineIndex LINE_OFFSET ; } return offset ; }', '/ * * * see StyledTextContent getTextRange ( int , int ) * / public String getTextRange ( int start , int length ) { return logicalContent . getTextRange ( start , length ) ; }', '/ * * * Returns the offset of the character after the word at the specified * offset . * < p > * Words are separated by spaces . Trailing spaces are considered part * of the word . * < / p > * * param line logical line the word is in * param startOffset start offset of the line , relative to the start * of the logical line . * param offset offset of the word to return the end of , relative to * the start of the visual line . * return the offset of the character after the word at the specified * offset . * / private int getWordEnd ( String line , int startOffset , int offset ) { int lineLength = line . length ( ) ; offset + = startOffset ; if ( offset > = lineLength ) { return offset - startOffset ; } / / skip over leading whitespace do { offset + + ; } while ( offset < lineLength Compatibility . isSpaceChar ( line . charAt ( offset ) ) ) ; while ( offset < lineLength Compatibility . isSpaceChar ( line . charAt ( offset ) ) = = false ) { offset + + ; } / / skip over trailing whitespace while ( offset < lineLength Compatibility . isSpaceChar ( line . charAt ( offset ) ) ) { offset + + ; } return offset - startOffset ; }', '/ * * * Returns the start offset of the word at the specified offset . * There are two classes of words formed by a sequence of characters : * < p > * Words are separated by spaces . Trailing spaces are considered part * of the word . * < / p > * * param line logical line the word is in * param startOffset start offset of the line , relative to the start * of the logical line . * param offset offset of the word to return the start of , relative to * the start of the visual line . * return the start offset of the word at the specified offset . * / private int getWordStart ( String line , int startOffset , int offset ) { offset + = startOffset ; / / skip over trailing whitespace do { offset - - ; } while ( offset > startOffset Compatibility . isSpaceChar ( line . charAt ( offset ) ) ) ; while ( offset > startOffset Compatibility . isSpaceChar ( line . charAt ( offset - 1 ) ) = = false ) { offset - - ; } return offset - startOffset ; }', '/ * * * see StyledTextContent removeTextChangeListener ( TextChangeListener ) * / public void removeTextChangeListener ( TextChangeListener listener ) { logicalContent . removeTextChangeListener ( listener ) ; }', '/ * * * Reset the visual ( wrapped ) lines in the specified range . * If the range specifies partial logical lines ( e . g . , startLine is * the second of two visual lines ) it is extended to reset all visual * lines of a logical line . * Following the reset the logical lines in the reset visual range are * rewrapped . * < p > * * param startLine index of the first visual line * param lineCount number of visual lines * / void reset ( int startLine , int lineCount ) { if ( lineCount < = 0 visualLineCount = = 0 ) { return ; } reset ( startLine , lineCount , true ) ; }', '/ * * * Reset the visual ( wrapped ) lines in the specified range . * If the range specifies partial logical lines ( e . g . , startLine is * the second of two visual lines ) it is extended to reset all visual * lines of a logical line . * < p > * * param startLine index of the first visual line * param lineCount number of visual lines * param wrap true = rewrap the logical lines in the reset visual range * false = don t rewrap lines . Visual lines will be left in an inconsistent * state since there will be a range of unwrapped and unknown lines . * return the first visual line that was reset * / private int reset ( int startLine , int lineCount , boolean wrap ) { if ( lineCount < = 0 ) { return startLine ; } / / make sure that all visual lines of the first logical line are / / being reset . visualFirstLine is the first visual line of the / / first logical line that has at least one visual line reset . int visualFirstLineOffset = getOffsetAtLine ( startLine ) ; int logicalFirstLine = logicalContent . getLineAtOffset ( visualFirstLineOffset ) ; int logicalFirstLineOffset = logicalContent . getOffsetAtLine ( logicalFirstLine ) ; int visualFirstLine = getLineAtOffset ( logicalFirstLineOffset ) ; lineCount + = startLine - visualFirstLine ; startLine = visualFirstLine ; / / make sure that all visual lines of the last logical line are / / being reset . int lastLine = startLine + lineCount - 1 ; int lastLineEnd = visualLines lastLine LINE_OFFSET + visualLines lastLine LINE_LENGTH ; int logicalEndLine = 0 ; while ( lastLine < visualLineCount - 1 lastLineEnd = = visualLines lastLine + 1 LINE_OFFSET ) { lastLine + + ; lastLineEnd = visualLines lastLine LINE_OFFSET + visualLines lastLine LINE_LENGTH ; } if ( wrap ) { if ( lastLine = = visualLineCount - 1 ) { logicalEndLine = logicalContent . getLineCount ( ) ; } else { logicalEndLine = logicalContent . getLineAtOffset ( visualLines lastLine + 1 LINE_OFFSET ) ; } } lineCount = lastLine - startLine + 1 ; resetVisualLines ( startLine , lineCount ) ; visualLineCount - = lineCount ; if ( wrap ) { / / always recalculate line wrap immediately after a reset / / because the content always needs to be in a usable state . / / i . e . , there must not be any reset but unwrapped lines wrapLineRange ( logicalFirstLine , logicalEndLine , startLine ) ; } return startLine ; }', '/ * * * Reset the visual ( wrapped ) lines in the specified range . * < p > * * param startLine index of the first visual line * param lineCount number of visual lines * / private void resetVisualLines ( int startLine , int lineCount ) { int endLine = startLine + lineCount ; for ( int i = startLine ; i < endLine ; i + + ) { visualLines i = new int { - 1 , - 1 } ; } }', '/ * * * see StyledTextContent replaceTextRange ( int , int , String ) * / public void replaceTextRange ( int start , int replaceLength , String text ) { logicalContent . replaceTextRange ( start , replaceLength , text ) ; }', '/ * * * see StyledTextContent setText ( String ) * / public void setText ( String text ) { logicalContent . setText ( text ) ; }', '/ * * * Set the line wrap data for the specified visual ( wrapped ) line . * < p > * * param visualLineIndex index of the visual line * param visualLineOffset start offset of the visual line , relative * to the start of the document * param visualLineLength length of the visual line * / private void setVisualLine ( int visualLineIndex , int visualLineOffset , int visualLineLength ) { ensureSize ( visualLineCount + 1 ) ; / / is the space for the visual line already taken ? can happen if / / there are more visual lines for a given logical line than before if ( visualLines visualLineIndex LINE_OFFSET ! = - 1 ) { System . arraycopy ( visualLines , visualLineIndex , visualLines , visualLineIndex + 1 , visualLineCount - visualLineIndex ) ; visualLines visualLineIndex = new int 2 ; } visualLines visualLineIndex LINE_OFFSET = visualLineOffset ; visualLines visualLineIndex LINE_LENGTH = visualLineLength ; visualLineCount + + ; }', '/ * * * Recalculates the line wrap for the lines affected by the * text change . * < p > * * param startOffset the start offset of the text change * param newLineCount the number of inserted lines * param replaceLineCount the number of deleted lines * param newCharCount the number of new characters * param replaceCharCount the number of deleted characters * / void textChanged ( int startOffset , int newLineCount , int replaceLineCount , int newCharCount , int replaceCharCount ) { / / do nothing if there are no wrapped lines if ( visualLineCount = = 0 ) { return ; } int logicalStartLine = logicalContent . getLineAtOffset ( startOffset ) ; int visualStartLine = getLineAtOffset ( startOffset ) ; int visualReplaceLastLine = visualLineCount - 1 ; int textChangeDelta = newCharCount - replaceCharCount ; if ( replaceLineCount > 0 ) { visualReplaceLastLine = getLineAtOffset ( startOffset + replaceCharCount ) ; / / at the start of a visual line / end of the previous visual line ? if ( visualReplaceLastLine = = 0 visualLines visualReplaceLastLine LINE_OFFSET = = visualLines visualReplaceLastLine - 1 LINE_OFFSET + visualLines visualReplaceLastLine - 1 LINE_LENGTH ) { visualReplaceLastLine + + ; } visualStartLine = reset ( visualStartLine , visualReplaceLastLine - visualStartLine + 1 , false ) ; } else { visualStartLine = reset ( visualStartLine , 1 , false ) ; } visualReplaceLastLine = wrapLineRange ( logicalStartLine , logicalStartLine + 1 + newLineCount , visualStartLine ) ; for ( int i = visualReplaceLastLine ; i < visualLineCount ; i + + ) { visualLines i LINE_OFFSET + = textChangeDelta ; } }', '/ * * * Measure the width of a segment in the specified logical line . * < p > * * param line the logical line * param logicalLineOffset start offset of the logical line , relative * to the start of the document * param visualLineOffset offset to start measuring at / start offset * of the visual line * param visualLineLength length of the segment to measure / the visual * line * param styles StyleRanges to use during measuring * param startX x position of the visual line relative to the start * of the logical line * param gc GC to use for measuring * param fontData FontData currently set in gc . Used to reduce calls * to gc . getFont ( ) . getFontData ( ) * / private int textWidth ( String line , int logicalLineOffset , int visualLineOffset , int visualLineLength , StyleRange styles , int startX , GC gc , FontData fontData ) { int width ; if ( styles ! = null ) { / / while wrapping a line , the logcial line styles may contain / / style ranges that don t apply ( i . e . , completely on the previous / next / / visual line ) . Therefore we need to filter the logical lines . styles = parent . getVisualLineStyleData ( styles , logicalLineOffset + visualLineOffset , visualLineLength ) ; } if ( parent . isBidi ( ) ) { String wrappedLine = line . substring ( visualLineOffset , visualLineOffset + visualLineLength ) ; StyledTextBidi bidi = parent . getStyledTextBidi ( wrappedLine , logicalLineOffset + visualLineOffset , gc , styles ) ; width = bidi . getTextWidth ( ) ; } else { width = parent . textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength , styles , startX , gc , fontData ) ; } return width ; }', '/ * * * Wrap the given logical line at the specified offset . * Called repeatedly until the entire logical lines has been split into * visual ( wrapped ) lines . * < p > * * param line the logical line * param logicalLineOffset offset of the logical line , relative to the * beginning of the content * param visualLineOffset start offset of the new visual line , relative * to the start of the logical line . * param startX x position of visualLineOffset , relative to the beginning * of the logical line * param width width to wrap the line to * param numChars average number of characters that fit into width * param styles StyleRanges to use for measuring the wrapped line * param gc GC to use for measuring * param fontData FontData currently set in gc . Used to reduce calls to * gc . getFont ( ) . getFontData ( ) * return int 0 = length of the new visual line , int 1 = width in pixels * of the new visual line * / private int wrapLine ( String line , int logicalLineOffset , int visualLineOffset , int startX , int width , int numChars , StyleRange styles , GC gc , FontData fontData ) { int lineLength = line . length ( ) ; int lineWidth = 0 ; int visualLineLength ; numChars = Math . min ( numChars , lineLength - visualLineOffset ) ; visualLineLength = getWordStart ( line , visualLineOffset , numChars ) ; / / find a word that is within the client area . make sure at least one / / character is on each line so that line wrap algorithm terminates . if ( visualLineLength > 0 ) { lineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength , styles , startX , gc , fontData ) ; if ( lineWidth > = width ) { while ( visualLineLength > 1 lineWidth > = width ) { visualLineLength = getWordStart ( line , visualLineOffset , visualLineLength ) ; lineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength , styles , startX , gc , fontData ) ; } } else if ( lineWidth < width ) { while ( visualLineOffset + visualLineLength < lineLength ) { int newLineLength = getWordEnd ( line , visualLineOffset , visualLineLength ) ; int newLineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , newLineLength , styles , startX , gc , fontData ) ; / / would next word be beyond client area ? if ( newLineWidth > = width ) { break ; } else { visualLineLength = newLineLength ; lineWidth = newLineWidth ; } } } } if ( visualLineLength < = 0 ) { / / no complete word fits on the line . either first word was not within / / estimated number of characters or it was beyond the line width even / / though it was within numChars . visualLineLength = numChars ; lineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength , styles , startX , gc , fontData ) ; if ( lineWidth > = width ) { while ( visualLineLength > 1 lineWidth > = width ) { visualLineLength - - ; lineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength , styles , startX , gc , fontData ) ; } } else if ( lineWidth < width ) { while ( visualLineOffset + visualLineLength < lineLength ) { int newLineWidth = textWidth ( line , logicalLineOffset , visualLineOffset , visualLineLength + 1 , styles , startX , gc , fontData ) ; if ( newLineWidth > = width ) { break ; } else { visualLineLength + + ; lineWidth = newLineWidth ; } } } } return new int { visualLineLength , lineWidth } ; }', '/ * * * Wrap the logical lines in the given range at the current client * area width of the StyledText widget * < p > * * param startLine first logical line to wrap * param endLine line after last logical line * param visualLineIndex visual ( wrapped ) line index that startLine * corresponds to . * return index of the line following the last wrapped line * / private int wrapLineRange ( int startLine , int endLine , int visualLineIndex ) { int emptyLineCount = 0 ; visualLineIndex = wrapLineRange ( startLine , endLine , visualLineIndex , parent . getClientArea ( ) . width ) ; / / is there space left for more visual lines ? can happen if there are fewer / / visual lines for a given logical line than before for ( int i = visualLineIndex ; i < visualLines . length ; i + + , emptyLineCount + + ) { if ( visualLines i LINE_OFFSET ! = - 1 ) { break ; } } if ( emptyLineCount > 0 ) { int copyLineCount = visualLineCount - visualLineIndex ; System . arraycopy ( visualLines , visualLineIndex + emptyLineCount , visualLines , visualLineIndex , copyLineCount ) ; resetVisualLines ( visualLineIndex + copyLineCount , emptyLineCount ) ; } return visualLineIndex ; }', '/ * * * Wrap the lines in the given range . Skip lines that have already * been wrapped . * < p > * * param startLine first logical line to wrap * param endLine line after last logical line * param visualLineIndex visual ( wrapped ) line index that startLine * corresponds to . * param width line width to wrap at * return index of last wrapped line * / private int wrapLineRange ( int startLine , int endLine , int visualLineIndex , int width ) { GC gc = new GC ( parent ) ; FontData fontData = gc . getFont ( ) . getFontData ( ) 0 ; int numChars = Math . max ( 1 , width / gc . getFontMetrics ( ) . getAverageCharWidth ( ) ) ; / / if there are no wrapped lines and the width is 0 the widget has / / not been made visible / sized yet . don t wrap until the widget size / / is known . if ( visualLineCount = = 0 width = = 0 ) { return visualLineIndex ; } for ( int i = startLine ; i < endLine ; i + + ) { String line = logicalContent . getLine ( i ) ; int lineOffset = logicalContent . getOffsetAtLine ( i ) ; int lineLength = line . length ( ) ; if ( lineLength = = 0 ) { setVisualLine ( visualLineIndex , lineOffset , 0 ) ; visualLineIndex + + ; continue ; } StyleRange styles = null ; StyledTextEvent event = parent . getLineStyleData ( lineOffset , line ) ; int startOffset = 0 ; int startX = 0 ; if ( event ! = null ) { styles = parent . filterLineStyles ( event . styles ) ; } while ( startOffset < lineLength ) { int result = wrapLine ( line , lineOffset , startOffset , startX , width , numChars , styles , gc , fontData ) ; setVisualLine ( visualLineIndex , lineOffset + startOffset , result WRAP_LINE_LENGTH ) ; startOffset + = result WRAP_LINE_LENGTH ; startX + = result WRAP_LINE_WIDTH ; visualLineIndex + + ; } } gc . dispose ( ) ; return visualLineIndex ; }', '/ * * * Wrap all logical lines at the current client area width of the * StyledText widget * / void wrapLines ( ) { wrapLines ( parent . getClientArea ( ) . width ) ; }', '/ * * * Wrap all logical lines at the given width . * < p > * * param width width to wrap lines at * / void wrapLines ( int width ) { int lineCount = logicalContent . getLineCount ( ) ; visualLineCount = 0 ; visualLines = new int lineCount 2 ; resetVisualLines ( 0 , visualLines . length ) ; wrapLineRange ( 0 , lineCount , 0 , width ) ; }'], 'label': 0}
{'guid': '1839d9b_3e3bcba80bbfef059088451456e7f0cf9cd69bf6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public static void error ( int code ) { error ( code , 0 ) ; }', 'public static void error ( int code , int hresult ) { switch ( code ) { / * OS Failure / Limit ( fatal , may occur only on some platforms ) * / case DND . ERROR_CANNOT_INIT_DRAG : { String msg = DND . INIT_DRAG_MESSAGE ; if ( hresult ! = 0 ) msg + = "result = " + hresult ; throw new SWTError ( code , msg ) ; } case DND . ERROR_CANNOT_INIT_DROP : { String msg = DND . INIT_DROP_MESSAGE ; if ( hresult ! = 0 ) msg + = "result = " + hresult ; throw new SWTError ( code , msg ) ; } case DND . ERROR_CANNOT_SET_CLIPBOARD : { String msg = DND . CANNOT_SET_CLIPBOARD_MESSAGE ; if ( hresult ! = 0 ) msg + = "result = " + hresult ; throw new SWTError ( code , msg ) ; } } / * Unknown / Undefined Error * / SWT . error ( code ) ; }'], 'label': 0}
{'guid': '1839d9b_e0dfd61d960b2c94bdc7ba014bb1957c9b70feae', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_8c20b7365b536a721d892937fbf83c70f2e517b9', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * DNDListener constructor comment . * param listener org . eclipse . swt . internal . SWTEventListener * / DNDListener ( SWTEventListener listener ) { super ( listener ) ; }', 'public void handleEvent ( Event e ) { switch ( e . type ) { case DND . DragStart : { DragSourceEvent event = new DragSourceEvent ( ( DNDEvent ) e ) ; ( ( DragSourceListener ) eventListener ) . dragStart ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragEnd : { DragSourceEvent event = new DragSourceEvent ( ( DNDEvent ) e ) ; ( ( DragSourceListener ) eventListener ) . dragFinished ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragSetData : { DragSourceEvent event = new DragSourceEvent ( ( DNDEvent ) e ) ; ( ( DragSourceListener ) eventListener ) . dragSetData ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragEnter : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . dragEnter ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragLeave : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . dragLeave ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragOver : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . dragOver ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . Drop : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . drop ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DropAccept : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . dropAccept ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } case DND . DragOperationChanged : { DropTargetEvent event = new DropTargetEvent ( ( DNDEvent ) e ) ; ( ( DropTargetListener ) eventListener ) . dragOperationChanged ( event ) ; event . updateEvent ( ( DNDEvent ) e ) ; break ; } } }'], 'label': 0}
{'guid': '1839d9b_30a349cafdc39f8038dc8376c1d05e0e6f949bdc', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public void dragStart ( DragSourceEvent event ) { }', 'public void dragFinished ( DragSourceEvent event ) { }', 'public void dragSetData ( DragSourceEvent event ) { }'], 'label': 0}
{'guid': '1839d9b_f47370a7c6f7c4dc4e1c1442bf5ff7cc9911c9d4', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public DragSourceEvent ( DNDEvent e ) { super ( e ) ; this . data = e . data ; this . detail = e . detail ; this . doit = e . doit ; this . dataType = e . dataType ; }', 'void updateEvent ( DNDEvent e ) { e . widget = this . widget ; e . time = this . time ; e . data = this . data ; e . detail = this . detail ; e . doit = this . doit ; e . dataType = this . dataType ; }'], 'label': 0}
{'guid': '1839d9b_d95288881276fb8c5796112489c0e2406641a877', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * The user has begun the actions required to drag the widget . This event gives the application * the chance to decide if a drag should be started . * * < p > The following fields in the DragSourceEvent apply : * < ul > * < li > widget - ( in ) the DragSource object that initiated the drag * < li > time - ( in ) the time the drop occurred * < li > doit - ( out ) set to fase by default . To cause a drag to begin , set this to true . * < / ul > < / p > * * param event the information associated with the drag finished event * * / public void dragStart ( DragSourceEvent event ) ;', '/ * * * The data is required from the drag source . * * < p > The following fields in the DragSourceEvent apply : * < ul > * < li > widget - ( in ) the DragSource object that initiated the drag * < li > time - ( in ) the time the drop occurred * < li > dataType - ( in ) the type of data requested . This is a TransferData object and can be used with the Transfer subclasses . * < li > data - ( out ) the application inserts the actual data here ( must match the dataType ) * < / ul > < / p > * * param event the information associated with the drag set data event * / public void dragSetData ( DragSourceEvent event ) ;', '/ * * * The drop has successfully completed ( mouse up over a valid target ) or has been terminated ( such as hitting * the ESC key ) . Perform cleanup such as removing data from the source side on a successful move operation . * * < p > The following fields in the DragSourceEvent apply : * < ul > * < li > widget - ( in ) the DragSource object that initiated the drag * < li > time - ( in ) the time the drop occurred * < li > doit - ( in ) true if the operation performed successfully * < li > detail - ( in ) the operation that was performed ( DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * param event the information associated with the drag finished event * * / public void dragFinished ( DragSourceEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_fc55ade742de140ea7639140969b2458412993ba', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['abstract void show ( int effect , int x , int y ) ;'], 'label': 0}
{'guid': '1839d9b_2b551b138cf0523f8f33f67364e2688fb2503eaa', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public void dragEnter ( DropTargetEvent event ) { }', 'public void dragLeave ( DropTargetEvent event ) { }', 'public void dragOperationChanged ( DropTargetEvent event ) { }', 'public void dragOver ( DropTargetEvent event ) { }', 'public void drop ( DropTargetEvent event ) { }', 'public void dropAccept ( DropTargetEvent event ) { }'], 'label': 0}
{'guid': '1839d9b_19dff6355418a2eb64678bbdefaa68a091b8af34', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public DropTargetEvent ( DNDEvent e ) { super ( e ) ; this . data = e . data ; this . x = e . x ; this . y = e . y ; this . detail = e . detail ; this . currentDataType = e . dataType ; this . dataTypes = e . dataTypes ; this . operations = e . operations ; this . feedback = e . feedback ; this . item = e . item ; }', 'void updateEvent ( DNDEvent e ) { e . widget = this . widget ; e . time = this . time ; e . data = this . data ; e . x = this . x ; e . y = this . y ; e . detail = this . detail ; e . dataType = this . currentDataType ; e . dataTypes = this . dataTypes ; e . operations = this . operations ; e . feedback = this . feedback ; e . item = this . item ; }'], 'label': 0}
{'guid': '1839d9b_5defa79fe2af5fe30a516f3a8b134f8b55dc8989', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * The cursor has entered the drop target boundaries . * * < p > The following fields in the DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) dataTypes - a list of the types of data that the < code > DragSource < / code > can support * < li > ( in , out ) currentDataType - the specific type of data that will be provided * < li > ( in ) operations - a list of the operations that the DragSource can support ( e . g . < code > DND . DROP_MOVE DND . DROP_COPY DND . DROP_LINK < / code > ) * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * < p > The application can change the operation that will be performed by modifying the < code > detail < / code > field * but the choice must be one of the values in the < code > operations < / code > field . * The application can also change the type of data being requested by modifying the < code > currentDataTypes < / code > * field but the value must be one of the values in the < code > dataTypes < / code > list . < / p > * * param event the information associated with the drag enter event * * / public void dragEnter ( DropTargetEvent event ) ;', '/ * * * The cursor has left the drop target boundaries . * * < p > The following fields in the DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) dataTypes - a list of the types of data that the < code > DragSource < / code > can support * < li > ( in , out ) currentDataType - the specific type of data that will be provided * < li > ( in ) operations - a list of the operations that the DragSource can support ( e . g . < code > DND . DROP_MOVE DND . DROP_COPY DND . DROP_LINK < / code > ) * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * < p > The application can change the operation that will be performed by modifying the < code > detail < / code > field * but the choice must be one of the values in the < code > operations < / code > field . * The application can also change the type of data being requested by modifying the < code > currentDataTypes < / code > * field but the value must be one of the values in the < code > dataTypes < / code > list . < / p > * * param event the information associated with the drag leave event * * / public void dragLeave ( DropTargetEvent event ) ;', '/ * * * The operation being performed has changed ( usually due to the user changing the selected key while dragging ) . * * < p > The following fields in the DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) dataTypes - a list of the types of data that the < code > DragSource < / code > can support * < li > ( in , out ) currentDataType - the specific type of data that will be provided * < li > ( in ) operations - a list of the operations that the DragSource can support ( e . g . < code > DND . DROP_MOVE DND . DROP_COPY DND . DROP_LINK < / code > ) * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * < p > The application can change the operation that will be performed by modifying the < code > detail < / code > field * but the choice must be one of the values in the < code > operations < / code > field . * The application can also change the type of data being requested by modifying the < code > currentDataTypes < / code > * field but the value must be one of the values in the < code > dataTypes < / code > list . < / p > * * param event the information associated with the drag operation changed event * / public void dragOperationChanged ( DropTargetEvent event ) ;', '/ * * * The cursor is moving over the drop target . * * < p > The following fields in the DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) dataTypes - a list of the types of data that the < code > DragSource < / code > can support * < li > ( in , out ) currentDataType - the specific type of data that will be provided * < li > ( in ) operations - a list of the operations that the DragSource can support ( e . g . < code > DND . DROP_MOVE DND . DROP_COPY DND . DROP_LINK < / code > ) * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * < p > The application can change the operation that will be performed by modifying the < code > detail < / code > field * but the choice must be one of the values in the < code > operations < / code > field . * The application can also change the type of data being requested by modifying the < code > currentDataTypes < / code > * field but the value must be one of the values in the < code > dataTypes < / code > list . < / p > * * param event the information associated with the drag over event * * / public void dragOver ( DropTargetEvent event ) ;', '/ * * * The data is being dropped . * * < p > The following fields in DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < li > ( in ) currentDataType - the specific type of data that will be provided * < li > ( in ) data - the data ( which is of type currentDataType ) * < / ul > < / p > * * < p > The application can refuse to perform the drop operation by setting the detail field to DND . DROP_NONE . < / p > * * param event the information associated with the drop event * * / public void drop ( DropTargetEvent event ) ;', '/ * * * The drop target is given the chance to change the nature of the drop . It can veto the drop by setting the * < code > event . detail < / code > field to < code > DND . DROP_NONE < / code > , it can change the data of data that will be * dropped by setting the < code > event . currentDataType < / code > field to a different value or it can change the * operation that will be performed by changing the < code > event . detail < / code > field . * * < p > The following fields in the DropTargetEvent apply : * < ul > * < li > ( in ) widget - the DragSource object that initiated the drag * < li > ( in ) time - the time the drop occurred * < li > ( in ) x - the x - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) y - the y - cordinate of the cursor relative to the < code > DropTarget Control < / code > * < li > ( in ) dataTypes - a list of the types of data that the < code > DragSource < / code > can support * < li > ( in , out ) currentDataType - the specific type of data that will be provided * < li > ( in ) operations - a list of the operations that the DragSource can support ( e . g . < code > DND . DROP_MOVE DND . DROP_COPY DND . DROP_LINK < / code > ) * < li > ( in , out ) detail - the operation being performed ( one of DND . DROP_MOVE , DND . DROP_COPY , DND . DROP_LINK , DND . DROP_NONE ) * < / ul > < / p > * * < p > The application can change the operation that will be performed by modifying the < code > detail < / code > field * but the choice must be one of the values in the < code > operations < / code > field . * The application can also change the type of data being requested by modifying the < code > currentDataTypes < / code > * field but the value must be one of the values in the < code > dataTypes < / code > list . < / p > * * param event the information associated with the drop accept event * * / public void dropAccept ( DropTargetEvent event ) ;'], 'label': 0}
{'guid': '1839d9b_d3d854a3e7a71ffe4a07d49cfa393faee8f7399e', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['NoDragUnderEffect ( Control control ) { }', 'void show ( int effect , int x , int y ) { }'], 'label': 0}
{'guid': '1839d9b_c8c5e4a05ac9847dad3933a9e9f45bca5e6e8779', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public TransferData getSupportedTypes ( ) { return null ; }', 'public boolean isSupportedType ( TransferData transferData ) { return false ; }'], 'label': 0}
{'guid': '1839d9b_b368acb21434070845763b6cee94a4ba3169ceff', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public Clipboard ( Display display ) { checkSubclass ( ) ; if ( display = = null ) { display = Display . getCurrent ( ) ; if ( display = = null ) { display = Display . getDefault ( ) ; } } if ( display . getThread ( ) ! = Thread . currentThread ( ) ) { SWT . error ( SWT . ERROR_THREAD_INVALID_ACCESS ) ; } this . display = display ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = Clipboard . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }', 'public void dispose ( ) { display = null ; }', 'public Object getContents ( Transfer transfer ) { if ( display . isDisposed ( ) ! ( transfer instanceof TextTransfer ) ) return null ; return display . getData ( "TextTransfer" ) ; }', 'public void setContents ( Object data , Transfer transferAgents ) { if ( data = = null ) { DND . error ( SWT . ERROR_NOT_IMPLEMENTED ) ; } if ( transferAgents = = null data . length ! = transferAgents . length ) { DND . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( display . isDisposed ( ) ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { if ( transferAgents i instanceof TextTransfer data i instanceof String ) { display . setData ( "TextTransfer" , data i ) ; return ; } } }', 'public String getAvailableTypeNames ( ) { return null ; }'], 'label': 0}
{'guid': '1839d9b_1c41d9e326126014455590c5fbb4f32e4e2beaef', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DragSource < / code > to handle dragging from the specified < code > Control < / code > . * * param control the < code > Control < / code > that the user clicks on to initiate the drag * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DragSource ( Control control , int style ) { super ( control , style ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDragListener ( DragSourceListener listener ) { }', 'public Display getDisplay ( ) { return null ; }', '/ * * * Returns the list of data types that can be transferred by this DragSource . * * return the list of data types that can be transferred by this DragSource * / public Transfer getTransfer ( ) { return null ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDragListener ( DragSourceListener listener ) { }', '/ * * * Specifies the list of data types that can be transferred by this DragSource . * The application must be able to provide data to match each of these types when * a successful drop has occurred . * / public void setTransfer ( Transfer transferAgents ) { }', '/ * * * deprecated - use DragSourceListener . dragStart * / public void startDrag ( ) { }'], 'label': 0}
{'guid': '1839d9b_1be0fe0207478e9dded59f6c98ce29a3ba64f942', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DropTarget < / code > to handle dropping on the specified < code > Control < / code > . * * param control the < code > Control < / code > over which the user positions the cursor to drop data * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DropTarget ( Control control , int style ) { super ( control , style ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDropListener ( DropTargetListener listener ) { }', '/ * * * Returns the Control which is registered for this DropTarget . This is the control over which the * user positions the cursor to drop the data . * * return the Control which is registered for this DropTarget * * / public Control getControl ( ) { return null ; }', 'public Display getDisplay ( ) { return null ; }', '/ * * * Returns the list of data types that can be transferred to this DropTarget . * * return the list of data types that can be transferred to this DropTarget * * / public Transfer getTransfer ( ) { return null ; }', 'public void notifyListener ( int eventType , Event event ) { }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDropListener ( DropTargetListener listener ) { }', '/ * * * Specifies the list of data types that can be transferred to this DropTarget . * * param transferAgents a list of Transfer objects which define the types of data that can be * dropped on this target * / public void setTransfer ( Transfer transferAgents ) { }'], 'label': 0}
{'guid': '1839d9b_a3f240b7a60399b69def119a056254c5b0810b54', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private FileTransfer ( ) { }', '/ * * * Returns the singleton instance of the FileTransfer class . * * return the singleton instance of the FileTransfer class * / public static FileTransfer getInstance ( ) { return null ; }', '/ * * * Converts a list of filenames to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a list of file names * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a list of file names to a Java array of String . * * param transferData the platform specific representation of the data that has been transferred * return a Java array of String containing a list of file names if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return null ; }', 'protected int getTypeIds ( ) { return null ; }'], 'label': 0}
{'guid': '1839d9b_490afaebc70d3b963e1b170f4e82143dcb6ab530', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private RTFTransfer ( ) { }', '/ * * * Returns the singleton instance of the RTFTransfer class . * * return the singleton instance of the RTFTransfer class * / public static RTFTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a RTF - formatted Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_6862a2ea48e2a11ea944c5ff042501cfd54eecdf', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TableDragUnderEffect ( Table table ) { this . table = table ; }', 'void show ( int effect , int x , int y ) { TableItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = table . getSelection ( ) ; table . setSelection ( new TableItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { table . setSelection ( selection ) ; selection = new TableItem 0 ; } }', 'private TableItem findItem ( int x , int y ) { if ( table = = null ) return null ; Point coordinates = new Point ( x , y ) ; coordinates = table . toControl ( coordinates ) ; return table . getItem ( coordinates ) ; }', 'private void setDragUnderEffect ( int effect , TableItem item ) { if ( currentItem ! = item ) { if ( item = = null ) { table . setSelection ( new TableItem 0 ) ; } else { table . setSelection ( new TableItem { item } ) ; } currentItem = item ; } currentEffect = effect ; }'], 'label': 0}
{'guid': '1839d9b_d84cbfe40a47cb00d8d4d5034a876ae37e69829a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private TextTransfer ( ) { }', '/ * * * Returns the singleton instance of the TextTransfer class . * * return the singleton instance of the TextTransfer class * / public static TextTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a plain text Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_9dcf84ff27ad809049f581d9bd84e38c9c890c0d', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Returns a list of the data types that can be transferred using this Transfer agent . * * < p > Only the data type fields of the TransferData Object are filled in . < / p > * * return a list of the data types that can be transferred using this Transfer agent * / abstract public TransferData getSupportedTypes ( ) ;', '/ * * * Returns true if the transferData data type can be transferred using this Transfer agent . * * param transferData a platform specific description of a data type ; only the data type fields * of the TransferData Object need to be filled in * * return true if the transferData data type can be transferred using this Transfer agent * / abstract public boolean isSupportedType ( TransferData transferData ) ;', 'abstract protected String getTypeNames ( ) ;', 'abstract protected int getTypeIds ( ) ;', 'abstract protected void javaToNative ( Object object , TransferData transferData ) ;', 'abstract protected Object nativeToJava ( TransferData transferData ) ;', '/ * * * Registers a name for a data type and returns the associated unique identifier . * * < p > You may register the same type more than once , the same unique identifier will be returned if the * type has been previously registered . < / p > * * < p > Note : Do < b > not < / b > call this method with pre - defined Clipboard Format types such as CF_TEXT * or CF_BITMAP because the pre - defined value will not be returned < / p > * * param formatName the name of a data type * * return the unique identifier associated with htis data type * / public static int registerType ( String formatName ) { return 0 ; }'], 'label': 0}
{'guid': '1839d9b_bade8baef0281de34ca2f4e64788f624be5ce5be', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_54ff723827cd38b73dead981e4d9e9b12ac7cc32', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TreeDragUnderEffect ( Tree tree ) { this . tree = tree ; }', 'void show ( int effect , int x , int y ) { TreeItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = tree . getSelection ( ) ; tree . setSelection ( new TreeItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { tree . setSelection ( selection ) ; selection = new TreeItem 0 ; } }', 'private TreeItem findItem ( int x , int y ) { Point coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; return tree . getItem ( coordinates ) ; }', 'private void setDragUnderEffect ( int effect , TreeItem item ) { switch ( effect ) { case DND . FEEDBACK_SELECT : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setDropSelection ( item ) ; currentEffect = DND . FEEDBACK_SELECT ; currentItem = item ; } break ; case DND . FEEDBACK_INSERT_AFTER : case DND . FEEDBACK_INSERT_BEFORE : if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setInsertMark ( item , effect = = DND . FEEDBACK_INSERT_AFTER ) ; currentEffect = effect ; currentItem = item ; } break ; default : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; } if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; } currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; break ; } }', 'private void setDropSelection ( TreeItem item ) { if ( item = = null ) { tree . setSelection ( new TreeItem 0 ) ; } else { tree . setSelection ( new TreeItem { item } ) ; } }', 'private void setInsertMark ( TreeItem item , boolean after ) { / / not currently implemented }'], 'label': 0}
{'guid': '1839d9b_c8c5e4a05ac9847dad3933a9e9f45bca5e6e8779', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public TransferData getSupportedTypes ( ) { return null ; }', 'public boolean isSupportedType ( TransferData transferData ) { return false ; }'], 'label': 0}
{'guid': '1839d9b_b368acb21434070845763b6cee94a4ba3169ceff', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public Clipboard ( Display display ) { checkSubclass ( ) ; if ( display = = null ) { display = Display . getCurrent ( ) ; if ( display = = null ) { display = Display . getDefault ( ) ; } } if ( display . getThread ( ) ! = Thread . currentThread ( ) ) { SWT . error ( SWT . ERROR_THREAD_INVALID_ACCESS ) ; } this . display = display ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = Clipboard . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }', 'public void dispose ( ) { display = null ; }', 'public Object getContents ( Transfer transfer ) { if ( display . isDisposed ( ) ! ( transfer instanceof TextTransfer ) ) return null ; return display . getData ( "TextTransfer" ) ; }', 'public void setContents ( Object data , Transfer transferAgents ) { if ( data = = null ) { DND . error ( SWT . ERROR_NOT_IMPLEMENTED ) ; } if ( transferAgents = = null data . length ! = transferAgents . length ) { DND . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( display . isDisposed ( ) ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { if ( transferAgents i instanceof TextTransfer data i instanceof String ) { display . setData ( "TextTransfer" , data i ) ; return ; } } }', 'public String getAvailableTypeNames ( ) { return null ; }'], 'label': 0}
{'guid': '1839d9b_1c41d9e326126014455590c5fbb4f32e4e2beaef', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DragSource < / code > to handle dragging from the specified < code > Control < / code > . * * param control the < code > Control < / code > that the user clicks on to initiate the drag * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DragSource ( Control control , int style ) { super ( control , style ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDragListener ( DragSourceListener listener ) { }', 'public Display getDisplay ( ) { return null ; }', '/ * * * Returns the list of data types that can be transferred by this DragSource . * * return the list of data types that can be transferred by this DragSource * / public Transfer getTransfer ( ) { return null ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDragListener ( DragSourceListener listener ) { }', '/ * * * Specifies the list of data types that can be transferred by this DragSource . * The application must be able to provide data to match each of these types when * a successful drop has occurred . * / public void setTransfer ( Transfer transferAgents ) { }', '/ * * * deprecated - use DragSourceListener . dragStart * / public void startDrag ( ) { }'], 'label': 0}
{'guid': '1839d9b_1be0fe0207478e9dded59f6c98ce29a3ba64f942', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DropTarget < / code > to handle dropping on the specified < code > Control < / code > . * * param control the < code > Control < / code > over which the user positions the cursor to drop data * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DropTarget ( Control control , int style ) { super ( control , style ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDropListener ( DropTargetListener listener ) { }', '/ * * * Returns the Control which is registered for this DropTarget . This is the control over which the * user positions the cursor to drop the data . * * return the Control which is registered for this DropTarget * * / public Control getControl ( ) { return null ; }', 'public Display getDisplay ( ) { return null ; }', '/ * * * Returns the list of data types that can be transferred to this DropTarget . * * return the list of data types that can be transferred to this DropTarget * * / public Transfer getTransfer ( ) { return null ; }', 'public void notifyListener ( int eventType , Event event ) { }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDropListener ( DropTargetListener listener ) { }', '/ * * * Specifies the list of data types that can be transferred to this DropTarget . * * param transferAgents a list of Transfer objects which define the types of data that can be * dropped on this target * / public void setTransfer ( Transfer transferAgents ) { }'], 'label': 0}
{'guid': '1839d9b_a3f240b7a60399b69def119a056254c5b0810b54', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private FileTransfer ( ) { }', '/ * * * Returns the singleton instance of the FileTransfer class . * * return the singleton instance of the FileTransfer class * / public static FileTransfer getInstance ( ) { return null ; }', '/ * * * Converts a list of filenames to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a list of file names * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a list of file names to a Java array of String . * * param transferData the platform specific representation of the data that has been transferred * return a Java array of String containing a list of file names if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return null ; }', 'protected int getTypeIds ( ) { return null ; }'], 'label': 0}
{'guid': '1839d9b_490afaebc70d3b963e1b170f4e82143dcb6ab530', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private RTFTransfer ( ) { }', '/ * * * Returns the singleton instance of the RTFTransfer class . * * return the singleton instance of the RTFTransfer class * / public static RTFTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a RTF - formatted Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_6862a2ea48e2a11ea944c5ff042501cfd54eecdf', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TableDragUnderEffect ( Table table ) { this . table = table ; }', 'void show ( int effect , int x , int y ) { TableItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = table . getSelection ( ) ; table . setSelection ( new TableItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { table . setSelection ( selection ) ; selection = new TableItem 0 ; } }', 'private TableItem findItem ( int x , int y ) { if ( table = = null ) return null ; Point coordinates = new Point ( x , y ) ; coordinates = table . toControl ( coordinates ) ; return table . getItem ( coordinates ) ; }', 'private void setDragUnderEffect ( int effect , TableItem item ) { if ( currentItem ! = item ) { if ( item = = null ) { table . setSelection ( new TableItem 0 ) ; } else { table . setSelection ( new TableItem { item } ) ; } currentItem = item ; } currentEffect = effect ; }'], 'label': 0}
{'guid': '1839d9b_d84cbfe40a47cb00d8d4d5034a876ae37e69829a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private TextTransfer ( ) { }', '/ * * * Returns the singleton instance of the TextTransfer class . * * return the singleton instance of the TextTransfer class * / public static TextTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a plain text Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { return null ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_9dcf84ff27ad809049f581d9bd84e38c9c890c0d', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Returns a list of the data types that can be transferred using this Transfer agent . * * < p > Only the data type fields of the TransferData Object are filled in . < / p > * * return a list of the data types that can be transferred using this Transfer agent * / abstract public TransferData getSupportedTypes ( ) ;', '/ * * * Returns true if the transferData data type can be transferred using this Transfer agent . * * param transferData a platform specific description of a data type ; only the data type fields * of the TransferData Object need to be filled in * * return true if the transferData data type can be transferred using this Transfer agent * / abstract public boolean isSupportedType ( TransferData transferData ) ;', 'abstract protected String getTypeNames ( ) ;', 'abstract protected int getTypeIds ( ) ;', 'abstract protected void javaToNative ( Object object , TransferData transferData ) ;', 'abstract protected Object nativeToJava ( TransferData transferData ) ;', '/ * * * Registers a name for a data type and returns the associated unique identifier . * * < p > You may register the same type more than once , the same unique identifier will be returned if the * type has been previously registered . < / p > * * < p > Note : Do < b > not < / b > call this method with pre - defined Clipboard Format types such as CF_TEXT * or CF_BITMAP because the pre - defined value will not be returned < / p > * * param formatName the name of a data type * * return the unique identifier associated with htis data type * / public static int registerType ( String formatName ) { return 0 ; }'], 'label': 0}
{'guid': '1839d9b_bade8baef0281de34ca2f4e64788f624be5ce5be', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_54ff723827cd38b73dead981e4d9e9b12ac7cc32', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TreeDragUnderEffect ( Tree tree ) { this . tree = tree ; }', 'void show ( int effect , int x , int y ) { TreeItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = tree . getSelection ( ) ; tree . setSelection ( new TreeItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { tree . setSelection ( selection ) ; selection = new TreeItem 0 ; } }', 'private TreeItem findItem ( int x , int y ) { Point coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; return tree . getItem ( coordinates ) ; }', 'private void setDragUnderEffect ( int effect , TreeItem item ) { switch ( effect ) { case DND . FEEDBACK_SELECT : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setDropSelection ( item ) ; currentEffect = DND . FEEDBACK_SELECT ; currentItem = item ; } break ; case DND . FEEDBACK_INSERT_AFTER : case DND . FEEDBACK_INSERT_BEFORE : if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setInsertMark ( item , effect = = DND . FEEDBACK_INSERT_AFTER ) ; currentEffect = effect ; currentItem = item ; } break ; default : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; } if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; } currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; break ; } }', 'private void setDropSelection ( TreeItem item ) { if ( item = = null ) { tree . setSelection ( new TreeItem 0 ) ; } else { tree . setSelection ( new TreeItem { item } ) ; } }', 'private void setInsertMark ( TreeItem item , boolean after ) { / / not currently implemented }'], 'label': 0}
{'guid': '1839d9b_de4a1159a9520b52f96711c16eed7d4d0a8a7039', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public TransferData getSupportedTypes ( ) { int types = getTypeIds ( ) ; TransferData data = new TransferData types . length ; for ( int i = 0 ; i < types . length ; i + + ) { data i = new TransferData ( ) ; data i . type = types i ; } return data ; }', 'public boolean isSupportedType ( TransferData transferData ) { int types = getTypeIds ( ) ; for ( int i = 0 ; i < types . length ; i + + ) { if ( transferData . type = = types i ) return true ; } return false ; }', 'protected void javaToNative ( Object object , TransferData transferData ) { if ( ( object = = null ) ! ( object instanceof byte ) ! ( isSupportedType ( transferData ) ) ) { transferData . result = 0 ; return ; } byte buffer = ( byte ) object ; transferData . pValue = OS . XtMalloc ( buffer . length + 1 ) ; OS . memmove ( transferData . pValue , buffer , buffer . length ) ; transferData . length = buffer . length ; transferData . format = 8 ; transferData . result = 1 ; }', 'protected Object nativeToJava ( TransferData transferData ) { if ( transferData . pValue = = 0 ! ( isSupportedType ( transferData ) ) ) return null ; int size = transferData . format * transferData . length / 8 ; byte buffer = new byte size ; OS . memmove ( buffer , transferData . pValue , size ) ; return buffer ; }'], 'label': 0}
{'guid': '1839d9b_4bf7a126ff99fba9bfce84624bf40b410eb359a6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public Clipboard ( Display display ) { checkSubclass ( ) ; if ( display = = null ) { display = Display . getCurrent ( ) ; if ( display = = null ) { display = Display . getDefault ( ) ; } } if ( display . getThread ( ) ! = Thread . currentThread ( ) ) { SWT . error ( SWT . ERROR_THREAD_INVALID_ACCESS ) ; } this . display = display ; int widgetClass = OS . TopLevelShellWidgetClass ( ) ; shellHandle = OS . XtAppCreateShell ( null , null , widgetClass , display . xDisplay , null , 0 ) ; OS . XtSetMappedWhenManaged ( shellHandle , false ) ; OS . XtRealizeWidget ( shellHandle ) ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = Clipboard . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }', 'public void dispose ( ) { if ( shellHandle ! = 0 ) OS . XtDestroyWidget ( shellHandle ) ; shellHandle = 0 ; display = null ; }', 'public Object getContents ( Transfer transfer ) { if ( display . isDisposed ( ) ) return null ; int xDisplay = OS . XtDisplay ( shellHandle ) ; if ( xDisplay = = 0 ) return null ; int xWindow = OS . XtWindow ( shellHandle ) ; if ( xWindow = = 0 ) return null ; / / Open clipboard for retrieval int retries = 0 ; int status = OS . XmClipboardStartRetrieve ( xDisplay , xWindow , OS . XtLastTimestampProcessed ( xDisplay ) ) ; while ( status = = OS . XmClipboardLocked retries < MAX_RETRIES ) { retries + + ; status = OS . XmClipboardStartRetrieve ( xDisplay , xWindow , OS . XtLastTimestampProcessed ( xDisplay ) ) ; } ; if ( status ! = OS . XmClipboardSuccess ) return null ; / / Does Clipboard have data in required format ? String type = null ; int length = new int 1 ; String supportedTypes = transfer . getTypeNames ( ) ; for ( int i = 0 ; i < supportedTypes . length ; i + + ) { if ( OS . XmClipboardInquireLength ( xDisplay , xWindow , supportedTypes i . getBytes ( ) , length ) = = 1 / * OS . XmClipboardSuccess * / ) { type = supportedTypes i ; break ; } } / / Retrieve data from Clipboard byte data = null ; if ( type ! = null ) { data = new byte length 0 ; status = OS . XmClipboardRetrieve ( xDisplay , xWindow , type . getBytes ( ) , data , length 0 , new int 1 , new int 1 ) ; if ( status ! = OS . XmClipboardSuccess ) { data = null ; } } / / Close Clipboard status = OS . XmClipboardEndRetrieve ( xDisplay , xWindow ) ; if ( data = = null ) return null ; / / Pass data to transfer agent for conversion to a Java Object / / Memory is allocated here to emulate the way Drag and Drop transfers data . TransferData transferData = new TransferData ( ) ; / * Use the character encoding for the default locale * / byte bName = Converter . wcsToMbcs ( null , type , false ) ; transferData . type = OS . XmInternAtom ( xDisplay , bName , false ) ; transferData . pValue = OS . XtMalloc ( data . length ) ; OS . memmove ( transferData . pValue , data , data . length ) ; transferData . length = data . length ; transferData . format = 8 ; transferData . result = 1 ; Object result = transfer . nativeToJava ( transferData ) ; / / Clean up allocated memory OS . XtFree ( transferData . pValue ) ; return result ; }', 'public void setContents ( Object data , Transfer transferAgents ) { if ( data = = null ) { DND . error ( SWT . ERROR_NOT_IMPLEMENTED ) ; } if ( transferAgents = = null data . length ! = transferAgents . length ) { DND . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( display . isDisposed ( ) ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; int xDisplay = OS . XtDisplay ( shellHandle ) ; if ( xDisplay = = 0 ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; int xWindow = OS . XtWindow ( shellHandle ) ; if ( xWindow = = 0 ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; / / Open clipboard for setting int item_id = new int 1 ; int retries = 0 ; int status = OS . XmClipboardStartCopy ( xDisplay , xWindow , 0 , OS . XtLastTimestampProcessed ( xDisplay ) , shellHandle , 0 , item_id ) ; while ( status = = OS . XmClipboardLocked retries < MAX_RETRIES ) { retries + + ; status = OS . XmClipboardStartCopy ( xDisplay , xWindow , 0 , OS . XtLastTimestampProcessed ( xDisplay ) , shellHandle , 0 , item_id ) ; } ; if ( status ! = OS . XmClipboardSuccess ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; / / copy data directly over to System clipboard ( not deferred ) for ( int i = 0 ; i < transferAgents . length ; i + + ) { String names = transferAgents i . getTypeNames ( ) ; for ( int j = 0 ; j < names . length ; j + + ) { TransferData transferData = new TransferData ( ) ; / * Use the character encoding for the default locale * / byte bName = Converter . wcsToMbcs ( null , names j , false ) ; transferData . type = OS . XmInternAtom ( xDisplay , bName , false ) ; transferAgents i . javaToNative ( data i , transferData ) ; status = OS . XmClipboardFail ; if ( transferData . result = = 1 transferData . format = = 8 ) { byte buffer = new byte transferData . length ; OS . memmove ( buffer , transferData . pValue , transferData . length ) ; status = OS . XmClipboardCopy ( xDisplay , xWindow , item_id 0 , bName , buffer , transferData . length , 0 , null ) ; } / / Clean up allocated memory if ( transferData . pValue ! = 0 ) { OS . XtFree ( transferData . pValue ) ; } } } / / close clipboard for setting OS . XmClipboardEndCopy ( xDisplay , xWindow , item_id 0 ) ; if ( status ! = OS . XmClipboardSuccess ) DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; }', 'public String getAvailableTypeNames ( ) { int count = new int 1 ; int max_length = new int 1 ; int xDisplay = OS . XtDisplay ( shellHandle ) ; if ( xDisplay = = 0 ) DND . error ( SWT . ERROR_UNSPECIFIED ) ; int xWindow = OS . XtWindow ( shellHandle ) ; if ( xWindow = = 0 ) DND . error ( SWT . ERROR_UNSPECIFIED ) ; if ( OS . XmClipboardInquireCount ( xDisplay , xWindow , count , max_length ) ! = OS . XmClipboardSuccess ) DND . error ( SWT . ERROR_UNSPECIFIED ) ; String types = new String count 0 ; for ( int i = 0 ; i < count 0 ; i + + ) { byte buffer = new byte max_length 0 ; int copied_length = new int 1 ; int rc = OS . XmClipboardInquireFormat ( xDisplay , xWindow , i + 1 , buffer , buffer . length , copied_length ) ; if ( rc = = OS . XmClipboardNoData ) { types i = "" ; continue ; } if ( rc ! = OS . XmClipboardSuccess ) DND . error ( SWT . ERROR_UNSPECIFIED ) ; byte buffer2 = new byte copied_length 0 ; System . arraycopy ( buffer , 0 , buffer2 , 0 , copied_length 0 ) ; types i = new String ( buffer2 ) ; } return types ; }'], 'label': 0}
{'guid': '1839d9b_38b3e085684c40511b39b05be200278690980f42', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DragSource < / code > to handle dragging from the specified < code > Control < / code > . * * param control the < code > Control < / code > that the user clicks on to initiate the drag * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DragSource ( Control control , int style ) { super ( control , checkStyle ( style ) ) ; this . control = control ; controlListener = new Listener ( ) { public void handleEvent ( Event event ) { if ( event . type = = SWT . Dispose ) { if ( ! DragSource . this . isDisposed ( ) ) { DragSource . this . dispose ( ) ; } } if ( event . type = = SWT . DragDetect ) { DragSource . this . drag ( ) ; } } } ; this . control . addListener ( SWT . Dispose , controlListener ) ; this . control . addListener ( SWT . DragDetect , controlListener ) ; this . addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { onDispose ( ) ; } } ) ; }', 'public void handleEvent ( Event event ) { if ( event . type = = SWT . Dispose ) { if ( ! DragSource . this . isDisposed ( ) ) { DragSource . this . dispose ( ) ; } } if ( event . type = = SWT . DragDetect ) { DragSource . this . drag ( ) ; } }', 'public void handleEvent ( Event event ) { onDispose ( ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDragListener ( DragSourceListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; DNDListener typedListener = new DNDListener ( listener ) ; addListener ( DND . DragStart , typedListener ) ; addListener ( DND . DragSetData , typedListener ) ; addListener ( DND . DragEnd , typedListener ) ; }', 'static int checkStyle ( int style ) { if ( style = = SWT . NONE ) return DND . DROP_MOVE ; return style ; }', 'private int convertProcCallback ( int widget , int pSelection , int pTarget , int pType_return , int ppValue_return , int pLength_return , int pFormat_return , int max_length , int client_data , int request_id ) { / * pSelection - atom specifying which property is being used to transfer the selection ( only support _MOTIF_DROP ) pTarget - atom specifying the type in which the requestor wants the information pType_return - out type atom that data has been converted to ( usually the same as pTarget ) ppValue_return - out set to a pointer to a block of memory pLength_return - out number of elements in the array pFormat_return - out size in bits of each element in the array * / if ( pSelection = = 0 ) return 0 ; / / is this a drop ? int selection = new int 1 ; OS . memmove ( selection , pSelection , 4 ) ; int motifDropAtom = Transfer . registerType ( "_MOTIF_DROP 0" ) ; if ( selection 0 ! = motifDropAtom ) return 0 ; / / get the target value from pTarget int target = new int 1 ; OS . memmove ( target , pTarget , 4 ) ; / / handle the "Move" case if ( target 0 = = Transfer . registerType ( "DELETE 0" ) ) { / / DELETE corresponds to a Move request moveRequested = true ; OS . memmove ( pType_return , new int { Transfer . registerType ( "NULL 0" ) } , 4 ) ; OS . memmove ( ppValue_return , new int { 0 } , 4 ) ; OS . memmove ( pLength_return , new int { 0 } , 4 ) ; OS . memmove ( pFormat_return , new int { 8 } , 4 ) ; return 1 ; } / / do we support the requested data type ? boolean dataMatch = true ; TransferData transferData = new TransferData ( ) ; transferData . type = target 0 ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { if ( transferAgents i . isSupportedType ( transferData ) ) { dataMatch = true ; break ; } } if ( ! dataMatch ) return 0 ; DNDEvent event = new DNDEvent ( ) ; event . widget = control ; / / event . time = ? ? ; event . dataType = transferData ; try { notifyListeners ( DND . DragSetData , event ) ; } catch ( Throwable err ) { return 0 ; } if ( event . data = = null ) return 0 ; Transfer transferAgent = null ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { if ( transferAgents i . isSupportedType ( transferData ) ) { transferAgent = transferAgents i ; break ; } } if ( transferAgent = = null ) return 0 ; transferAgent . javaToNative ( event . data , transferData ) ; if ( transferData . result = = 1 ) { OS . memmove ( ppValue_return , new int { transferData . pValue } , 4 ) ; OS . memmove ( pType_return , new int { transferData . type } , 4 ) ; OS . memmove ( pLength_return , new int { transferData . length } , 4 ) ; OS . memmove ( pFormat_return , new int { transferData . format } , 4 ) ; return 1 ; } else { OS . memmove ( ppValue_return , new int { 0 } , 4 ) ; OS . memmove ( pLength_return , new int { 0 } , 4 ) ; OS . memmove ( pFormat_return , new int { 8 } , 4 ) ; return 0 ; } }', 'private void drag ( ) { if ( transferAgents = = null ) return ; / / Current event must be a Button Press event Display display = control . getDisplay ( ) ; if ( display . xEvent . type ! = OS . ButtonPress ) return ; DNDEvent event = new DNDEvent ( ) ; event . widget = this ; event . time = display . xEvent . pad2 ; event . doit = true ; try { notifyListeners ( DND . DragStart , event ) ; } catch ( Throwable e ) { event . doit = false ; } if ( ! event . doit ) { int time = display . xEvent . pad2 ; / / corresponds to time field in XButtonEvent int dc = OS . XmGetDragContext ( control . handle , time ) ; if ( dc ! = 0 ) { OS . XmDragCancel ( dc ) ; } return ; } / / set the protocol ( optional ) / / not implemented / / create pixmaps for icons ( optional ) / / not implemented / / Copy targets to global memory TransferData transferData = new TransferData 0 ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { TransferData data = transferAgents i . getSupportedTypes ( ) ; TransferData newTransferData = new TransferData transferData . length + data . length ; System . arraycopy ( transferData , 0 , newTransferData , 0 , transferData . length ) ; System . arraycopy ( data , 0 , newTransferData , transferData . length , data . length ) ; transferData = newTransferData ; } int dataTypes = new int transferData . length ; for ( int i = 0 ; i < transferData . length ; i + + ) { dataTypes i = transferData i . type ; } int pExportTargets = OS . XtMalloc ( dataTypes . length * 4 ) ; OS . memmove ( pExportTargets , dataTypes , dataTypes . length * 4 ) ; if ( convertProc = = null ) convertProc = new Callback ( this , "convertProcCallback" , 10 ) ; if ( convertProc = = null ) return ; int args = new int { OS . XmNexportTargets , pExportTargets , OS . XmNnumExportTargets , dataTypes . length , OS . XmNdragOperations , opToOsOp ( getStyle ( ) ) , OS . XmNconvertProc , convertProc . getAddress ( ) , OS . XmNoperationCursorIcon , 0 , OS . XmNsourceCursorIcon , 0 , OS . XmNstateCursorIcon , 0 , OS . XmNclientData , 0 , OS . XmNblendModel , OS . XmBLEND_ALL } ; / / look for existing drag contexts int time = display . xEvent . pad2 ; / / corresponds to time field in XButtonEvent dragContext = OS . XmGetDragContext ( control . handle , time ) ; if ( dragContext ! = 0 ) { OS . XtSetValues ( dragContext , args , args . length / 2 ) ; } else { dragContext = OS . XmDragStart ( this . control . handle , display . xEvent , args , args . length / 2 ) ; } OS . XtFree ( pExportTargets ) ; if ( dragContext = = 0 ) return ; / / register a call back to clean up when drop is done ( optional ) if ( dragDropFinish = = null ) dragDropFinish = new Callback ( this , "dragDropFinishCallback" , 3 ) ; OS . XtAddCallback ( dragContext , OS . XmNdragDropFinishCallback , dragDropFinish . getAddress ( ) , 0 ) ; / / register a call back to tell user what happened ( optional ) if ( dropFinish = = null ) dropFinish = new Callback ( this , "dropFinishCallback" , 3 ) ; OS . XtAddCallback ( dragContext , OS . XmNdropFinishCallback , dropFinish . getAddress ( ) , 0 ) ; return ; }', 'private int dragDropFinishCallback ( int widget , int client_data , int call_data ) { / / uncomment the following code when we allow users to specify their own source icons / / release the pre set source icon / / int pSourceIcon = OS . XtMalloc ( 4 ) ; / / int args = new int { OS . XmNsourceCursorIcon , pSourceIcon } ; / / OS . XtGetValues ( control . handle , args , args . length / 2 ) ; / / int sourceIcon = new int 1 ; / / OS . memmove ( sourceIcon , pSourceIcon , 4 ) ; / / if ( sourceIcon 0 ! = 0 ) / / OS . XtDestroyWidget ( sourceIcon 0 ) ; / / OS . XtFree ( pSourceIcon ) ; dragContext = 0 ; if ( convertProc ! = null ) convertProc . dispose ( ) ; convertProc = null ; if ( dragDropFinish ! = null ) dragDropFinish . dispose ( ) ; dragDropFinish = null ; if ( dropFinish ! = null ) dropFinish . dispose ( ) ; dropFinish = null ; return 0 ; }', 'private int dropFinishCallback ( int widget , int client_data , int call_data ) { XmDropFinishCallback data = new XmDropFinishCallback ( ) ; OS . memmove ( data , call_data , XmDropFinishCallback . sizeof ) ; if ( data . dropAction ! = OS . XmDROP data . dropSiteStatus ! = OS . XmDROP_SITE_VALID ) return 0 ; DNDEvent event = new DNDEvent ( ) ; event . widget = this . control ; event . time = data . timeStamp ; if ( moveRequested ) { event . detail = DND . DROP_MOVE ; } else { if ( data . operation = = OS . XmDROP_MOVE ) { event . detail = DND . DROP_NONE ; } else { event . detail = osOpToOp ( data . operation ) ; } } event . doit = ( data . completionStatus ! = 0 ) ; try { notifyListeners ( DND . DragEnd , event ) ; } catch ( Throwable err ) { } moveRequested = false ; return 0 ; }', '/ * * * Returns the Control which is registered for this DragSource . This is the control that the * user clicks in to initiate dragging . * * return the Control which is registered for this DragSource * / public Control getControl ( ) { return control ; }', '/ * * * Gets the Display . * / public Display getDisplay ( ) { if ( control = = null ) DND . error ( SWT . ERROR_WIDGET_DISPOSED ) ; return control . getDisplay ( ) ; }', '/ * * * Returns the list of data types that can be transferred by this DragSource . * * return the list of data types that can be transferred by this DragSource * / public Transfer getTransfer ( ) { return transferAgents ; }', 'private void onDispose ( ) { if ( convertProc ! = null ) convertProc . dispose ( ) ; convertProc = null ; if ( dragDropFinish ! = null ) dragDropFinish . dispose ( ) ; dragDropFinish = null ; if ( dropFinish ! = null ) dropFinish . dispose ( ) ; dropFinish = null ; if ( control ! = null controlListener ! = null ) { control . removeListener ( SWT . Dispose , controlListener ) ; control . removeListener ( SWT . DragDetect , controlListener ) ; } control = null ; controlListener = null ; transferAgents = null ; }', 'private byte opToOsOp ( int operation ) { byte osOperation = OS . XmDROP_NOOP ; if ( ( operation DND . DROP_COPY ) = = DND . DROP_COPY ) osOperation = OS . XmDROP_COPY ; if ( ( operation DND . DROP_MOVE ) = = DND . DROP_MOVE ) osOperation = OS . XmDROP_MOVE ; if ( ( operation DND . DROP_LINK ) = = DND . DROP_LINK ) osOperation = OS . XmDROP_LINK ; return osOperation ; }', 'private int osOpToOp ( byte osOperation ) { int operation = DND . DROP_NONE ; if ( ( osOperation OS . XmDROP_COPY ) = = OS . XmDROP_COPY ) operation = DND . DROP_COPY ; if ( ( osOperation OS . XmDROP_MOVE ) = = OS . XmDROP_MOVE ) operation = DND . DROP_MOVE ; if ( ( osOperation OS . XmDROP_LINK ) = = OS . XmDROP_LINK ) operation = DND . DROP_LINK ; return operation ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDragListener ( DragSourceListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( DND . DragStart , listener ) ; removeListener ( DND . DragSetData , listener ) ; removeListener ( DND . DragEnd , listener ) ; }', '/ * * * Specifies the list of data types that can be transferred by this DragSource . * The application must be able to provide data to match each of these types when * a successful drop has occurred . * / public void setTransfer ( Transfer transferAgents ) { this . transferAgents = transferAgents ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = DragSource . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }'], 'label': 0}
{'guid': '1839d9b_8f5421a2c994cc9b40dc66865754d32a42eb9755', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DropTarget < / code > to handle dropping on the specified < code > Control < / code > . * * param control the < code > Control < / code > over which the user positions the cursor to drop data * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DropTarget ( Control control , int style ) { super ( control , checkStyle ( style ) ) ; this . control = control ; dropProc = new Callback ( this , "dropProcCallback" , 3 ) ; if ( dropProc = = null ) DND . error ( DND . ERROR_CANNOT_INIT_DROP ) ; dragProc = new Callback ( this , "dragProcCallback" , 3 ) ; if ( dragProc = = null ) DND . error ( DND . ERROR_CANNOT_INIT_DROP ) ; int args = new int { OS . XmNdropSiteOperations , opToOsOp ( style ) , OS . XmNdropSiteActivity , OS . XmDROP_SITE_ACTIVE , OS . XmNdropProc , dropProc . getAddress ( ) , OS . XmNdragProc , dragProc . getAddress ( ) , OS . XmNanimationStyle , OS . XmDRAG_UNDER_NONE , OS . XmNdropSiteType , OS . XmDROP_SITE_COMPOSITE , } ; / / the OS may have registered this widget as a drop site on creation . / / Remove the registered drop site because it has preconfigured values which we do not want . / / OS . XmDropSiteUnregister ( control . handle ) ; / / Register drop site with our own values OS . XmDropSiteRegister ( control . handle , args , args . length / 2 ) ; controlListener = new Listener ( ) { public void handleEvent ( Event event ) { if ( ! DropTarget . this . isDisposed ( ) ) { DropTarget . this . dispose ( ) ; } } } ; control . addListener ( SWT . Dispose , controlListener ) ; this . addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { onDispose ( ) ; } } ) ; if ( control instanceof Tree ) { effect = new TreeDragUnderEffect ( ( Tree ) control ) ; } else if ( control instanceof Table ) { effect = new TableDragUnderEffect ( ( Table ) control ) ; } else { effect = new NoDragUnderEffect ( control ) ; } }', 'public void handleEvent ( Event event ) { if ( ! DropTarget . this . isDisposed ( ) ) { DropTarget . this . dispose ( ) ; } }', 'public void handleEvent ( Event event ) { onDispose ( ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDropListener ( DropTargetListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; DNDListener typedListener = new DNDListener ( listener ) ; addListener ( DND . DragEnter , typedListener ) ; addListener ( DND . DragLeave , typedListener ) ; addListener ( DND . DragOver , typedListener ) ; addListener ( DND . DragOperationChanged , typedListener ) ; addListener ( DND . Drop , typedListener ) ; addListener ( DND . DropAccept , typedListener ) ; }', 'static int checkStyle ( int style ) { if ( style = = SWT . NONE ) return DND . DROP_MOVE ; return style ; }', 'private void updateDragOverHover ( long delay , DNDEvent event ) { if ( delay = = 0 ) { dragOverStart = 0 ; dragOverEvent = null ; dragOverHeartbeat = null ; return ; } dragOverStart = System . currentTimeMillis ( ) + delay ; if ( dragOverEvent = = null ) dragOverEvent = new DNDEvent ( ) ; dragOverEvent . x = event . x ; dragOverEvent . y = event . y ; dragOverEvent . dataTypes = event . dataTypes ; dragOverEvent . operations = event . operations ; dragOverEvent . dataType = event . dataType ; dragOverEvent . detail = event . detail ; }', 'private int dragProcCallback ( int widget , int client_data , int call_data ) { XmDragProcCallback callbackData = new XmDragProcCallback ( ) ; OS . memmove ( callbackData , call_data , XmDragProcCallback . sizeof ) ; if ( callbackData . reason = = OS . XmCR_DROP_SITE_ENTER_MESSAGE ) { releaseDropInfo ( ) ; / / get the export targets int ppExportTargets = OS . XtMalloc ( 4 ) ; int pNumExportTargets = OS . XtMalloc ( 4 ) ; int args = new int { OS . XmNexportTargets , ppExportTargets , OS . XmNnumExportTargets , pNumExportTargets } ; OS . XtGetValues ( callbackData . dragContext , args , args . length / 2 ) ; int numExportTargets = new int 1 ; OS . memmove ( numExportTargets , pNumExportTargets , 4 ) ; OS . XtFree ( pNumExportTargets ) ; int pExportTargets = new int 1 ; OS . memmove ( pExportTargets , ppExportTargets , 4 ) ; OS . XtFree ( ppExportTargets ) ; int exportTargets = new int numExportTargets 0 ; OS . memmove ( exportTargets , pExportTargets 0 , 4 * numExportTargets 0 ) ; / / ? OS . XtFree ( pExportTargets 0 ) ; for ( int i = 0 , length = exportTargets . length ; i < length ; i + + ) { for ( int j = 0 , length2 = transferAgents . length ; j < length2 ; j + + ) { TransferData transferData = new TransferData ( ) ; transferData . type = exportTargets i ; if ( transferAgents j . isSupportedType ( transferData ) ) { TransferData newDataTypes = new TransferData dataTypes . length + 1 ; System . arraycopy ( dataTypes , 0 , newDataTypes , 0 , dataTypes . length ) ; newDataTypes dataTypes . length = transferData ; dataTypes = newDataTypes ; break ; } } } } DNDEvent event = new DNDEvent ( ) ; event . widget = this . control ; event . time = callbackData . timeStamp ; short root_x = new short 1 ; short root_y = new short 1 ; OS . XtTranslateCoords ( this . control . handle , ( short ) callbackData . x , ( short ) callbackData . y , root_x , root_y ) ; event . x = root_x 0 ; event . y = root_y 0 ; event . dataTypes = dataTypes ; event . feedback = DND . FEEDBACK_SELECT ; event . operations = osOpToOp ( callbackData . operations ) ; event . dataType = selectedDataType ; event . detail = osOpToOp ( callbackData . operation ) ; try { switch ( callbackData . reason ) { case OS . XmCR_DROP_SITE_ENTER_MESSAGE : if ( dataTypes . length > 0 ) { event . dataType = dataTypes 0 ; } dragOverHeartbeat = new Runnable ( ) { public void run ( ) { if ( control . isDisposed ( ) dragOverStart = = 0 ) return ; long time = System . currentTimeMillis ( ) ; int delay = DRAGOVER_HYSTERESIS ; if ( time > = dragOverStart ) { DNDEvent event = new DNDEvent ( ) ; event . widget = control ; event . time = ( int ) time ; event . x = dragOverEvent . x ; event . y = dragOverEvent . y ; event . dataTypes = dragOverEvent . dataTypes ; event . feedback = DND . FEEDBACK_SELECT ; event . operations = dragOverEvent . operations ; event . dataType = dragOverEvent . dataType ; event . detail = dragOverEvent . detail ; notifyListeners ( DND . DragOver , event ) ; effect . show ( event . feedback , event . x , event . y ) ; } else { delay = ( int ) ( dragOverStart - time ) ; } control . getDisplay ( ) . timerExec ( delay , dragOverHeartbeat ) ; } } ; updateDragOverHover ( DRAGOVER_HYSTERESIS , event ) ; notifyListeners ( DND . DragEnter , event ) ; effect . show ( event . feedback , event . x , event . y ) ; dragOverHeartbeat . run ( ) ; break ; case OS . XmCR_DROP_SITE_MOTION_MESSAGE : updateDragOverHover ( DRAGOVER_HYSTERESIS , event ) ; notifyListeners ( DND . DragOver , event ) ; effect . show ( event . feedback , event . x , event . y ) ; break ; case OS . XmCR_OPERATION_CHANGED : updateDragOverHover ( DRAGOVER_HYSTERESIS , event ) ; notifyListeners ( DND . DragOperationChanged , event ) ; effect . show ( event . feedback , event . x , event . y ) ; break ; case OS . XmCR_DROP_SITE_LEAVE_MESSAGE : event . detail = DND . DROP_NONE ; updateDragOverHover ( 0 , null ) ; notifyListeners ( DND . DragLeave , event ) ; effect . show ( DND . FEEDBACK_NONE , 0 , 0 ) ; return 0 ; } } catch ( Throwable err ) { callbackData . dropSiteStatus = OS . XmDROP_SITE_INVALID ; callbackData . operation = opToOsOp ( DND . DROP_NONE ) ; OS . memmove ( call_data , callbackData , XmDragProcCallback . sizeof ) ; return 0 ; } selectedDataType = null ; for ( int i = 0 ; i < dataTypes . length ; i + + ) { if ( dataTypes i . equals ( event . dataType ) ) { selectedDataType = event . dataType ; break ; } } int lastOperation = DND . DROP_NONE ; if ( selectedDataType ! = null ( ( event . detail osOpToOp ( callbackData . operations ) ) = = event . detail ) ) { lastOperation = event . detail ; } callbackData . dropSiteStatus = OS . XmDROP_SITE_VALID ; callbackData . operation = opToOsOp ( lastOperation ) ; OS . memmove ( call_data , callbackData , XmDragProcCallback . sizeof ) ; return 0 ; }', 'public void run ( ) { if ( control . isDisposed ( ) dragOverStart = = 0 ) return ; long time = System . currentTimeMillis ( ) ; int delay = DRAGOVER_HYSTERESIS ; if ( time > = dragOverStart ) { DNDEvent event = new DNDEvent ( ) ; event . widget = control ; event . time = ( int ) time ; event . x = dragOverEvent . x ; event . y = dragOverEvent . y ; event . dataTypes = dragOverEvent . dataTypes ; event . feedback = DND . FEEDBACK_SELECT ; event . operations = dragOverEvent . operations ; event . dataType = dragOverEvent . dataType ; event . detail = dragOverEvent . detail ; notifyListeners ( DND . DragOver , event ) ; effect . show ( event . feedback , event . x , event . y ) ; } else { delay = ( int ) ( dragOverStart - time ) ; } control . getDisplay ( ) . timerExec ( delay , dragOverHeartbeat ) ; }', 'private int dropProcCallback ( int widget , int client_data , int call_data ) { updateDragOverHover ( 0 , null ) ; effect . show ( DND . FEEDBACK_NONE , 0 , 0 ) ; droppedEventData = new XmDropProcCallback ( ) ; OS . memmove ( droppedEventData , call_data , XmDropProcCallback . sizeof ) ; DNDEvent event = new DNDEvent ( ) ; event . widget = this . control ; event . time = droppedEventData . timeStamp ; short root_x = new short 1 ; short root_y = new short 1 ; OS . XtTranslateCoords ( this . control . handle , ( short ) droppedEventData . x , ( short ) droppedEventData . y , root_x , root_y ) ; event . x = root_x 0 ; event . y = root_y 0 ; event . dataTypes = dataTypes ; event . operations = osOpToOp ( droppedEventData . operations ) ; event . dataType = selectedDataType ; event . detail = osOpToOp ( droppedEventData . operation ) ; try { notifyListeners ( DND . DropAccept , event ) ; } catch ( Throwable err ) { event . detail = DND . DROP_NONE ; event . dataType = null ; } selectedDataType = null ; for ( int i = 0 ; i < dataTypes . length ; i + + ) { if ( dataTypes i . equals ( event . dataType ) ) { selectedDataType = event . dataType ; break ; } } int lastOperation = DND . DROP_NONE ; if ( selectedDataType ! = null ( ( event . detail osOpToOp ( droppedEventData . operations ) ) = = event . detail ) ) { lastOperation = event . detail ; } if ( lastOperation = = DND . DROP_NONE ) { / / this was not a successful drop int args = new int { OS . XmNtransferStatus , OS . XmTRANSFER_FAILURE , OS . XmNnumDropTransfers , 0 } ; dropTransferObject = OS . XmDropTransferStart ( droppedEventData . dragContext , args , args . length / 2 ) ; return 0 ; } / / ask drag source for dropped data int transferEntries = new int 2 ; transferEntries 0 = 0 ; transferEntries 1 = selectedDataType . type ; int pTransferEntries = OS . XtMalloc ( transferEntries . length * 4 ) ; OS . memmove ( pTransferEntries , transferEntries , transferEntries . length * 4 ) ; if ( transferProc = = null ) transferProc = new Callback ( this , "transferProcCallback" , 7 ) ; if ( transferProc ! = null ) { int args = new int { OS . XmNdropTransfers , pTransferEntries , OS . XmNnumDropTransfers , transferEntries . length / 2 , OS . XmNtransferProc , transferProc . getAddress ( ) } ; dropTransferObject = OS . XmDropTransferStart ( droppedEventData . dragContext , args , args . length / 2 ) ; OS . XtFree ( pTransferEntries ) ; } return 0 ; }', '/ * * * Returns the Control which is registered for this DropTarget . This is the control over which the * user positions the cursor to drop the data . * * return the Control which is registered for this DropTarget * * / public Control getControl ( ) { return control ; }', 'public Display getDisplay ( ) { if ( control = = null ) DND . error ( SWT . ERROR_WIDGET_DISPOSED ) ; return control . getDisplay ( ) ; }', '/ * * * Returns the list of data types that can be transferred to this DropTarget . * * return the list of data types that can be transferred to this DropTarget * * / public Transfer getTransfer ( ) { return transferAgents ; }', 'public void notifyListeners ( int eventType , Event event ) { Point coordinates = new Point ( event . x , event . y ) ; coordinates = control . toControl ( coordinates ) ; if ( this . control instanceof Tree ) { event . item = ( ( Tree ) control ) . getItem ( coordinates ) ; } if ( this . control instanceof Table ) { event . item = ( ( Table ) control ) . getItem ( coordinates ) ; } super . notifyListeners ( eventType , event ) ; }', 'private void onDispose ( ) { if ( dropProc ! = null ) dropProc . dispose ( ) ; dropProc = null ; if ( transferProc ! = null ) transferProc . dispose ( ) ; transferProc = null ; if ( dragProc ! = null ) dragProc . dispose ( ) ; dragProc = null ; / / if ( control ! = null ! control . isDisposed ( ) ) { / / OS . XmDropSiteUnregister ( control . handle ) ; / / } if ( controlListener ! = null ) { control . removeListener ( SWT . Dispose , controlListener ) ; } controlListener = null ; control = null ; transferAgents = null ; }', 'private byte opToOsOp ( int operation ) { byte osOperation = OS . XmDROP_NOOP ; if ( ( operation DND . DROP_COPY ) = = DND . DROP_COPY ) osOperation = OS . XmDROP_COPY ; if ( ( operation DND . DROP_MOVE ) = = DND . DROP_MOVE ) osOperation = OS . XmDROP_MOVE ; if ( ( operation DND . DROP_LINK ) = = DND . DROP_LINK ) osOperation = OS . XmDROP_LINK ; return osOperation ; }', 'private int osOpToOp ( byte osOperation ) { int operation = DND . DROP_NONE ; if ( ( osOperation OS . XmDROP_COPY ) = = OS . XmDROP_COPY ) operation = DND . DROP_COPY ; if ( ( osOperation OS . XmDROP_MOVE ) = = OS . XmDROP_MOVE ) operation = DND . DROP_MOVE ; if ( ( osOperation OS . XmDROP_LINK ) = = OS . XmDROP_LINK ) operation = DND . DROP_LINK ; return operation ; }', 'private void releaseDropInfo ( ) { selectedDataType = null ; dataTypes = new TransferData 0 ; droppedEventData = null ; dropTransferObject = 0 ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDropListener ( DropTargetListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( DND . DragEnter , listener ) ; removeListener ( DND . DragLeave , listener ) ; removeListener ( DND . DragOver , listener ) ; removeListener ( DND . DragOperationChanged , listener ) ; removeListener ( DND . Drop , listener ) ; removeListener ( DND . DropAccept , listener ) ; }', '/ * * * Specifies the list of data types that can be transferred to this DropTarget . * * param transferAgents a list of Transfer objects which define the types of data that can be * dropped on this target * / public void setTransfer ( Transfer transferAgents ) { this . transferAgents = transferAgents ; / / register data types TransferData transferData = new TransferData 0 ; for ( int i = 0 , length = transferAgents . length ; i < length ; i + + ) { TransferData data = transferAgents i . getSupportedTypes ( ) ; TransferData newTransferData = new TransferData transferData . length + data . length ; System . arraycopy ( transferData , 0 , newTransferData , 0 , transferData . length ) ; System . arraycopy ( data , 0 , newTransferData , transferData . length , data . length ) ; transferData = newTransferData ; } int atoms = new int transferData . length ; for ( int i = 0 , length = transferData . length ; i < length ; i + + ) { atoms i = transferData i . type ; } / / Copy import targets to global memory int pImportTargets = OS . XtMalloc ( atoms . length * 4 ) ; OS . memmove ( pImportTargets , atoms , atoms . length * 4 ) ; int args = new int { OS . XmNimportTargets , pImportTargets , OS . XmNnumImportTargets , atoms . length } ; OS . XmDropSiteUpdate ( control . handle , args , args . length / 2 ) ; OS . XtFree ( pImportTargets ) ; }', 'private int transferProcCallback ( int widget , int client_data , int pSelection , int pType , int pValue , int pLength , int pFormat ) { int type = new int 1 ; OS . memmove ( type , pType , 4 ) ; / / get dropped data object Transfer transferAgent = null ; TransferData transferData = new TransferData ( ) ; transferData . type = type 0 ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { if ( transferAgents i . isSupportedType ( transferData ) ) { transferAgent = transferAgents i ; break ; } } if ( transferAgent ! = null ) { transferData . pValue = pValue ; int length = new int 1 ; OS . memmove ( length , pLength , 4 ) ; transferData . length = length 0 ; int format = new int 1 ; OS . memmove ( format , pFormat , 4 ) ; transferData . format = format 0 ; Object data = transferAgent . nativeToJava ( transferData ) ; OS . XtFree ( transferData . pValue ) ; / / ? ? Should we be freeing this , and what about the other memory ? / / notify listeners of drop DNDEvent event = new DNDEvent ( ) ; event . widget = this . control ; event . time = droppedEventData . timeStamp ; short root_x = new short 1 ; short root_y = new short 1 ; OS . XtTranslateCoords ( this . control . handle , ( short ) droppedEventData . x , ( short ) droppedEventData . y , root_x , root_y ) ; event . x = root_x 0 ; event . y = root_y 0 ; event . dataTypes = dataTypes ; event . operations = osOpToOp ( droppedEventData . operations ) ; event . dataType = transferData ; event . detail = osOpToOp ( droppedEventData . operation ) ; event . data = data ; try { notifyListeners ( DND . Drop , event ) ; } catch ( Throwable err ) { event . detail = DND . DROP_NONE ; } if ( ( event . detail DND . DROP_MOVE ) = = DND . DROP_MOVE ) { OS . XmDropTransferAdd ( dropTransferObject , new int { 0 , Transfer . registerType ( "DELETE 0" ) } , 1 ) ; } } return 0 ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = DropTarget . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }'], 'label': 0}
{'guid': '1839d9b_0bda4b53f6647466b66b1e038d42b8be97ac2ba4', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private FileTransfer ( ) { }', '/ * * * Returns the singleton instance of the FileTransfer class . * * return the singleton instance of the FileTransfer class * / public static FileTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a list of filenames to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a list of file names * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof String ) ) return ; / / build a byte array from data String files = ( String ) object ; / / create a string separated by "new lines" to represent list of files String nativeFormat = "file : " ; for ( int i = 0 , length = files . length ; i < length ; i + + ) { nativeFormat + = files i + " r" ; } nativeFormat + = " 0" ; / / pass byte array on to super to convert to native super . javaToNative ( nativeFormat . getBytes ( ) , transferData ) ; }', '/ * * * Converts a platform specific representation of a list of file names to a Java array of String . * * param transferData the platform specific representation of the data that has been transferred * return a Java array of String containing a list of file names if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { byte data = ( byte ) super . nativeToJava ( transferData ) ; if ( data = = null ) return null ; String string = new String ( data ) ; / / parse data and convert string to array of files int start = string . indexOf ( "file : " ) ; if ( start = = - 1 ) return null ; start + = 5 ; String fileNames = new String 0 ; while ( start < string . length ( ) ) { int end = string . indexOf ( " r" , start ) ; if ( end = = - 1 ) end = string . length ( ) - 1 ; String fileName = string . substring ( start , end ) ; String newFileNames = new String fileNames . length + 1 ; System . arraycopy ( fileNames , 0 , newFileNames , 0 , fileNames . length ) ; newFileNames fileNames . length = fileName ; fileNames = newFileNames ; start = string . indexOf ( "file : " , end ) ; if ( start = = - 1 ) break ; start + = 5 ; } return fileNames ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID } ; }'], 'label': 0}
{'guid': '1839d9b_f2b015d4b0213ffbbb9b5bbf483b2841f42e3bf6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private RTFTransfer ( ) { }', '/ * * * Returns the singleton instance of the RTFTransfer class . * * return the singleton instance of the RTFTransfer class * / public static RTFTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a RTF - formatted Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof String ) ) return ; String text = ( String ) object ; super . javaToNative ( text . getBytes ( ) , transferData ) ; }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { / / get byte array from super byte buffer = ( byte ) super . nativeToJava ( transferData ) ; if ( buffer = = null ) return null ; / / convert byte array to a string return new String ( buffer ) ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_7b9e962ca34d6e7e0410d0bd288dbc90a3d71cef', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TableDragUnderEffect ( Table table ) { this . table = table ; }', 'void show ( int effect , int x , int y ) { TableItem item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect = = DND . FEEDBACK_NONE effect ! = DND . FEEDBACK_NONE ) { selection = table . getSelection ( ) ; table . deselectAll ( ) ; } scrollHover ( effect , item , x , y ) ; setDragUnderEffect ( effect , item ) ; if ( currentEffect ! = DND . FEEDBACK_NONE effect = = DND . FEEDBACK_NONE ) { table . setSelection ( selection ) ; selection = new TableItem 0 ; } currentEffect = effect ; }', 'private TableItem findItem ( int x , int y ) { if ( table = = null ) return null ; Point coordinates = new Point ( x , y ) ; coordinates = table . toControl ( coordinates ) ; TableItem item = table . getItem ( coordinates ) ; if ( item ! = null ) return item ; Rectangle area = table . getClientArea ( ) ; for ( int x1 = area . x ; x1 < area . x + area . width ; x1 + + ) { coordinates = new Point ( x1 , y ) ; coordinates = table . toControl ( coordinates ) ; item = table . getItem ( coordinates ) ; if ( item ! = null ) return item ; } return null ; }', 'private void setDragUnderEffect ( int effect , TableItem item ) { if ( ( effect DND . FEEDBACK_SELECT ) ! = 0 ) { setDropSelection ( item ) ; return ; } if ( ( currentEffect DND . FEEDBACK_SELECT ) ! = 0 ) setDropSelection ( null ) ; }', 'private void setDropSelection ( TableItem item ) { if ( item = = dropSelection ) return ; if ( dropSelection ! = null ) table . deselectAll ( ) ; dropSelection = item ; if ( dropSelection ! = null ) table . setSelection ( new TableItem { dropSelection } ) ; }', 'private void scrollHover ( int effect , TableItem item , int x , int y ) { if ( ( effect DND . FEEDBACK_SCROLL ) = = 0 ) { scrollBeginTime = 0 ; scrollItem = null ; return ; } if ( scrollItem = = item scrollBeginTime ! = 0 ) { if ( System . currentTimeMillis ( ) > = scrollBeginTime ) { scroll ( item , x , y ) ; scrollBeginTime = 0 ; scrollItem = null ; } return ; } scrollBeginTime = System . currentTimeMillis ( ) + SCROLL_HYSTERESIS ; scrollItem = item ; }', 'private void scroll ( TableItem item , int x , int y ) { if ( item = = null ) return ; Point coordinates = new Point ( x , y ) ; coordinates = table . toControl ( coordinates ) ; Rectangle area = table . getClientArea ( ) ; TableItem showItem = null ; int itemIndex = table . indexOf ( item ) ; if ( coordinates . y - area . y < SCROLL_WIDTH ) { showItem = table . getItem ( Math . max ( 0 , itemIndex - 1 ) ) ; } else if ( ( area . y + area . height - coordinates . y ) < SCROLL_WIDTH ) { showItem = table . getItem ( Math . min ( table . getItemCount ( ) - 1 , itemIndex + 1 ) ) ; } if ( showItem ! = null ) { table . showItem ( showItem ) ; } }'], 'label': 0}
{'guid': '1839d9b_93fb0cf71e72fa181ce90f99d4dd2894c2430f53', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private TextTransfer ( ) { }', '/ * * * Returns the singleton instance of the TextTransfer class . * * return the singleton instance of the TextTransfer class * / public static TextTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a plain text Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof String ) ) return ; String text = ( String ) object ; super . javaToNative ( text . getBytes ( ) , transferData ) ; }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { / / get byte array from super byte buffer = ( byte ) super . nativeToJava ( transferData ) ; if ( buffer = = null ) return null ; / / convert byte array to a string return new String ( buffer ) ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME1 , TYPENAME2 , TYPENAME3 } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID1 , TYPEID2 , TYPEID3 } ; }'], 'label': 0}
{'guid': '1839d9b_adfd3078154fcc587776e17eda486831fffd9a58', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Returns a list of the data types that can be transferred using this Transfer agent . * * < p > Only the data type fields of the TransferData Object are filled in . < / p > * * return a list of the data types that can be transferred using this Transfer agent * / abstract public TransferData getSupportedTypes ( ) ;', '/ * * * Returns true if the transferData data type can be transferred using this Transfer agent . * * param transferData a platform specific description of a data type ; only the data type fields * of the TransferData Object need to be filled in * * return true if the transferData data type can be transferred using this Transfer agent * / abstract public boolean isSupportedType ( TransferData transferData ) ;', 'abstract protected String getTypeNames ( ) ;', 'abstract protected int getTypeIds ( ) ;', 'abstract protected void javaToNative ( Object object , TransferData transferData ) ;', 'abstract protected Object nativeToJava ( TransferData transferData ) ;', '/ * * * Registers a name for a data type and returns the associated unique identifier . * * < p > You may register the same type more than once , the same unique identifier will be returned if the * type has been previously registered . < / p > * * < p > Note : Do < b > not < / b > call this method with pre - defined Clipboard Format types such as CF_TEXT * or CF_BITMAP because the pre - defined value will not be returned < / p > * * param formatName the name of a data type * * return the unique identifier associated with htis data type * / public static int registerType ( String formatName ) { int xDisplay = Display . getDefault ( ) . xDisplay ; / / using default because we don t have a particular widget / * Use the character encoding for the default locale * / byte bName = Converter . wcsToMbcs ( null , formatName , false ) ; int atom = OS . XmInternAtom ( xDisplay , bName , false ) ; return atom ; }'], 'label': 0}
{'guid': '1839d9b_19562957a4138404fe28d49a5339095cb7c1baae', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_4dc65a9ae6688d2253193b40d4f8f6d2d5b0ebe2', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TreeDragUnderEffect ( Tree tree ) { this . tree = tree ; }', 'void show ( int effect , int x , int y ) { effect = checkEffect ( effect ) ; TreeItem item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect = = DND . FEEDBACK_NONE effect ! = DND . FEEDBACK_NONE ) { selection = tree . getSelection ( ) ; tree . deselectAll ( ) ; } scrollHover ( effect , item , x , y ) ; expandHover ( effect , item , x , y ) ; setDragUnderEffect ( effect , item ) ; if ( currentEffect ! = DND . FEEDBACK_NONE effect = = DND . FEEDBACK_NONE ) { tree . setSelection ( selection ) ; selection = new TreeItem 0 ; } currentEffect = effect ; }', 'private int checkEffect ( int effect ) { / / Some effects are mutually exclusive . Make sure that only one of the mutually exclusive effects has been specified . int mask = DND . FEEDBACK_INSERT_AFTER DND . FEEDBACK_INSERT_BEFORE DND . FEEDBACK_SELECT ; int bits = effect mask ; if ( bits = = DND . FEEDBACK_INSERT_AFTER bits = = DND . FEEDBACK_INSERT_BEFORE bits = = DND . FEEDBACK_SELECT ) return effect ; return ( effect mask ) ; }', 'private TreeItem findItem ( int x , int y ) { Point coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; Rectangle area = tree . getClientArea ( ) ; if ( ! area . contains ( coordinates ) ) return null ; TreeItem item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; / / Scan across the width of the tree . for ( int x1 = area . x ; x1 < area . x + area . width ; x1 + + ) { coordinates = new Point ( x1 , coordinates . y ) ; item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; } / / Check if we are just below the last item of the tree coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; if ( coordinates . y > area . y + area . height - tree . getItemHeight ( ) ) { ; int y1 = area . y + area . height - tree . getItemHeight ( ) ; coordinates = new Point ( coordinates . x , y1 ) ; item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; / / Scan across the width of the tree just above the bottom . . for ( int x1 = area . x ; x1 < area . x + area . width ; x1 + + ) { coordinates = new Point ( x1 , y1 ) ; item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; } } return null ; }', 'private void setDragUnderEffect ( int effect , TreeItem item ) { if ( ( effect DND . FEEDBACK_SELECT ) ! = 0 ) { if ( ( currentEffect DND . FEEDBACK_INSERT_AFTER ) ! = 0 ( currentEffect DND . FEEDBACK_INSERT_BEFORE ) ! = 0 ) { tree . setInsertMark ( null , false ) ; } setDropSelection ( item ) ; return ; } if ( ( effect DND . FEEDBACK_INSERT_AFTER ) ! = 0 ( effect DND . FEEDBACK_INSERT_BEFORE ) ! = 0 ) { if ( ( currentEffect DND . FEEDBACK_SELECT ) ! = 0 ) { setDropSelection ( null ) ; } setInsertMark ( item , ( effect DND . FEEDBACK_INSERT_BEFORE ) ! = 0 ) ; return ; } setInsertMark ( null , false ) ; setDropSelection ( null ) ; }', 'private void setDropSelection ( TreeItem item ) { if ( item = = dropSelection ) return ; if ( dropSelection ! = null ) tree . deselectAll ( ) ; dropSelection = item ; if ( dropSelection ! = null ) tree . setSelection ( new TreeItem { dropSelection } ) ; }', 'private void setInsertMark ( TreeItem item , boolean before ) { if ( item = = insertMark before = = insertBefore ) return ; insertMark = item ; insertBefore = before ; tree . setInsertMark ( item , before ) ; }', 'private void scrollHover ( int effect , TreeItem item , int x , int y ) { if ( ( effect DND . FEEDBACK_SCROLL ) = = 0 ) { scrollBeginTime = 0 ; scrollItem = null ; return ; } if ( scrollItem = = item scrollBeginTime ! = 0 ) { if ( System . currentTimeMillis ( ) > = scrollBeginTime ) { scroll ( item , x , y ) ; scrollBeginTime = 0 ; scrollItem = null ; } return ; } scrollBeginTime = System . currentTimeMillis ( ) + SCROLL_HYSTERESIS ; scrollItem = item ; }', 'private void scroll ( TreeItem item , int x , int y ) { if ( item = = null ) return ; Point coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; Rectangle area = tree . getClientArea ( ) ; TreeItem showItem = null ; if ( coordinates . y - area . y < SCROLL_WIDTH ) { showItem = getPreviousVisibleItem ( item ) ; } else if ( ( area . y + area . height - coordinates . y ) < SCROLL_WIDTH ) { showItem = getNextVisibleItem ( item , true ) ; } if ( showItem ! = null ) { tree . showItem ( showItem ) ; } }', 'private void expandHover ( int effect , TreeItem item , int x , int y ) { if ( ( effect DND . FEEDBACK_EXPAND ) = = 0 ) { expandBeginTime = 0 ; expandItem = null ; return ; } if ( expandItem = = item expandBeginTime ! = 0 ) { if ( System . currentTimeMillis ( ) > = expandBeginTime ) { expand ( item , x , y ) ; expandBeginTime = 0 ; expandItem = null ; } return ; } expandBeginTime = System . currentTimeMillis ( ) + EXPAND_HYSTERESIS ; expandItem = item ; }', 'private void expand ( TreeItem item , int x , int y ) { if ( item = = null item . getExpanded ( ) ) return ; Event event = new Event ( ) ; event . x = x ; event . y = y ; event . item = item ; event . time = ( int ) System . currentTimeMillis ( ) ; tree . notifyListeners ( SWT . Expand , event ) ; if ( item . isDisposed ( ) ) return ; item . setExpanded ( true ) ; }', 'private TreeItem getNextVisibleItem ( TreeItem item , boolean includeChildren ) { / / look down / / neccesary on the first pass only if ( includeChildren item . getItemCount ( ) > 0 item . getExpanded ( ) ) { return item . getItems ( ) 0 ; } / / look sideways TreeItem parent = item . getParentItem ( ) ; TreeItem peers = ( parent ! = null ) ? parent . getItems ( ) : tree . getItems ( ) ; for ( int i = 0 ; i < peers . length - 1 ; i + + ) { if ( peers i = = item ) return peers i + 1 ; } / / look up if ( parent ! = null ) return getNextVisibleItem ( parent , false ) ; return null ; }', 'private TreeItem getPreviousVisibleItem ( TreeItem item ) { / / look sideways TreeItem parent = item . getParentItem ( ) ; TreeItem peers = ( parent ! = null ) ? parent . getItems ( ) : tree . getItems ( ) ; for ( int i = peers . length - 1 ; i > 0 ; i - - ) { if ( peers i = = item ) { TreeItem peer = peers i - 1 ; if ( ! peer . getExpanded ( ) peer . getItemCount ( ) = = 0 ) return peer ; TreeItem peerItems = peer . getItems ( ) ; return peerItems peerItems . length - 1 ; } } / / look up return parent ; }'], 'label': 0}
{'guid': '1839d9b_3ab0c9971dd206a84406c7241fb79521fbd5133f', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public TransferData getSupportedTypes ( ) { int types = getTypeIds ( ) ; TransferData data = new TransferData types . length ; for ( int i = 0 ; i < types . length ; i + + ) { data i = new TransferData ( ) ; data i . type = types i ; } return data ; }', 'public boolean isSupportedType ( TransferData transferData ) { int types = getTypeIds ( ) ; for ( int i = 0 ; i < types . length ; i + + ) { if ( transferData . type = = types i ) return true ; } return false ; }', 'protected void javaToNative ( Object object , TransferData transferData ) { if ( ( object = = null ) ! ( object instanceof byte ) ! ( isSupportedType ( transferData ) ) ) { transferData . result = 0 ; return ; } byte buffer = ( byte ) object ; transferData . pData = OS . malloc ( buffer . length ) ; OS . memmove ( transferData . pData , buffer , buffer . length ) ; transferData . length = buffer . length ; transferData . result = 1 ; }', 'protected Object nativeToJava ( TransferData transferData ) { if ( transferData . pData = = 0 ! ( isSupportedType ( transferData ) ) ) return null ; int size = transferData . length ; if ( size = = 0 ) return null ; byte buffer = new byte size ; OS . memmove ( buffer , transferData . pData , size ) ; return buffer ; }'], 'label': 0}
{'guid': '1839d9b_f9f4ac47c28af480afb61cb8fd1394a74c974d6a', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public Clipboard ( Display display ) { checkSubclass ( ) ; if ( display = = null ) { display = Display . getCurrent ( ) ; if ( display = = null ) { display = Display . getDefault ( ) ; } } if ( display . getThread ( ) ! = Thread . currentThread ( ) ) { SWT . error ( SWT . ERROR_THREAD_INVALID_ACCESS ) ; } this . display = display ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = Clipboard . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }', 'public void dispose ( ) { display = null ; }', 'public Object getContents ( Transfer transfer ) { if ( display . isDisposed ( ) ) return null ; Object result = null ; int ig = OS . PhInputGroup ( 0 ) ; int cbdata = OS . PhClipboardPasteStart ( ( short ) ig ) ; if ( cbdata = = 0 ) return result ; try { String types = transfer . getTypeNames ( ) ; int ids = transfer . getTypeIds ( ) ; for ( int i = 0 ; i < types . length ; i + + ) { byte type = Converter . wcsToMbcs ( null , types i , true ) ; int pClipHeader = OS . PhClipboardPasteType ( cbdata , type ) ; if ( pClipHeader ! = 0 ) { PhClipHeader clipHeader = new PhClipHeader ( ) ; OS . memmove ( clipHeader , pClipHeader , PhClipHeader . sizeof ) ; TransferData data = new TransferData ( ) ; data . pData = clipHeader . data ; data . length = clipHeader . length ; data . type = ids i ; result = transfer . nativeToJava ( data ) ; break ; } } } finally { OS . PhClipboardPasteFinish ( cbdata ) ; } return result ; }', 'public void setContents ( Object data , Transfer transferAgents ) { if ( display . isDisposed ( ) ) return ; if ( data = = null ) { int ig = OS . PhInputGroup ( 0 ) ; if ( OS . PhClipboardCopy ( ( short ) ig , 0 , null ) ! = 0 ) { DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; } return ; } if ( transferAgents = = null data . length ! = transferAgents . length ) { DND . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } PhClipHeader clips = new PhClipHeader 0 ; int count = 0 ; for ( int i = 0 ; i < transferAgents . length ; i + + ) { String names = transferAgents i . getTypeNames ( ) ; int ids = transferAgents i . getTypeIds ( ) ; for ( int j = 0 ; j < names . length ; j + + ) { TransferData transferData = new TransferData ( ) ; transferData . type = ids j ; transferAgents i . javaToNative ( data i , transferData ) ; PhClipHeader clip = new PhClipHeader ( ) ; clip . data = transferData . pData ; clip . length = ( short ) transferData . length ; byte temp = Converter . wcsToMbcs ( null , names j , false ) ; byte type = new byte 8 ; System . arraycopy ( temp , 0 , type , 0 , Math . min ( type . length , temp . length ) ) ; clip . type_0 = type 0 ; clip . type_1 = type 1 ; clip . type_2 = type 2 ; clip . type_3 = type 3 ; clip . type_4 = type 4 ; clip . type_5 = type 5 ; clip . type_6 = type 6 ; clip . type_7 = type 7 ; PhClipHeader newClips = new PhClipHeader count + 1 ; System . arraycopy ( clips , 0 , newClips , 0 , clips . length ) ; clips = newClips ; clips count + + = clip ; } } if ( count = = 0 ) return ; / / Copy data to clipboard byte buffer = new byte count * PhClipHeader . sizeof ; byte temp = new byte PhClipHeader . sizeof ; for ( int i = 0 ; i < count ; i + + ) { OS . memmove ( temp , clips i , PhClipHeader . sizeof ) ; System . arraycopy ( temp , 0 , buffer , i * PhClipHeader . sizeof , temp . length ) ; } int ig = OS . PhInputGroup ( 0 ) ; if ( OS . PhClipboardCopy ( ( short ) ig , count , buffer ) ! = 0 ) { DND . error ( DND . ERROR_CANNOT_SET_CLIPBOARD ) ; } / / Free allocated data for ( int i = 0 ; i < count ; i + + ) { OS . free ( clips i . data ) ; } }', 'public String getAvailableTypeNames ( ) { String types = new String 0 ; int ig = OS . PhInputGroup ( 0 ) ; int cbdata = OS . PhClipboardPasteStart ( ( short ) ig ) ; if ( cbdata = = 0 ) return types ; try { int pClipHeader = 0 ; int n = 0 ; while ( ( pClipHeader = OS . PhClipboardPasteTypeN ( cbdata , n + + ) ) ! = 0 ) { PhClipHeader clipHeader = new PhClipHeader ( ) ; OS . memmove ( clipHeader , pClipHeader , PhClipHeader . sizeof ) ; byte buffer = new byte 8 ; buffer 0 = clipHeader . type_0 ; buffer 1 = clipHeader . type_1 ; buffer 2 = clipHeader . type_2 ; buffer 3 = clipHeader . type_3 ; buffer 4 = clipHeader . type_4 ; buffer 5 = clipHeader . type_5 ; buffer 6 = clipHeader . type_6 ; buffer 7 = clipHeader . type_7 ; char unicode = Converter . mbcsToWcs ( null , buffer ) ; String newTypes = new String types . length + 1 ; System . arraycopy ( types , 0 , newTypes , 0 , types . length ) ; newTypes types . length = new String ( unicode ) . trim ( ) ; types = newTypes ; } } finally { OS . PhClipboardPasteFinish ( cbdata ) ; } return types ; }'], 'label': 0}
{'guid': '1839d9b_9c3fedd6a6e040882312983ad9c92427d1727d74', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DragSource < / code > to handle dragging from the specified < code > Control < / code > . * * param control the < code > Control < / code > that the user clicks on to initiate the drag * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DragSource ( Control control , int style ) { super ( control , checkStyle ( style ) ) ; this . control = control ; controlListener = new Listener ( ) { public void handleEvent ( Event event ) { if ( event . type = = SWT . Dispose ) { if ( ! DragSource . this . isDisposed ( ) ) { DragSource . this . dispose ( ) ; } } if ( event . type = = SWT . DragDetect ) { / / DragSource . this . drag ( ) ; } } } ; this . control . addListener ( SWT . Dispose , controlListener ) ; this . control . addListener ( SWT . DragDetect , controlListener ) ; this . addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { / / onDispose ( ) ; } } ) ; }', 'public void handleEvent ( Event event ) { if ( event . type = = SWT . Dispose ) { if ( ! DragSource . this . isDisposed ( ) ) { DragSource . this . dispose ( ) ; } } if ( event . type = = SWT . DragDetect ) { / / DragSource . this . drag ( ) ; } }', 'public void handleEvent ( Event event ) { / / onDispose ( ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDragListener ( DragSourceListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; DNDListener typedListener = new DNDListener ( listener ) ; addListener ( DND . DragStart , typedListener ) ; addListener ( DND . DragSetData , typedListener ) ; addListener ( DND . DragEnd , typedListener ) ; }', 'static int checkStyle ( int style ) { if ( style = = SWT . NONE ) return DND . DROP_MOVE ; return style ; }', '/ * * * Returns the Control which is registered for this DragSource . This is the control that the * user clicks in to initiate dragging . * * return the Control which is registered for this DragSource * / public Control getControl ( ) { return control ; }', '/ * * * Gets the Display . * / public Display getDisplay ( ) { if ( control = = null ) DND . error ( SWT . ERROR_WIDGET_DISPOSED ) ; return control . getDisplay ( ) ; }', '/ * * * Returns the list of data types that can be transferred by this DragSource . * * return the list of data types that can be transferred by this DragSource * / public Transfer getTransfer ( ) { return transferAgents ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDragListener ( DragSourceListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( DND . DragStart , listener ) ; removeListener ( DND . DragSetData , listener ) ; removeListener ( DND . DragEnd , listener ) ; }', '/ * * * Specifies the list of data types that can be transferred by this DragSource . * The application must be able to provide data to match each of these types when * a successful drop has occurred . * / public void setTransfer ( Transfer transferAgents ) { this . transferAgents = transferAgents ; }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = DragSource . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }'], 'label': 0}
{'guid': '1839d9b_1abeb8104dc60decfa03b73f1a91dd86443c1a47', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Creates a new < code > DropTarget < / code > to handle dropping on the specified < code > Control < / code > . * * param control the < code > Control < / code > over which the user positions the cursor to drop data * * param style the bitwise OR ing of allowed operations ; this may be a combination of any of * DND . DROP_NONE , DND . DROP_COPY , DND . DROP_MOVE , DND . DROP_LINK * * / public DropTarget ( Control control , int style ) { super ( control , checkStyle ( style ) ) ; this . control = control ; controlListener = new Listener ( ) { public void handleEvent ( Event event ) { if ( ! DropTarget . this . isDisposed ( ) ) { DropTarget . this . dispose ( ) ; } } } ; control . addListener ( SWT . Dispose , controlListener ) ; this . addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { / / onDispose ( ) ; } } ) ; if ( control instanceof Tree ) { effect = new TreeDragUnderEffect ( ( Tree ) control ) ; } else if ( control instanceof Table ) { effect = new TableDragUnderEffect ( ( Table ) control ) ; } else { effect = new NoDragUnderEffect ( control ) ; } }', 'public void handleEvent ( Event event ) { if ( ! DropTarget . this . isDisposed ( ) ) { DropTarget . this . dispose ( ) ; } }', 'public void handleEvent ( Event event ) { / / onDispose ( ) ; }', '/ * * * Adds the listener to receive events . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void addDropListener ( DropTargetListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; DNDListener typedListener = new DNDListener ( listener ) ; addListener ( DND . DragEnter , typedListener ) ; addListener ( DND . DragLeave , typedListener ) ; addListener ( DND . DragOver , typedListener ) ; addListener ( DND . DragOperationChanged , typedListener ) ; addListener ( DND . Drop , typedListener ) ; addListener ( DND . DropAccept , typedListener ) ; }', 'static int checkStyle ( int style ) { if ( style = = SWT . NONE ) return DND . DROP_MOVE ; return style ; }', '/ * * * Returns the Control which is registered for this DropTarget . This is the control over which the * user positions the cursor to drop the data . * * return the Control which is registered for this DropTarget * * / public Control getControl ( ) { return control ; }', 'public Display getDisplay ( ) { if ( control = = null ) DND . error ( SWT . ERROR_WIDGET_DISPOSED ) ; return control . getDisplay ( ) ; }', '/ * * * Returns the list of data types that can be transferred to this DropTarget . * * return the list of data types that can be transferred to this DropTarget * * / public Transfer getTransfer ( ) { return transferAgents ; }', 'public void notifyListeners ( int eventType , Event event ) { Point coordinates = new Point ( event . x , event . y ) ; coordinates = control . toControl ( coordinates ) ; if ( this . control instanceof Tree ) { event . item = ( ( Tree ) control ) . getItem ( coordinates ) ; } if ( this . control instanceof Table ) { event . item = ( ( Table ) control ) . getItem ( coordinates ) ; } super . notifyListeners ( eventType , event ) ; }', '/ * * * Removes the listener . * * param listener the listener * * exception SWTError * < ul > < li > ERROR_THREAD_INVALID_ACCESS when called from the wrong thread < / li > * < li > ERROR_WIDGET_DISPOSED when the widget has been disposed < / li > * < li > ERROR_NULL_ARGUMENT when listener is null < / li > < / ul > * / public void removeDropListener ( DropTargetListener listener ) { if ( listener = = null ) DND . error ( SWT . ERROR_NULL_ARGUMENT ) ; removeListener ( DND . DragEnter , listener ) ; removeListener ( DND . DragLeave , listener ) ; removeListener ( DND . DragOver , listener ) ; removeListener ( DND . DragOperationChanged , listener ) ; removeListener ( DND . Drop , listener ) ; removeListener ( DND . DropAccept , listener ) ; }', '/ * * * Specifies the list of data types that can be transferred to this DropTarget . * * param transferAgents a list of Transfer objects which define the types of data that can be * dropped on this target * / public void setTransfer ( Transfer transferAgents ) { }', 'protected void checkSubclass ( ) { String name = getClass ( ) . getName ( ) ; String validName = DropTarget . class . getName ( ) ; if ( ! validName . equals ( name ) ) { DND . error ( SWT . ERROR_INVALID_SUBCLASS ) ; } }'], 'label': 0}
{'guid': '1839d9b_9ba4ffe40b1448fe62193ce438ae4200df318629', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private FileTransfer ( ) { }', '/ * * * Returns the singleton instance of the FileTransfer class . * * return the singleton instance of the FileTransfer class * / public static FileTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a list of filenames to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a list of file names * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { DND . error ( org . eclipse . swt . SWT . ERROR_NOT_IMPLEMENTED ) ; }', '/ * * * Converts a platform specific representation of a list of file names to a Java array of String . * * param transferData the platform specific representation of the data that has been transferred * return a Java array of String containing a list of file names if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { DND . error ( org . eclipse . swt . SWT . ERROR_NOT_IMPLEMENTED ) ; return null ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID } ; }'], 'label': 0}
{'guid': '1839d9b_d7729ddc6b52bf3e6ae47a97ec7bbead5e5a5a62', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private RTFTransfer ( ) { }', '/ * * * Returns the singleton instance of the RTFTransfer class . * * return the singleton instance of the RTFTransfer class * / public static RTFTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a RTF - formatted Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof String ) ) return ; byte buffer = Converter . wcsToMbcs ( null , ( String ) object , true ) ; super . javaToNative ( buffer , transferData ) ; }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { if ( transferData . pData = = 0 ! ( isSupportedType ( transferData ) ) ) return null ; int size = transferData . length ; if ( size = = 0 ) return null ; byte buffer = new byte OS . strlen ( transferData . pData ) ; OS . memmove ( buffer , transferData . pData , buffer . length ) ; / / convert byte array to a string char unicode = Converter . mbcsToWcs ( null , buffer ) ; return new String ( unicode ) ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID } ; }'], 'label': 0}
{'guid': '1839d9b_d9e566bb5d091dcd8e34caad568b364af92c2275', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TableDragUnderEffect ( Table table ) { this . table = table ; }', 'void show ( int effect , int x , int y ) { TableItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = table . getSelection ( ) ; table . setSelection ( new TableItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { table . setSelection ( selection ) ; selection = new TableItem 0 ; } }', 'private TableItem findItem ( int x , int y ) { if ( table = = null ) return null ; Point coordinates = new Point ( x , y ) ; coordinates = table . toControl ( coordinates ) ; TableItem item = table . getItem ( coordinates ) ; if ( item ! = null ) return item ; Rectangle area = table . getClientArea ( ) ; for ( int x1 = area . x ; x1 < area . x + area . width ; x1 + + ) { coordinates = new Point ( x1 , y ) ; coordinates = table . toControl ( coordinates ) ; item = table . getItem ( coordinates ) ; if ( item ! = null ) return item ; } return null ; }', 'private void setDragUnderEffect ( int effect , TableItem item ) { if ( currentItem ! = item ) { if ( item = = null ) { table . setSelection ( new TableItem 0 ) ; } else { table . setSelection ( new TableItem { item } ) ; } currentItem = item ; } currentEffect = effect ; }'], 'label': 0}
{'guid': '1839d9b_d3cc4e6f03cc51ccdf6d3543027f266dd129c6f6', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['private TextTransfer ( ) { }', '/ * * * Returns the singleton instance of the TextTransfer class . * * return the singleton instance of the TextTransfer class * / public static TextTransfer getInstance ( ) { return _instance ; }', '/ * * * Converts a plain text Java String to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java String containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / public void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof String ) ) return ; byte buffer = Converter . wcsToMbcs ( null , ( String ) object , true ) ; super . javaToNative ( buffer , transferData ) ; }', '/ * * * Converts a platform specific representation of a string to a Java String . * * param transferData the platform specific representation of the data that has been transferred * return a Java String containing the transferred data if the conversion was successful ; * otherwise null * / public Object nativeToJava ( TransferData transferData ) { if ( transferData . pData = = 0 ! ( isSupportedType ( transferData ) ) ) return null ; int size = transferData . length ; if ( size = = 0 ) return null ; byte buffer = new byte OS . strlen ( transferData . pData ) ; OS . memmove ( buffer , transferData . pData , buffer . length ) ; / / convert byte array to a string char unicode = Converter . mbcsToWcs ( null , buffer ) ; return new String ( unicode ) ; }', 'protected String getTypeNames ( ) { return new String { TYPENAME } ; }', 'protected int getTypeIds ( ) { return new int { TYPEID } ; }'], 'label': 0}
{'guid': '1839d9b_7984436caf1b250262ecf4b5f53a864abaa33e61', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['/ * * * Returns a list of the data types that can be transferred using this Transfer agent . * * < p > Only the data type fields of the TransferData Object are filled in . < / p > * * return a list of the data types that can be transferred using this Transfer agent * / abstract public TransferData getSupportedTypes ( ) ;', '/ * * * Returns true if the transferData data type can be transferred using this Transfer agent . * * param transferData a platform specific description of a data type ; only the data type fields * of the TransferData Object need to be filled in * * return true if the transferData data type can be transferred using this Transfer agent * / abstract public boolean isSupportedType ( TransferData transferData ) ;', 'abstract protected String getTypeNames ( ) ;', 'abstract protected int getTypeIds ( ) ;', 'abstract protected void javaToNative ( Object object , TransferData transferData ) ;', 'abstract protected Object nativeToJava ( TransferData transferData ) ;', '/ * * * Registers a name for a data type and returns the associated unique identifier . * * < p > You may register the same type more than once , the same unique identifier will be returned if the * type has been previously registered . < / p > * * < p > Note : Do < b > not < / b > call this method with pre - defined Clipboard Format types such as CF_TEXT * or CF_BITMAP because the pre - defined value will not be returned < / p > * * param formatName the name of a data type * * return the unique identifier associated with htis data type * / public static int registerType ( String formatName ) { if ( formatName = = "TEXT" ) return 10 ; if ( formatName = = "files" ) return 11 ; if ( formatName = = "RTF" ) return 12 ; return 0 ; }'], 'label': 0}
{'guid': '1839d9b_b287069a6fc394300c8d92e8435c16631fddb639', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': [], 'label': 0}
{'guid': '1839d9b_d37961bda143aca80d2ba1d783fd56810e33aee5', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['TreeDragUnderEffect ( Tree tree ) { this . tree = tree ; }', 'void show ( int effect , int x , int y ) { TreeItem item = null ; if ( effect ! = DND . FEEDBACK_NONE ) item = findItem ( x , y ) ; if ( item = = null ) effect = DND . FEEDBACK_NONE ; if ( currentEffect ! = effect currentEffect = = DND . FEEDBACK_NONE ) { selection = tree . getSelection ( ) ; tree . setSelection ( new TreeItem 0 ) ; } boolean restoreSelection = currentEffect ! = effect effect = = DND . FEEDBACK_NONE ; setDragUnderEffect ( effect , item ) ; if ( restoreSelection ) { tree . setSelection ( selection ) ; selection = new TreeItem 0 ; } }', 'private TreeItem findItem ( int x , int y ) { Point coordinates = new Point ( x , y ) ; coordinates = tree . toControl ( coordinates ) ; TreeItem item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; Rectangle area = tree . getClientArea ( ) ; for ( int x1 = area . x ; x1 < area . x + area . width ; x1 + + ) { coordinates = new Point ( x1 , y ) ; coordinates = tree . toControl ( coordinates ) ; item = tree . getItem ( coordinates ) ; if ( item ! = null ) return item ; } return null ; }', 'private void setDragUnderEffect ( int effect , TreeItem item ) { switch ( effect ) { case DND . FEEDBACK_SELECT : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setDropSelection ( item ) ; currentEffect = DND . FEEDBACK_SELECT ; currentItem = item ; } break ; case DND . FEEDBACK_INSERT_AFTER : case DND . FEEDBACK_INSERT_BEFORE : if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; } if ( currentEffect ! = effect currentItem ! = item ) { setInsertMark ( item , effect = = DND . FEEDBACK_INSERT_AFTER ) ; currentEffect = effect ; currentItem = item ; } break ; default : if ( currentEffect = = DND . FEEDBACK_INSERT_AFTER currentEffect = = DND . FEEDBACK_INSERT_BEFORE ) { setInsertMark ( null , false ) ; } if ( currentEffect = = DND . FEEDBACK_SELECT ) { setDropSelection ( null ) ; } currentEffect = DND . FEEDBACK_NONE ; currentItem = null ; break ; } }', 'private void setDropSelection ( TreeItem item ) { if ( item = = null ) { tree . setSelection ( new TreeItem 0 ) ; } else { tree . setSelection ( new TreeItem { item } ) ; } }', 'private void setInsertMark ( TreeItem item , boolean after ) { / / not currently implemented }'], 'label': 0}
{'guid': '1839d9b_86e486532d362f34d728a54bac396d3b1f2237a3', 'q_paras': ['Detection of CDE as active WM is platform - specific', 'SWT code currently determines the active desktop by looking for defined "atoms" or properties that are associated with the root window . The atom that Eclipse now uses to identify CDE is DTWM_IS_RUNNING . This happens in Program . getDesktop ( ) . CDE on AIX does not define this property . It would be nice to have a string that AIX , HP - UX , and Solaris have in common . Kevin Cornell and I have discussed using _DT_SM_PREFERENCES . which appears to be a defined property for all three platforms .'], 'c_paras': ['public TransferData getSupportedTypes ( ) { int types = getTypeIds ( ) ; TransferData data = new TransferData types . length ; for ( int i = 0 ; i < types . length ; i + + ) { data i = new TransferData ( ) ; data i . type = types i ; data i . formatetc = new FORMATETC ( ) ; data i . formatetc . cfFormat = types i ; data i . formatetc . dwAspect = COM . DVASPECT_CONTENT ; data i . formatetc . lindex = - 1 ; data i . formatetc . tymed = COM . TYMED_HGLOBAL ; } return data ; }', 'public boolean isSupportedType ( TransferData transferData ) { int types = getTypeIds ( ) ; for ( int i = 0 ; i < types . length ; i + + ) { FORMATETC format = transferData . formatetc ; if ( format . cfFormat = = types i ( format . dwAspect COM . DVASPECT_CONTENT ) = = COM . DVASPECT_CONTENT ( format . tymed COM . TYMED_HGLOBAL ) = = COM . TYMED_HGLOBAL ) return true ; } return false ; }', '/ * * * Converts a Java byte array to a platform specific representation . * < p > * On a successful conversion , the transferData . result field will be set as follows : * < ul > * < li > Windows : OLE . S_OK * < li > Motif : 0 * < / ul > * If this transfer agent is unable to perform the conversion , * the transferData . result field will be set to a failure value as follows : * < ul > * < li > Windows : OLE . DV_E_TYMED * < li > Motif : 1 * < / ul > < / p > * * param object a Java byte array containing the data to be transferred * param transferData an empty TransferData object ; this object will be filled in on return * with the platform specific format of the data * / protected void javaToNative ( Object object , TransferData transferData ) { if ( object = = null ! ( object instanceof byte ) ) { transferData . result = COM . E_FAIL ; return ; } byte data = ( byte ) object ; if ( isSupportedType ( transferData ) ) { / / Allocate the memory because the caller ( DropTarget ) has not handed it in / / The caller of this method must release the data when it is done with it . int size = data . length ; int newPtr = OS . GlobalAlloc ( OS . GMEM_FIXED OS . GMEM_ZEROINIT , size ) ; OS . MoveMemory ( newPtr , data , size ) ; transferData . stgmedium = new STGMEDIUM ( ) ; transferData . stgmedium . tymed = COM . TYMED_HGLOBAL ; transferData . stgmedium . unionField = newPtr ; transferData . stgmedium . pUnkForRelease = 0 ; transferData . result = COM . S_OK ; return ; } / / did not match the TYMED transferData . stgmedium = new STGMEDIUM ( ) ; transferData . result = COM . DV_E_TYMED ; }', '/ * * * Converts a platform specific representation of a byte array to a Java byte array . * * param transferData the platform specific representation of the data that has been transferred * return a Java byte array containing the transferred data if the conversion was successful ; * otherwise null * / protected Object nativeToJava ( TransferData transferData ) { if ( ! isSupportedType ( transferData ) transferData . pIDataObject = = 0 ) { transferData . result = COM . E_FAIL ; return null ; } IDataObject data = new IDataObject ( transferData . pIDataObject ) ; data . AddRef ( ) ; FORMATETC formatetc = transferData . formatetc ; STGMEDIUM stgmedium = new STGMEDIUM ( ) ; stgmedium . tymed = COM . TYMED_HGLOBAL ; transferData . result = data . GetData ( formatetc , stgmedium ) ; data . Release ( ) ; if ( transferData . result ! = COM . S_OK ) { return null ; } int size = OS . GlobalSize ( stgmedium . unionField ) ; byte buffer = new byte size ; int ptr = OS . GlobalLock ( stgmedium . unionField ) ; OS . MoveMemory ( buffer , ptr , size ) ; OS . GlobalUnlock ( ptr ) ; OS . GlobalFree ( stgmedium . unionField ) ; return buffer ; }'], 'label': 0}
